{"/home/travis/build/npmtest/node-npmtest-cloc/test.js":"/* istanbul instrument in package npmtest_cloc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cloc/lib.npmtest_cloc.js":"/* istanbul instrument in package npmtest_cloc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cloc = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cloc = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cloc/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cloc && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cloc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cloc\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cloc.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cloc.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cloc.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cloc.__dirname + '/lib.npmtest_cloc.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cloc/node_modules/cloc/lib/cloc":"#!/usr/bin/env perl\n# cloc -- Count Lines of Code                  {{{1\n# Copyright (C) 2006-2017 Al Danial <al.danial@gmail.com>\n# First release August 2006\n#\n# Includes code from:\n#   - SLOCCount v2.26\n#     http://www.dwheeler.com/sloccount/\n#     by David Wheeler.\n#   - Regexp::Common v2013031301\n#     http://search.cpan.org/~abigail/Regexp-Common-2013031301/lib/Regexp/Common.pm\n#     by Damian Conway and Abigail.\n#   - Win32::Autoglob\n#     http://search.cpan.org/~sburke/Win32-Autoglob-1.01/Autoglob.pm\n#     by Sean M. Burke.\n#   - Algorithm::Diff\n#     http://search.cpan.org/~tyemq/Algorithm-Diff-1.1902/lib/Algorithm/Diff.pm\n#     by Tye McQueen.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details:\n# <http://www.gnu.org/licenses/gpl.txt>.\n#\n# 1}}}\nmy $VERSION = \"1.72\";  # odd number == beta; even number == stable\nmy $URL     = \"github.com/AlDanial/cloc\";  # 'https://' pushes header too wide\nrequire 5.006;\n# use modules                                  {{{1\nuse warnings;\nuse strict;\nuse Getopt::Long;\nuse File::Basename;\nuse File::Temp qw { tempfile tempdir };\nuse File::Find;\nuse File::Path;\nuse File::Spec;\nuse IO::File;\nuse POSIX \"strftime\";\n\n# Digest::MD5 isn't in the standard distribution. Use it only if installed.\nmy $HAVE_Digest_MD5 = 0;\neval \"use Digest::MD5;\";\nif (defined $Digest::MD5::VERSION) {\n    $HAVE_Digest_MD5 = 1;\n} else {\n    warn \"Digest::MD5 not installed; will skip file uniqueness checks.\\n\";\n}\n\n# Time::HiRes became standard with Perl 5.8\nmy $HAVE_Time_HiRes = 0;\neval \"use Time::HiRes;\";\n$HAVE_Time_HiRes = 1 if defined $Time::HiRes::VERSION;\n\nmy $HAVE_Rexexp_Common;\n# Regexp::Common isn't in the standard distribution.  It will\n# be installed in a temp directory if necessary.\nBEGIN {\n    if (eval \"use Regexp::Common;\") {\n        $HAVE_Rexexp_Common = 1;\n    } else {\n        $HAVE_Rexexp_Common = 0;\n    }\n}\n\nmy $HAVE_Algorith_Diff = 0;\n# Algorithm::Diff isn't in the standard distribution.  It will\n# be installed in a temp directory if necessary.\neval \"use Algorithm::Diff qw ( sdiff ) \";\nif (defined $Algorithm::Diff::VERSION) {\n    $HAVE_Algorith_Diff = 1;\n} else {\n    Install_Algorithm_Diff();\n}\n# print \"2 HAVE_Algorith_Diff = $HAVE_Algorith_Diff\\n\";\n# test_alg_diff($ARGV[$#ARGV - 1], $ARGV[$#ARGV]); die;\n# die \"Hre=$HAVE_Rexexp_Common  Had=$HAVE_Algorith_Diff\";\n\n# Uncomment next two lines when building Windows executable with perl2exe\n# or if running on a system that already has Regexp::Common.\n#use Regexp::Common;\n#$HAVE_Rexexp_Common = 1;\n\n#perl2exe_include \"Regexp/Common/whitespace.pm\"\n#perl2exe_include \"Regexp/Common/URI.pm\"\n#perl2exe_include \"Regexp/Common/URI/fax.pm\"\n#perl2exe_include \"Regexp/Common/URI/file.pm\"\n#perl2exe_include \"Regexp/Common/URI/ftp.pm\"\n#perl2exe_include \"Regexp/Common/URI/gopher.pm\"\n#perl2exe_include \"Regexp/Common/URI/http.pm\"\n#perl2exe_include \"Regexp/Common/URI/pop.pm\"\n#perl2exe_include \"Regexp/Common/URI/prospero.pm\"\n#perl2exe_include \"Regexp/Common/URI/news.pm\"\n#perl2exe_include \"Regexp/Common/URI/tel.pm\"\n#perl2exe_include \"Regexp/Common/URI/telnet.pm\"\n#perl2exe_include \"Regexp/Common/URI/tv.pm\"\n#perl2exe_include \"Regexp/Common/URI/wais.pm\"\n#perl2exe_include \"Regexp/Common/CC.pm\"\n#perl2exe_include \"Regexp/Common/SEN.pm\"\n#perl2exe_include \"Regexp/Common/number.pm\"\n#perl2exe_include \"Regexp/Common/delimited.pm\"\n#perl2exe_include \"Regexp/Common/profanity.pm\"\n#perl2exe_include \"Regexp/Common/net.pm\"\n#perl2exe_include \"Regexp/Common/zip.pm\"\n#perl2exe_include \"Regexp/Common/comment.pm\"\n#perl2exe_include \"Regexp/Common/balanced.pm\"\n#perl2exe_include \"Regexp/Common/lingua.pm\"\n#perl2exe_include \"Regexp/Common/list.pm\"\n#perl2exe_include \"File/Glob.pm\"\n\nuse Text::Tabs qw { expand };\nuse Cwd qw { cwd };\nuse File::Glob;\n# 1}}}\n# Usage information, options processing.       {{{1\nmy $ON_WINDOWS = 0;\n   $ON_WINDOWS = 1 if ($^O =~ /^MSWin/) or ($^O eq \"Windows_NT\");\nif ($ON_WINDOWS and $ENV{'SHELL'}) {\n    if ($ENV{'SHELL'} =~ m{^/}) {\n        $ON_WINDOWS = 0;  # make Cygwin look like Unix\n    } else {\n        $ON_WINDOWS = 1;  # MKS defines $SHELL but still acts like Windows\n    }\n}\n\nmy $NN     = chr(27) . \"[0m\";  # normal\n   $NN     = \"\" if $ON_WINDOWS or !(-t STDERR); # -t STDERR:  is it a terminal?\nmy $BB     = chr(27) . \"[1m\";  # bold\n   $BB     = \"\" if $ON_WINDOWS or !(-t STDERR);\nmy $script = basename $0;\nmy $brief_usage  = \"\n                       cloc -- Count Lines of Code\n\nUsage:\n    $script [options] <file(s)/dir(s)>\n        Count physical lines of source code and comments in the given files\n        (may be archives such as compressed tarballs or zip files) and/or\n        recursively below the given directories.\n        Example:    cloc src/ include/ main.c\n\n    $script [options] --diff <set1>  <set2>\n        Compute differences of physical lines of source code and comments\n        between a pair of directories or archive files.\n        Example:    cloc --diff Python-3.5.tar.xz python-3.6/\n\n$script --help  shows full documentation on the options.\nhttp://$URL has numerous examples and more information.\n\";\nmy $usage  = \"\nUsage: $script [options] <file(s)/dir(s)> | <set 1> <set 2> | <report files>\n\n Count, or compute differences of, physical lines of source code in the\n given files (may be archives such as compressed tarballs or zip files)\n and/or recursively below the given directories.\n\n ${BB}Input Options${NN}\n   --extract-with=<cmd>      This option is only needed if cloc is unable\n                             to figure out how to extract the contents of\n                             the input file(s) by itself.\n                             Use <cmd> to extract binary archive files (e.g.:\n                             .tar.gz, .zip, .Z).  Use the literal '>FILE<' as\n                             a stand-in for the actual file(s) to be\n                             extracted.  For example, to count lines of code\n                             in the input files\n                                gcc-4.2.tar.gz  perl-5.8.8.tar.gz\n                             on Unix use\n                               --extract-with='gzip -dc >FILE< | tar xf -'\n                             or, if you have GNU tar,\n                               --extract-with='tar zxf >FILE<'\n                             and on Windows use, for example:\n                               --extract-with=\\\"\\\\\\\"c:\\\\Program Files\\\\WinZip\\\\WinZip32.exe\\\\\\\" -e -o >FILE< .\\\"\n                             (if WinZip is installed there).\n   --list-file=<file>        Take the list of file and/or directory names to\n                             process from <file>, which has one file/directory\n                             name per line.  Only exact matches are counted;\n                             relative path names will be resolved starting from\n                             the directory where cloc is invoked.\n                             See also --exclude-list-file.\n   --vcs=<VCS>               Invoke a system call to <VCS> to obtain a list of\n                             files to work on.  If <VCS> is 'git', then will\n                             invoke 'git ls-files' to get a file list and\n                             'git submodule status' to get a list of submodules\n                             whose contents will be ignored.  If <VCS> is 'svn'\n                             then will invoke 'svn list -R'.  The primary benefit\n                             is that cloc will then skip files explicitly\n                             excluded by the versioning tool in question,\n                             ie, those in .gitignore or have the svn:ignore\n                             property.\n                             Alternatively <VCS> may be any system command\n                             that generates a list of files.\n                             Note:  cloc must be in a directory which can read\n                             the files as they are returned by <VCS>.  cloc will\n                             not download files from remote repositories.\n                             'svn list -R' may refer to a remote repository\n                             to obtain file names (and therefore may require\n                             authentication to the remote repository), but\n                             the files themselves must be local.\n   --unicode                 Check binary files to see if they contain Unicode\n                             expanded ASCII text.  This causes performance to\n                             drop noticeably.\n\n ${BB}Processing Options${NN}\n   --autoconf                Count .in files (as processed by GNU autoconf) of\n                             recognized languages.\n   --by-file                 Report results for every source file encountered.\n   --by-file-by-lang         Report results for every source file encountered\n                             in addition to reporting by language.\n   --count-and-diff <set1> <set2>\n                             First perform direct code counts of source file(s)\n                             of <set1> and <set2> separately, then perform a diff\n                             of these.  Inputs may be pairs of files, directories,\n                             or archives.  See also --diff, --diff-alignment,\n                             --diff-timeout, --ignore-case, --ignore-whitespace.\n   --diff <set1> <set2>      Compute differences in code and comments between\n                             source file(s) of <set1> and <set2>.  The inputs\n                             may be pairs of files, directories, or archives.\n                             Use --diff-alignment to generate a list showing\n                             which file pairs where compared.  See also\n                             --count-and-diff, --diff-alignment, --diff-timeout,\n                             --ignore-case, --ignore-whitespace.\n   --diff-timeout <N>        Ignore files which take more than <N> seconds\n                             to process.  Default is 10 seconds.\n                             (Large files with many repeated lines can cause\n                             Algorithm::Diff::sdiff() to take hours.)\n   --follow-links            [Unix only] Follow symbolic links to directories\n                             (sym links to files are always followed).\n   --force-lang=<lang>[,<ext>]\n                             Process all files that have a <ext> extension\n                             with the counter for language <lang>.  For\n                             example, to count all .f files with the\n                             Fortran 90 counter (which expects files to\n                             end with .f90) instead of the default Fortran 77\n                             counter, use\n                               --force-lang=\\\"Fortran 90\\\",f\n                             If <ext> is omitted, every file will be counted\n                             with the <lang> counter.  This option can be\n                             specified multiple times (but that is only\n                             useful when <ext> is given each time).\n                             See also --script-lang, --lang-no-ext.\n   --force-lang-def=<file>   Load language processing filters from <file>,\n                             then use these filters instead of the built-in\n                             filters.  Note:  languages which map to the same\n                             file extension (for example:\n                             MATLAB/Mathematica/Objective C/MUMPS/Mercury;\n                             Pascal/PHP; Lisp/OpenCL; Lisp/Julia; Perl/Prolog)\n                             will be ignored as these require additional\n                             processing that is not expressed in language\n                             definition files.  Use --read-lang-def to define\n                             new language filters without replacing built-in\n                             filters (see also --write-lang-def).\n   --ignore-whitespace       Ignore horizontal white space when comparing files\n                             with --diff.  See also --ignore-case.\n   --ignore-case             Ignore changes in case; consider upper- and lower-\n                             case letters equivalent when comparing files with\n                             --diff.  See also --ignore-whitespace.\n   --lang-no-ext=<lang>      Count files without extensions using the <lang>\n                             counter.  This option overrides internal logic\n                             for files without extensions (where such files\n                             are checked against known scripting languages\n                             by examining the first line for #!).  See also\n                             --force-lang, --script-lang.\n   --max-file-size=<MB>      Skip files larger than <MB> megabytes when\n                             traversing directories.  By default, <MB>=100.\n                             cloc's memory requirement is roughly twenty times\n                             larger than the largest file so running with\n                             files larger than 100 MB on a computer with less\n                             than 2 GB of memory will cause problems.\n                             Note:  this check does not apply to files\n                             explicitly passed as command line arguments.\n   --original-dir            [Only effective in combination with\n                             --strip-comments]  Write the stripped files\n                             to the same directory as the original files.\n   --read-binary-files       Process binary files in addition to text files.\n                             This is usually a bad idea and should only be\n                             attempted with text files that have embedded\n                             binary data.\n   --read-lang-def=<file>    Load new language processing filters from <file>\n                             and merge them with those already known to cloc.\n                             If <file> defines a language cloc already knows\n                             about, cloc's definition will take precedence.\n                             Use --force-lang-def to over-ride cloc's\n                             definitions (see also --write-lang-def ).\n   --script-lang=<lang>,<s>  Process all files that invoke <s> as a #!\n                             scripting language with the counter for language\n                             <lang>.  For example, files that begin with\n                                #!/usr/local/bin/perl5.8.8\n                             will be counted with the Perl counter by using\n                                --script-lang=Perl,perl5.8.8\n                             The language name is case insensitive but the\n                             name of the script language executable, <s>,\n                             must have the right case.  This option can be\n                             specified multiple times.  See also --force-lang,\n                             --lang-no-ext.\n   --sdir=<dir>              Use <dir> as the scratch directory instead of\n                             letting File::Temp chose the location.  Files\n                             written to this location are not removed at\n                             the end of the run (as they are with File::Temp).\n   --skip-uniqueness         Skip the file uniqueness check.  This will give\n                             a performance boost at the expense of counting\n                             files with identical contents multiple times\n                             (if such duplicates exist).\n   --stdin-name=<file>       Give a file name to use to determine the language\n                             for standard input.  (Use - as the input name to\n                             receive source code via STDIN.)\n   --strip-comments=<ext>    For each file processed, write to the current\n                             directory a version of the file which has blank\n                             lines and comments removed.  The name of each\n                             stripped file is the original file name with\n                             .<ext> appended to it.  It is written to the\n                             current directory unless --original-dir is on.\n   --sum-reports             Input arguments are report files previously\n                             created with the --report-file option.  Makes\n                             a cumulative set of results containing the\n                             sum of data from the individual report files.\n   --unix                    Override the operating system autodetection\n                             logic and run in UNIX mode.  See also\n                             --windows, --show-os.\n   --use-sloccount           If SLOCCount is installed, use its compiled\n                             executables c_count, java_count, pascal_count,\n                             php_count, and xml_count instead of cloc's\n                             counters.  SLOCCount's compiled counters are\n                             substantially faster than cloc's and may give\n                             a performance improvement when counting projects\n                             with large files.  However, these cloc-specific\n                             features will not be available: --diff,\n                             --count-and-diff, --strip-comments, --unicode.\n   --windows                 Override the operating system autodetection\n                             logic and run in Microsoft Windows mode.\n                             See also --unix, --show-os.\n\n ${BB}Filter Options${NN}\n   --exclude-dir=<D1>[,D2,]  Exclude the given comma separated directories\n                             D1, D2, D3, et cetera, from being scanned.  For\n                             example  --exclude-dir=.cache,test  will skip\n                             all files and subdirectories that have /.cache/\n                             or /test/ as their parent directory.\n                             Directories named .bzr, .cvs, .hg, .git, and\n                             .svn are always excluded.\n                             This option only works with individual directory\n                             names so including file path separators is not\n                             allowed.  Use --fullpath and --not-match-d=<regex>\n                             to supply a regex matching multiple subdirectories.\n   --exclude-ext=<ext1>[,<ext2>[...]]\n                             Do not count files having the given file name\n                             extensions.\n   --exclude-lang=<L1>[,L2,] Exclude the given comma separated languages\n                             L1, L2, L3, et cetera, from being counted.\n   --exclude-list-file=<file>  Ignore files and/or directories whose names\n                             appear in <file>.  <file> should have one file\n                             name per line.  Only exact matches are ignored;\n                             relative path names will be resolved starting from\n                             the directory where cloc is invoked.\n                             See also --list-file.\n   --fullpath                Modifies the behavior of --match-f, --not-match-f,\n                             and --not-match-d to include the file's path\n                             in the regex, not just the file's basename.\n                             (This does not expand each file to include its\n                             absolute path, instead it uses as much of\n                             the path as is passed in to cloc.)\n                             Note:  --match-d always looks at the full\n                             path and therefore is unaffected by --fullpath.\n   --include-lang=<L1>[,L2,] Count only the given comma separated languages\n                             L1, L2, L3, et cetera.\n   --match-d=<regex>         Only count files in directories matching the Perl\n                             regex.  For example\n                               --match-d='/(src|include)/'\n                             only counts files in directories containing\n                             /src/ or /include/.  Unlike --not-match-d,\n                             --match-f, and --not-match-f, --match-d always\n                             compares the fully qualified path against the regex.\n   --not-match-d=<regex>     Count all files except those in directories\n                             matching the Perl regex.  Only the trailing\n                             directory name is compared, for example, when\n                             counting in /usr/local/lib, only 'lib' is\n                             compared to the regex.\n                             Add --fullpath to compare parent directories to\n                             the regex.\n                             Do not include file path separators at the beginning\n                             or end of the regex.\n   --match-f=<regex>         Only count files whose basenames match the Perl\n                             regex.  For example\n                               --match-f='^[Ww]idget'\n                             only counts files that start with Widget or widget.\n                             Add --fullpath to include parent directories\n                             in the regex instead of just the basename.\n   --not-match-f=<regex>     Count all files except those whose basenames\n                             match the Perl regex.  Add --fullpath to include\n                             parent directories in the regex instead of just\n                             the basename.\n   --skip-archive=<regex>    Ignore files that end with the given Perl regular\n                             expression.  For example, if given\n                               --skip-archive='(zip|tar(\\.(gz|Z|bz2|xz|7z))?)'\n                             the code will skip files that end with .zip,\n                             .tar, .tar.gz, .tar.Z, .tar.bz2, .tar.xz, and\n                             .tar.7z.\n   --skip-win-hidden         On Windows, ignore hidden files.\n\n ${BB}Debug Options${NN}\n   --categorized=<file>      Save names of categorized files to <file>.\n   --counted=<file>          Save names of processed source files to <file>.\n   --diff-alignment=<file>   Write to <file> a list of files and file pairs\n                             showing which files were added, removed, and/or\n                             compared during a run with --diff.  This switch\n                             forces the --diff mode on.\n   --explain=<lang>          Print the filters used to remove comments for\n                             language <lang> and exit.  In some cases the\n                             filters refer to Perl subroutines rather than\n                             regular expressions.  An examination of the\n                             source code may be needed for further explanation.\n   --help                    Print this usage information and exit.\n   --found=<file>            Save names of every file found to <file>.\n   --ignored=<file>          Save names of ignored files and the reason they\n                             were ignored to <file>.\n   --print-filter-stages     Print processed source code before and after\n                             each filter is applied.\n   --show-ext[=<ext>]        Print information about all known (or just the\n                             given) file extensions and exit.\n   --show-lang[=<lang>]      Print information about all known (or just the\n                             given) languages and exit.\n   --show-os                 Print the value of the operating system mode\n                             and exit.  See also --unix, --windows.\n   -v[=<n>]                  Verbose switch (optional numeric value).\n   -verbose[=<n>]            Long form of -v.\n   --version                 Print the version of this program and exit.\n   --write-lang-def=<file>   Writes to <file> the language processing filters\n                             then exits.  Useful as a first step to creating\n                             custom language definitions (see also\n                             --force-lang-def, --read-lang-def).\n\n ${BB}Output Options${NN}\n   --3                       Print third-generation language output.\n                             (This option can cause report summation to fail\n                             if some reports were produced with this option\n                             while others were produced without it.)\n   --by-percent  X           Instead of comment and blank line counts, show\n                             these values as percentages based on the value\n                             of X in the denominator:\n                                X = 'c'   -> # lines of code\n                                X = 'cm'  -> # lines of code + comments\n                                X = 'cb'  -> # lines of code + blanks\n                                X = 'cmb' -> # lines of code + comments + blanks\n                             For example, if using method 'c' and your code\n                             has twice as many lines of comments as lines\n                             of code, the value in the comment column will\n                             be 200%.  The code column remains a line count.\n   --csv                     Write the results as comma separated values.\n   --csv-delimiter=<C>       Use the character <C> as the delimiter for comma\n                             separated files instead of ,.  This switch forces\n   --json                    Write the results as JavaScript Object Notation\n                             (JSON) formatted output.\n   --md                      Write the results as Markdown-formatted text.\n   --out=<file>              Synonym for --report-file=<file>.\n   --progress-rate=<n>       Show progress update after every <n> files are\n                             processed (default <n>=100).  Set <n> to 0 to\n                             suppress progress output (useful when redirecting\n                             output to STDOUT).\n   --quiet                   Suppress all information messages except for\n                             the final report.\n   --report-file=<file>      Write the results to <file> instead of STDOUT.\n   --sql=<file>              Write results as SQL create and insert statements\n                             which can be read by a database program such as\n                             SQLite.  If <file> is -, output is sent to STDOUT.\n   --sql-append              Append SQL insert statements to the file specified\n                             by --sql and do not generate table creation\n                             statements.  Only valid with the --sql option.\n   --sql-project=<name>      Use <name> as the project identifier for the\n                             current run.  Only valid with the --sql option.\n   --sql-style=<style>       Write SQL statements in the given style instead\n                             of the default SQLite format.  Currently, the\n                             only style option is Oracle.\n   --sum-one                 For plain text reports, show the SUM: output line\n                             even if only one input file is processed.\n   --xml                     Write the results in XML.\n   --xsl=<file>              Reference <file> as an XSL stylesheet within\n                             the XML output.  If <file> is 1 (numeric one),\n                             writes a default stylesheet, cloc.xsl (or\n                             cloc-diff.xsl if --diff is also given).\n                             This switch forces --xml on.\n   --yaml                    Write the results in YAML.\n\n\";\n#  Help information for options not yet implemented:\n#  --inline                  Process comments that appear at the end\n#                            of lines containing code.\n#  --html                    Create HTML files of each input file showing\n#                            comment and code lines in different colors.\n\n$| = 1;  # flush STDOUT\nmy $start_time = get_time();\nmy (\n    $opt_categorized          ,\n    $opt_found                ,\n    @opt_force_lang           ,\n    $opt_lang_no_ext          ,\n    @opt_script_lang          ,\n    $opt_count_diff           ,\n    $opt_diff                 ,\n    $opt_diff_alignment       ,\n    $opt_diff_timeout         ,\n    $opt_html                 ,\n    $opt_ignored              ,\n    $opt_counted              ,\n    $opt_show_ext             ,\n    $opt_show_lang            ,\n    $opt_progress_rate        ,\n    $opt_print_filter_stages  ,\n    $opt_v                    ,\n    $opt_vcs                  ,\n    $opt_version              ,\n    $opt_exclude_lang         ,\n    $opt_exclude_list_file    ,\n    $opt_exclude_dir          ,\n    $opt_explain              ,\n    $opt_include_lang         ,\n    $opt_force_lang_def       ,\n    $opt_read_lang_def        ,\n    $opt_write_lang_def       ,\n    $opt_strip_comments       ,\n    $opt_original_dir         ,\n    $opt_quiet                ,\n    $opt_report_file          ,\n    $opt_sdir                 ,\n    $opt_sum_reports          ,\n    $opt_unicode              ,\n    $opt_no3                  ,   # accept it but don't use it\n    $opt_3                    ,\n    $opt_extract_with         ,\n    $opt_by_file              ,\n    $opt_by_file_by_lang      ,\n    $opt_by_percent           ,\n    $opt_xml                  ,\n    $opt_xsl                  ,\n    $opt_yaml                 ,\n    $opt_csv                  ,\n    $opt_csv_delimiter        ,\n    $opt_fullpath             ,\n    $opt_json                 ,\n    $opt_md                   ,\n    $opt_match_f              ,\n    $opt_not_match_f          ,\n    $opt_match_d              ,\n    $opt_not_match_d          ,\n    $opt_skip_uniqueness      ,\n    $opt_list_file            ,\n    $opt_help                 ,\n    $opt_skip_win_hidden      ,\n    $opt_read_binary_files    ,\n    $opt_sql                  ,\n    $opt_sql_append           ,\n    $opt_sql_project          ,\n    $opt_sql_style            ,\n    $opt_inline               ,\n    $opt_exclude_ext          ,\n    $opt_ignore_whitespace    ,\n    $opt_ignore_case          ,\n    $opt_follow_links         ,\n    $opt_autoconf             ,\n    $opt_sum_one              ,\n    $opt_stdin_name           ,\n    $opt_force_on_windows     ,\n    $opt_force_on_unix        ,   # actually forces !$ON_WINDOWS\n    $opt_show_os              ,\n    $opt_skip_archive         ,\n    $opt_max_file_size        ,   # in MB\n    $opt_use_sloccount        ,\n   );\nmy $getopt_success = GetOptions(\n   \"by_file|by-file\"                         => \\$opt_by_file             ,\n   \"by_file_by_lang|by-file-by-lang\"         => \\$opt_by_file_by_lang     ,\n   \"categorized=s\"                           => \\$opt_categorized         ,\n   \"counted=s\"                               => \\$opt_counted             ,\n   \"include_lang|include-lang=s\"             => \\$opt_include_lang        ,\n   \"exclude_lang|exclude-lang=s\"             => \\$opt_exclude_lang        ,\n   \"exclude_dir|exclude-dir=s\"               => \\$opt_exclude_dir         ,\n   \"exclude_list_file|exclude-list-file=s\"   => \\$opt_exclude_list_file   ,\n   \"explain=s\"                               => \\$opt_explain             ,\n   \"extract_with|extract-with=s\"             => \\$opt_extract_with        ,\n   \"found=s\"                                 => \\$opt_found               ,\n   \"count_and_diff|count-and-diff\"           => \\$opt_count_diff          ,\n   \"diff\"                                    => \\$opt_diff                ,\n   \"diff-alignment|diff_alignment=s\"         => \\$opt_diff_alignment      ,\n   \"diff-timeout|diff_timeout=i\"             => \\$opt_diff_timeout        ,\n   \"html\"                                    => \\$opt_html                ,\n   \"ignored=s\"                               => \\$opt_ignored             ,\n   \"quiet\"                                   => \\$opt_quiet               ,\n   \"force_lang_def|force-lang-def=s\"         => \\$opt_force_lang_def      ,\n   \"read_lang_def|read-lang-def=s\"           => \\$opt_read_lang_def       ,\n   \"show_ext|show-ext:s\"                     => \\$opt_show_ext            ,\n   \"show_lang|show-lang:s\"                   => \\$opt_show_lang           ,\n   \"progress_rate|progress-rate=i\"           => \\$opt_progress_rate       ,\n   \"print_filter_stages|print-filter-stages\" => \\$opt_print_filter_stages ,\n   \"report_file|report-file=s\"               => \\$opt_report_file         ,\n   \"out=s\"                                   => \\$opt_report_file         ,\n   \"script_lang|script-lang=s\"               => \\@opt_script_lang         ,\n   \"sdir=s\"                                  => \\$opt_sdir                ,\n   \"skip_uniqueness|skip-uniqueness\"         => \\$opt_skip_uniqueness     ,\n   \"strip_comments|strip-comments=s\"         => \\$opt_strip_comments      ,\n   \"original_dir|original-dir\"               => \\$opt_original_dir        ,\n   \"sum_reports|sum-reports\"                 => \\$opt_sum_reports         ,\n   \"unicode\"                                 => \\$opt_unicode             ,\n   \"no3\"                                     => \\$opt_no3                 ,  # ignored\n   \"3\"                                       => \\$opt_3                   ,\n   \"v|verbose:i\"                             => \\$opt_v                   ,\n   \"vcs=s\"                                   => \\$opt_vcs                 ,\n   \"version\"                                 => \\$opt_version             ,\n   \"write_lang_def|write-lang-def=s\"         => \\$opt_write_lang_def      ,\n   \"xml\"                                     => \\$opt_xml                 ,\n   \"xsl=s\"                                   => \\$opt_xsl                 ,\n   \"force_lang|force-lang=s\"                 => \\@opt_force_lang          ,\n   \"lang_no_ext|lang-no-ext=s\"               => \\$opt_lang_no_ext         ,\n   \"yaml\"                                    => \\$opt_yaml                ,\n   \"csv\"                                     => \\$opt_csv                 ,\n   \"csv_delimeter|csv-delimiter=s\"           => \\$opt_csv_delimiter       ,\n   \"json\"                                    => \\$opt_json                ,\n   \"md\"                                      => \\$opt_md                  ,\n   \"fullpath\"                                => \\$opt_fullpath            ,\n   \"match_f|match-f=s\"                       => \\$opt_match_f             ,\n   \"not_match_f|not-match-f=s\"               => \\$opt_not_match_f         ,\n   \"match_d|match-d=s\"                       => \\$opt_match_d             ,\n   \"not_match_d|not-match-d=s\"               => \\$opt_not_match_d         ,\n   \"list_file|list-file=s\"                   => \\$opt_list_file           ,\n   \"help\"                                    => \\$opt_help                ,\n   \"skip_win_hidden|skip-win-hidden\"         => \\$opt_skip_win_hidden     ,\n   \"read_binary_files|read-binary-files\"     => \\$opt_read_binary_files   ,\n   \"sql=s\"                                   => \\$opt_sql                 ,\n   \"sql_project|sql-project=s\"               => \\$opt_sql_project         ,\n   \"sql_append|sql-append\"                   => \\$opt_sql_append          ,\n   \"sql_style|sql-style=s\"                   => \\$opt_sql_style           ,\n   \"inline\"                                  => \\$opt_inline              ,\n   \"exclude_ext|exclude-ext=s\"               => \\$opt_exclude_ext         ,\n   \"ignore_whitespace|ignore-whitespace\"     => \\$opt_ignore_whitespace   ,\n   \"ignore_case|ignore-case\"                 => \\$opt_ignore_case         ,\n   \"follow_links|follow-links\"               => \\$opt_follow_links        ,\n   \"autoconf\"                                => \\$opt_autoconf            ,\n   \"sum_one|sum-one\"                         => \\$opt_sum_one             ,\n   \"by_percent|by-percent=s\"                 => \\$opt_by_percent          ,\n   \"stdin_name|stdin-name=s\"                 => \\$opt_stdin_name          ,\n   \"windows\"                                 => \\$opt_force_on_windows    ,\n   \"unix\"                                    => \\$opt_force_on_unix       ,\n   \"show_os|show-os\"                         => \\$opt_show_os             ,\n   \"skip_archive|skip-archive=s\"             => \\$opt_skip_archive        ,\n   \"max_file_size|max-file-size=i\"           => \\$opt_max_file_size       ,\n   \"use_sloccount|use-sloccount\"             => \\$opt_use_sloccount       ,\n  );\n$opt_by_file  = 1 if defined  $opt_by_file_by_lang;\nmy $CLOC_XSL = \"cloc.xsl\"; # created with --xsl\n   $CLOC_XSL = \"cloc-diff.xsl\" if $opt_diff;\ndie \"\\n\" unless $getopt_success;\nprint $usage and exit if $opt_help;\nmy %Exclude_Language = ();\n   %Exclude_Language = map { $_ => 1 } split(/,/, $opt_exclude_lang)\n        if $opt_exclude_lang;\nmy %Exclude_Dir      = ();\n   %Exclude_Dir      = map { $_ => 1 } split(/,/, $opt_exclude_dir )\n        if $opt_exclude_dir ;\ndie unless exclude_dir_validates(\\%Exclude_Dir);\nmy %Include_Language = ();\n   %Include_Language = map { $_ => 1 } split(/,/, $opt_include_lang)\n        if $opt_include_lang;\n# Forcibly exclude .svn, .cvs, .hg, .git, .bzr directories.  The contents of these\n# directories often conflict with files of interest.\n$opt_exclude_dir       = 1;\n$Exclude_Dir{\".svn\"}   = 1;\n$Exclude_Dir{\".cvs\"}   = 1;\n$Exclude_Dir{\".hg\"}    = 1;\n$Exclude_Dir{\".git\"}   = 1;\n$Exclude_Dir{\".bzr\"}   = 1;\n$opt_count_diff        = defined $opt_count_diff ? 1 : 0;\n$opt_diff              = 1  if $opt_diff_alignment;\n$opt_exclude_ext       = \"\" unless $opt_exclude_ext;\n$opt_ignore_whitespace = 0  unless $opt_ignore_whitespace;\n$opt_ignore_case       = 0  unless $opt_ignore_case;\n$opt_lang_no_ext       = 0  unless $opt_lang_no_ext;\n$opt_follow_links      = 0  unless $opt_follow_links;\n$opt_diff_timeout      =10  unless $opt_diff_timeout;\n$opt_csv               = 1  if $opt_csv_delimiter;\n$ON_WINDOWS            = 1  if $opt_force_on_windows;\n$ON_WINDOWS            = 0  if $opt_force_on_unix;\n$opt_max_file_size     = 100 unless $opt_max_file_size;\nmy $HAVE_SLOCCOUNT_c_count = 0;\nif (!$ON_WINDOWS and $opt_use_sloccount) {\n    # Only bother doing this kludgey test is user explicitly wants\n    # to use SLOCCount.  Debian based systems will hang if just doing\n    #  external_utility_exists(\"c_count\")\n    # if c_count is in $PATH; c_count expects to have input.\n    $HAVE_SLOCCOUNT_c_count = external_utility_exists(\"c_count /bin/sh\");\n}\nif ($opt_use_sloccount) {\n    if (!$HAVE_SLOCCOUNT_c_count) {\n        warn \"c_count could not be found; ignoring --use-sloccount\\n\";\n        $opt_use_sloccount = 0;\n    } else {\n        warn \"Using c_count, php_count, xml_count, pascal_count from SLOCCount\\n\";\n        warn \"--diff is disabled with --use-sloccount\\n\" if $opt_diff;\n        warn \"--count-and-diff is disabled with --use-sloccount\\n\" if $opt_count_diff;\n        warn \"--unicode is disabled with --use-sloccount\\n\" if $opt_unicode;\n        warn \"--strip-comments is disabled with --use-sloccount\\n\" if $opt_strip_comments;\n        $opt_diff           = 0;\n        $opt_count_diff     = undef;\n        $opt_unicode        = 0;\n        $opt_strip_comments = 0;\n    }\n}\n\nmy @COUNT_DIFF_ARGV        = undef;\nmy $COUNT_DIFF_report_file = undef;\nif ($opt_count_diff) {\n    die \"--count-and-diff requires two arguments; got \", scalar @ARGV, \"\\n\"\n        if scalar @ARGV != 2;\n    # prefix with a dummy term so that $opt_count_diff is the\n    # index into @COUNT_DIFF_ARGV to work on at each pass\n    @COUNT_DIFF_ARGV = (undef, $ARGV[0],\n                               $ARGV[1],\n                              [$ARGV[0], $ARGV[1]]);  # 3rd pass: diff them\n    $COUNT_DIFF_report_file = $opt_report_file if $opt_report_file;\n}\n\n# Options defaults:\n$opt_quiet         =   1 if ($opt_md or $opt_json) and !defined $opt_report_file;\n$opt_progress_rate = 100 unless defined $opt_progress_rate;\n$opt_progress_rate =   0 if     defined $opt_quiet;\nif (!defined $opt_v) {\n    $opt_v  = 0;\n} elsif (!$opt_v) {\n    $opt_v  = 1;\n}\nif (defined $opt_xsl) {\n    $opt_xsl = $CLOC_XSL if $opt_xsl eq \"1\";\n    $opt_xml = 1;\n}\nmy $skip_generate_report = 0;\n$opt_sql_style = 0 unless defined $opt_sql_style;\n$opt_sql = 0 unless $opt_sql_style or defined $opt_sql;\nif ($opt_sql eq \"-\" || $opt_sql eq \"1\") { # stream SQL output to STDOUT\n    $opt_quiet            = 1;\n    $skip_generate_report = 1;\n    $opt_by_file          = 1;\n    $opt_sum_reports      = 0;\n    $opt_progress_rate    = 0;\n} elsif ($opt_sql)  { # write SQL output to a file\n    $opt_by_file          = 1;\n    $skip_generate_report = 1;\n    $opt_sum_reports      = 0;\n}\nif ($opt_sql_style) {\n    $opt_sql_style = lc $opt_sql_style;\n    if (!grep { lc $_ eq $opt_sql_style } qw ( Oracle )) {\n        die \"'$opt_sql_style' is not a recognized SQL style.\\n\";\n    }\n}\n$opt_by_percent = '' unless defined $opt_by_percent;\nif ($opt_by_percent and $opt_by_percent !~ m/^(c|cm|cb|cmb)$/i) {\n    die \"--by-percent must be either 'c', 'cm', 'cb', or 'cmb'\\n\";\n}\n$opt_by_percent = lc $opt_by_percent;\n\nif (defined $opt_vcs) {\n    if      ($opt_vcs eq \"git\") {\n        $opt_vcs = \"git ls-files\";\n        my @submodules = invoke_generator('git submodule status');\n        foreach my $SM (@submodules) {\n            $SM =~ s/^\\s+//;        # may have leading space\n            $SM =~ s/\\(\\S+\\)\\s*$//; # may end with something like (heads/master)\n\t\t\tmy ($checksum, $dir) = split(' ', $SM, 2);\n            $dir =~ s/\\s+$//;\n            $Exclude_Dir{$dir} = 1;\n        }\n    } elsif ($opt_vcs eq \"svn\") {\n        $opt_vcs = \"svn list -R\";\n    }\n}\n\ndie $brief_usage unless defined $opt_version         or\n                        defined $opt_show_lang       or\n                        defined $opt_show_ext        or\n                        defined $opt_show_os         or\n                        defined $opt_write_lang_def  or\n                        defined $opt_list_file       or\n                        defined $opt_vcs             or\n                        defined $opt_xsl             or\n                        defined $opt_explain         or\n                        scalar @ARGV >= 1;\ndie \"--diff requires two arguments; got \", scalar @ARGV, \"\\n\"\n    if $opt_diff and scalar @ARGV != 2;\nif ($opt_version) {\n    printf \"$VERSION\\n\";\n    exit;\n}\n# 1}}}\n# Step 1:  Initialize global constants.        {{{1\n#\nmy $nFiles_Found = 0;  # updated in make_file_list\nmy (%Language_by_Extension, %Language_by_Script,\n    %Filters_by_Language, %Not_Code_Extension, %Not_Code_Filename,\n    %Language_by_File, %Scale_Factor, %Known_Binary_Archives,\n    %EOL_Continuation_re,\n   );\nmy $ALREADY_SHOWED_HEADER = 0;\nmy $ALREADY_SHOWED_XML_SECTION = 0;\nmy %Error_Codes = ( 'Unable to read'                => -1,\n                    'Neither file nor directory'    => -2,\n                    'Diff error (quoted comments?)' => -3,\n                    'Diff error, exceeded timeout'  => -4,\n                  );\nif ($opt_force_lang_def) {\n    # replace cloc's definitions\n    read_lang_def(\n        $opt_force_lang_def    , #        Sample values:\n        \\%Language_by_Extension, # Language_by_Extension{f}    = 'Fortran 77'\n        \\%Language_by_Script   , # Language_by_Script{sh}      = 'Bourne Shell'\n        \\%Language_by_File     , # Language_by_File{makefile}  = 'make'\n        \\%Filters_by_Language  , # Filters_by_Language{Bourne Shell}[0] =\n                                 #      [ 'remove_matches' , '^\\s*#'  ]\n        \\%Not_Code_Extension   , # Not_Code_Extension{jpg}     = 1\n        \\%Not_Code_Filename    , # Not_Code_Filename{README}   = 1\n        \\%Scale_Factor         , # Scale_Factor{Perl}          = 4.0\n        \\%EOL_Continuation_re  , # EOL_Continuation_re{C++}    = '\\\\$'\n        );\n} else {\n    set_constants(               #\n        \\%Language_by_Extension, # Language_by_Extension{f}    = 'Fortran 77'\n        \\%Language_by_Script   , # Language_by_Script{sh}      = 'Bourne Shell'\n        \\%Language_by_File     , # Language_by_File{makefile}  = 'make'\n        \\%Filters_by_Language  , # Filters_by_Language{Bourne Shell}[0] =\n                                 #      [ 'remove_matches' , '^\\s*#'  ]\n        \\%Not_Code_Extension   , # Not_Code_Extension{jpg}     = 1\n        \\%Not_Code_Filename    , # Not_Code_Filename{README}   = 1\n        \\%Scale_Factor         , # Scale_Factor{Perl}          = 4.0\n        \\%Known_Binary_Archives, # Known_Binary_Archives{.tar} = 1\n        \\%EOL_Continuation_re  , # EOL_Continuation_re{C++}    = '\\\\$'\n        );\n}\nif ($opt_read_lang_def) {\n    # augment cloc's definitions (keep cloc's where there are overlaps)\n    merge_lang_def(\n        $opt_read_lang_def     , #        Sample values:\n        \\%Language_by_Extension, # Language_by_Extension{f}    = 'Fortran 77'\n        \\%Language_by_Script   , # Language_by_Script{sh}      = 'Bourne Shell'\n        \\%Language_by_File     , # Language_by_File{makefile}  = 'make'\n        \\%Filters_by_Language  , # Filters_by_Language{Bourne Shell}[0] =\n                                 #      [ 'remove_matches' , '^\\s*#'  ]\n        \\%Not_Code_Extension   , # Not_Code_Extension{jpg}     = 1\n        \\%Not_Code_Filename    , # Not_Code_Filename{README}   = 1\n        \\%Scale_Factor         , # Scale_Factor{Perl}          = 4.0\n        \\%EOL_Continuation_re  , # EOL_Continuation_re{C++}    = '\\\\$'\n        );\n}\nif ($opt_lang_no_ext and !defined $Filters_by_Language{$opt_lang_no_ext}) {\n    die_unknown_lang($opt_lang_no_ext, \"--lang-no-ext\")\n}\ncheck_scale_existence(\\%Filters_by_Language, \\%Language_by_Extension,\n                      \\%Scale_Factor);\n\n# Process command line provided extension-to-language mapping overrides.\n# Make a hash of known languages in lower case for easier matching.\nmy %Recognized_Language_lc = (); # key = language name in lc, value = true name\nforeach my $language (keys %Filters_by_Language) {\n    my $lang_lc = lc $language;\n    $Recognized_Language_lc{$lang_lc} = $language;\n}\nmy %Forced_Extension = (); # file name extensions which user wants to count\nmy $All_One_Language = 0;  # set to !0 if --force-lang's <ext> is missing\nforeach my $pair (@opt_force_lang) {\n    my ($lang, $extension) = split(',', $pair);\n    my $lang_lc = lc $lang;\n    if (defined $extension) {\n        $Forced_Extension{$extension} = $lang;\n\n        die_unknown_lang($lang, \"--force-lang\")\n            unless $Recognized_Language_lc{$lang_lc};\n\n        $Language_by_Extension{$extension} = $Recognized_Language_lc{$lang_lc};\n    } else {\n        # the scary case--count everything as this language\n        $All_One_Language = $Recognized_Language_lc{$lang_lc};\n    }\n}\n\nforeach my $pair (@opt_script_lang) {\n    my ($lang, $script_name) = split(',', $pair);\n    my $lang_lc = lc $lang;\n    if (!defined $script_name) {\n        die \"The --script-lang option requires a comma separated pair of \".\n            \"strings.\\n\";\n    }\n\n    die_unknown_lang($lang, \"--script-lang\")\n        unless $Recognized_Language_lc{$lang_lc};\n\n    $Language_by_Script{$script_name} = $Recognized_Language_lc{$lang_lc};\n}\n\n# If user provided file extensions to ignore, add these to\n# the exclusion list.\nforeach my $ext (map { $_ => 1 } split(/,/, $opt_exclude_ext ) ) {\n    $ext = lc $ext if $ON_WINDOWS;\n    $Not_Code_Extension{$ext} = 1;\n}\n\n# If SQL or --by-file output is requested, keep track of directory names\n# generated by File::Temp::tempdir and used to temporarily hold the results\n# of compressed archives.  Contents of the SQL table 't' will be much\n# cleaner if these meaningless directory names are stripped from the front\n# of files pulled from the archives.\nmy %TEMP_DIR = ();\nmy $TEMP_OFF =  0;  # Needed for --sdir; keep track of the number of\n                    # scratch directories made in this run to avoid\n                    # file overwrites by multiple extractions to same\n                    # sdir.\n# Also track locations where temporary installations, if necessary, of\n# Algorithm::Diff and/or Regexp::Common are done.  Make sure these\n# directories are not counted as inputs (ref bug #80 2012-11-23).\nmy %TEMP_INST = ();\n\n# invert %Language_by_Script hash to get an easy-to-look-up list of known\n# scripting languages\nmy %Script_Language = map { $_ => 1 } values %Language_by_Script ;\n# 1}}}\n# Step 2:  Early exits for display, summation. {{{1\n#\nprint_extension_info(   $opt_show_ext     ) if defined $opt_show_ext ;\nprint_language_info(    $opt_show_lang, '') if defined $opt_show_lang;\nprint_language_filters( $opt_explain      ) if defined $opt_explain  ;\nexit if (defined $opt_show_ext)  or\n        (defined $opt_show_lang) or\n        (defined $opt_explain);\n\nTop_of_Processing_Loop:\n# Sorry, coding purists.  Using a goto to implement --count-and-diff\n# which has to do three passes over the main code, starting with\n# a clean slate each time.\nif ($opt_count_diff) {\n    @ARGV = ( $COUNT_DIFF_ARGV[ $opt_count_diff ] );\n    if ($opt_count_diff == 3) {\n        $opt_diff = 1;\n        @ARGV = @{$COUNT_DIFF_ARGV[ $opt_count_diff ]}; # last arg is list of list\n    }\n    if ($opt_report_file) {\n        # Instead of just one output file, will have three.\n        # Keep their names unique otherwise results are clobbered.\n        if ($opt_count_diff == 3) {\n            $opt_report_file = $COUNT_DIFF_report_file . \".diff.$ARGV[0].$ARGV[1]\";\n        } else {\n            $opt_report_file = $COUNT_DIFF_report_file . \".\" .  $ARGV[0];\n        }\n    } else {\n        # STDOUT; print a header showing what it's working on\n        if ($opt_count_diff == 3) {\n            print \"\\ndiff $ARGV[0] $ARGV[1]::\\n\";\n        } else {\n            print \"\\n\" if $opt_count_diff > 1;\n            print \"$ARGV[0]::\\n\";\n        }\n    }\n    $ALREADY_SHOWED_HEADER      = 0;\n    $ALREADY_SHOWED_XML_SECTION = 0;\n}\n\n#print \"Before glob have [\", join(\",\", @ARGV), \"]\\n\";\n@ARGV = windows_glob(@ARGV) if $ON_WINDOWS;\n#print \"after  glob have [\", join(\",\", @ARGV), \"]\\n\";\n\n# filter out archive files if requested to do so\nif (defined $opt_skip_archive) {\n    my @non_archive = ();\n    foreach my $candidate (@ARGV) {\n        if ($candidate !~ m/${opt_skip_archive}$/) {\n            push @non_archive, $candidate;\n\n        }\n    }\n    @ARGV = @non_archive;\n}\n\nif ($opt_sum_reports and $opt_diff) {\n    my @results = ();\n    if ($opt_list_file) { # read inputs from the list file\n        my @list = read_list_file($opt_list_file);\n        @results = combine_diffs(\\@list);\n    } elsif ($opt_vcs) { # read inputs from the VCS generator\n        my @list = invoke_generator($opt_vcs, \\@ARGV);\n        @results = combine_diffs(\\@list);\n    } else { # get inputs from the command line\n        @results = combine_diffs(\\@ARGV);\n    }\n    if ($opt_report_file) {\n        write_file($opt_report_file, @results);\n    } else {\n        print \"\\n\", join(\"\\n\", @results), \"\\n\";\n    }\n    exit;\n}\nif ($opt_sum_reports) {\n    my %Results = ();\n    foreach my $type( \"by language\", \"by report file\" ) {\n        my $found_lang = undef;\n        if ($opt_list_file or $opt_vcs) {\n            # read inputs from the list file\n            my @list;\n            if ($opt_vcs) {\n                @list = invoke_generator($opt_vcs, \\@ARGV);\n            } else {\n                @list = read_list_file($opt_list_file);\n            }\n            $found_lang = combine_results(\\@list,\n                                           $type,\n                                          \\%{$Results{ $type }},\n                                          \\%Filters_by_Language );\n        } else { # get inputs from the command line\n            $found_lang = combine_results(\\@ARGV,\n                                           $type,\n                                          \\%{$Results{ $type }},\n                                          \\%Filters_by_Language );\n        }\n        next unless %Results;\n        my $end_time = get_time();\n        my @results  = generate_report($VERSION, $end_time - $start_time,\n                                       $type,\n                                      \\%{$Results{ $type }}, \\%Scale_Factor);\n        if ($opt_report_file) {\n            my $ext  = \".lang\";\n               $ext  = \".file\" unless $type eq \"by language\";\n            next if !$found_lang and  $ext  eq \".lang\";\n            write_file($opt_report_file . $ext, @results);\n        } else {\n            print \"\\n\", join(\"\\n\", @results), \"\\n\";\n        }\n    }\n    exit;\n}\nif ($opt_write_lang_def) {\n    write_lang_def($opt_write_lang_def   ,\n                  \\%Language_by_Extension,\n                  \\%Language_by_Script   ,\n                  \\%Language_by_File     ,\n                  \\%Filters_by_Language  ,\n                  \\%Not_Code_Extension   ,\n                  \\%Not_Code_Filename    ,\n                  \\%Scale_Factor         ,\n                  \\%EOL_Continuation_re  ,\n                  );\n    exit;\n}\nif ($opt_show_os) {\n    if ($ON_WINDOWS) {\n        print \"Windows\\n\";\n    } else {\n        print \"UNIX\\n\";\n    }\n    exit;\n}\n# 1}}}\n# Step 3:  Create a list of files to consider. {{{1\n#  a) If inputs are binary archives, first cd to a temp\n#     directory, expand the archive with the user-given\n#     extraction tool, then add the temp directory to\n#     the list of dirs to process.\n#  b) Create a list of every file that might contain source\n#     code.  Ignore binary files, zero-sized files, and\n#     any file in a directory the user says to exclude.\n#  c) Determine the language for each file in the list.\n#\nmy @binary_archive = ();\nmy $cwd            = cwd();\nif ($opt_extract_with) {\n#print \"cwd main = [$cwd]\\n\";\n    my @extract_location = ();\n    foreach my $bin_file (@ARGV) {\n        my $extract_dir = undef;\n        if ($opt_sdir) {\n            ++$TEMP_OFF;\n            $extract_dir = \"$opt_sdir/$TEMP_OFF\";\n            File::Path::rmtree($extract_dir) if     is_dir($extract_dir);\n            File::Path::mkpath($extract_dir) unless is_dir($extract_dir);\n        } else {\n            $extract_dir = tempdir( CLEANUP => 1 );  # 1 = delete on exit\n        }\n        $TEMP_DIR{ $extract_dir } = 1 if $opt_sql or $opt_by_file;\n        print \"mkdir $extract_dir\\n\"  if $opt_v;\n        print \"cd    $extract_dir\\n\"  if $opt_v;\n        chdir $extract_dir;\n        my $bin_file_full_path = \"\";\n        if (File::Spec->file_name_is_absolute( $bin_file )) {\n            $bin_file_full_path = $bin_file;\n#print \"bin_file_full_path (was ful) = [$bin_file_full_path]\\n\";\n        } else {\n            $bin_file_full_path = File::Spec->catfile( $cwd, $bin_file );\n#print \"bin_file_full_path (was rel) = [$bin_file_full_path]\\n\";\n        }\n        my     $extract_cmd = uncompress_archive_cmd($bin_file_full_path);\n        print  $extract_cmd, \"\\n\" if $opt_v;\n        system $extract_cmd;\n        push @extract_location, $extract_dir;\n        chdir $cwd;\n    }\n    # It is possible that the binary archive itself contains additional\n    # files compressed the same way (true for Java .ear files).  Go\n    # through all the files that were extracted, see if they are binary\n    # archives and try to extract them.  Lather, rinse, repeat.\n    my $binary_archives_exist = 1;\n    my $count_binary_archives = 0;\n    my $previous_count        = 0;\n    my $n_pass                = 0;\n    while ($binary_archives_exist) {\n        @binary_archive = ();\n        foreach my $dir (@extract_location) {\n            find(\\&archive_files, $dir);  # populates global @binary_archive\n        }\n        foreach my $archive (@binary_archive) {\n            my $extract_dir = undef;\n            if ($opt_sdir) {\n                ++$TEMP_OFF;\n                $extract_dir = \"$opt_sdir/$TEMP_OFF\";\n                File::Path::rmtree($extract_dir) if     is_dir($extract_dir);\n                File::Path::mkpath($extract_dir) unless is_dir($extract_dir);\n            } else {\n                $extract_dir = tempdir( CLEANUP => 1 );  # 1 = delete on exit\n            }\n            $TEMP_DIR{ $extract_dir } = 1 if $opt_sql or $opt_by_file;\n            print \"mkdir $extract_dir\\n\"  if $opt_v;\n            print \"cd    $extract_dir\\n\"  if $opt_v;\n            chdir  $extract_dir;\n\n            my     $extract_cmd = uncompress_archive_cmd($archive);\n            print  $extract_cmd, \"\\n\" if $opt_v;\n            system $extract_cmd;\n            push @extract_location, $extract_dir;\n            unlink $archive;  # otherwise will be extracting it forever\n        }\n        $count_binary_archives = scalar @binary_archive;\n        if ($count_binary_archives == $previous_count) {\n            $binary_archives_exist = 0;\n        }\n        $previous_count = $count_binary_archives;\n    }\n    chdir $cwd;\n\n    @ARGV = @extract_location;\n} else {\n    # see if any of the inputs need to be auto-uncompressed &/or expanded\n    my @updated_ARGS = ();\n    foreach my $Arg (@ARGV) {\n        if (is_dir($Arg)) {\n            push @updated_ARGS, $Arg;\n            next;\n        }\n        my $full_path = \"\";\n        if (File::Spec->file_name_is_absolute( $Arg )) {\n            $full_path = $Arg;\n        } else {\n            $full_path = File::Spec->catfile( $cwd, $Arg );\n        }\n#print \"full_path = [$full_path]\\n\";\n        my $extract_cmd = uncompress_archive_cmd($full_path);\n        if ($extract_cmd) {\n            my $extract_dir = undef;\n            if ($opt_sdir) {\n                ++$TEMP_OFF;\n                $extract_dir = \"$opt_sdir/$TEMP_OFF\";\n                File::Path::rmtree($extract_dir) if     is_dir($extract_dir);\n                File::Path::mkpath($extract_dir) unless is_dir($extract_dir);\n            } else {\n                $extract_dir = tempdir( CLEANUP => 1 ); # 1 = delete on exit\n            }\n            $TEMP_DIR{ $extract_dir } = 1 if $opt_sql or $opt_by_file;\n            print \"mkdir $extract_dir\\n\"  if $opt_v;\n            print \"cd    $extract_dir\\n\"  if $opt_v;\n            chdir  $extract_dir;\n            print  $extract_cmd, \"\\n\" if $opt_v;\n            system $extract_cmd;\n            push @updated_ARGS, $extract_dir;\n            chdir $cwd;\n        } else {\n            # this is a conventional, uncompressed, unarchived file\n            # or a directory; keep as-is\n            push @updated_ARGS, $Arg;\n        }\n    }\n    @ARGV = @updated_ARGS;\n\n    # make sure we're not counting any directory containing\n    # temporary installations of Regexp::Common, Algorithm::Diff\n    foreach my $d (sort keys %TEMP_INST) {\n        foreach my $a (@ARGV) {\n            next unless is_dir($a);\n            if ($opt_v > 2) {\n                printf \"Comparing %s (location of %s) to input [%s]\\n\",\n                        $d, $TEMP_INST{$d}, $a;\n            }\n            if ($a eq $d) {\n                die \"File::Temp::tempdir chose directory \",\n                    $d, \" to install \", $TEMP_INST{$d}, \" but this \",\n                    \"matches one of your input directories.  Rerun \",\n                    \"with --sdir and supply a different temporary \",\n                    \"directory for \", $TEMP_INST{$d}, \"\\n\";\n            }\n        }\n    }\n}\n# 1}}}\nmy @Errors    = ();\nmy @file_list = ();  # global variable updated in files()\nmy %Ignored   = ();  # files that are not counted (language not recognized or\n                     # problems reading the file)\nmy @Lines_Out = ();\nif ($opt_diff) {\n# Step 4:  Separate code from non-code files.  {{{1\nmy @fh            = ();\nmy @files_for_set = ();\n# make file lists for each separate argument\nfor (my $i = 0; $i < scalar @ARGV; $i++) {\n    push @fh,\n         make_file_list([ $ARGV[$i] ], \\%Error_Codes, \\@Errors, \\%Ignored);\n    @{$files_for_set[$i]} = @file_list;\n    if ($opt_exclude_list_file) {\n        # note: process_exclude_list_file() references global @file_list\n        process_exclude_list_file($opt_exclude_list_file,\n                                 \\%Exclude_Dir,\n                                 \\%Ignored);\n    }\n    @file_list = ();\n}\n# 1}}}\n# Step 5:  Remove duplicate files.             {{{1\n#\nmy %Language           = ();\nmy %unique_source_file = ();\nmy $n_set = 0;\nforeach my $FH (@fh) {  # loop over each pair of file sets\n    ++$n_set;\n    remove_duplicate_files($FH,\n                               \\%{$Language{$FH}}               ,\n                               \\%{$unique_source_file{$FH}}     ,\n                          \\%Error_Codes                         ,\n                               \\@Errors                         ,\n                               \\%Ignored                        );\n    printf \"%2d: %8d unique file%s.                          \\r\",\n        $n_set,\n        plural_form(scalar keys %unique_source_file)\n        unless $opt_quiet;\n}\n# 1}}}\n# Step 6:  Count code, comments, blank lines.  {{{1\n#\nmy %Results_by_Language = ();\nmy %Results_by_File     = ();\nmy %Delta_by_Language   = ();\nmy %Delta_by_File       = ();\n\nforeach (my $F = 0; $F < scalar @fh - 1; $F++) {\n    # loop over file sets; do diff between set $F to $F+1\n\n    my $nCounted = 0;\n\n    my @file_pairs    = ();\n    my @files_added   = ();\n    my @files_removed = ();\n\n    align_by_pairs(\\%{$unique_source_file{$fh[$F  ]}}    , # in\n                   \\%{$unique_source_file{$fh[$F+1]}}    , # in\n                   \\@files_added                         , # out\n                   \\@files_removed                       , # out\n                   \\@file_pairs                          , # out\n                   );\n    my %already_counted = (); # already_counted{ filename } = 1\n\n    if (!@file_pairs) {\n        # Special case where all files were either added or deleted.\n        # In this case, one of these arrays will be empty:\n        #   @files_added, @files_removed\n        # so loop over both to cover both cases.\n        my $status = @files_added ? 'added' : 'removed';\n        my $offset = @files_added ? 1       : 0        ;\n        foreach my $file (@files_added, @files_removed) {\n            next unless defined $Language{$fh[$F+$offset]}{$file};\n            my $Lang = $Language{$fh[$F+$offset]}{$file};\n            next if $Lang eq '(unknown)';\n            my ($all_line_count,\n                $blank_count   ,\n                $comment_count ,\n               ) = call_counter($file, $Lang, \\@Errors);\n            $already_counted{$file} = 1;\n            my $code_count = $all_line_count-$blank_count-$comment_count;\n            if ($opt_by_file) {\n                $Delta_by_File{$file}{'code'   }{$status} += $code_count   ;\n                $Delta_by_File{$file}{'blank'  }{$status} += $blank_count  ;\n                $Delta_by_File{$file}{'comment'}{$status} += $comment_count;\n                $Delta_by_File{$file}{'lang'   }{$status}  = $Lang         ;\n                $Delta_by_File{$file}{'nFiles' }{$status} += 1             ;\n            }\n            $Delta_by_Language{$Lang}{'code'   }{$status} += $code_count   ;\n            $Delta_by_Language{$Lang}{'blank'  }{$status} += $blank_count  ;\n            $Delta_by_Language{$Lang}{'comment'}{$status} += $comment_count;\n            $Delta_by_Language{$Lang}{'nFiles' }{$status} += 1             ;\n        }\n    }\n   #use Data::Dumper::Simple;\n   #use Data::Dumper;\n   #print Dumper(\\@files_added, \\@files_removed, \\@file_pairs);\n    my @alignment = (); # only  used if --diff-alignment\n#print \"after align_by_pairs:\\n\";\n\n#print \"added:\\n\";\n    push @alignment, sprintf \"Files added: %d\\n\", scalar @files_added\n        if $opt_diff_alignment;\n    foreach my $f (@files_added) {\n        next if $already_counted{$f};\n#printf \"%10s -> %s\\n\", $f, $Language{$fh[$F+1]}{$f};\n        # Don't proceed unless the file (both L and R versions)\n        # is in a known language.\n        next if $opt_include_lang\n                and not $Include_Language{$Language{$fh[$F+1]}{$f}};\n        next if $Language{$fh[$F+1]}{$f} eq \"(unknown)\";\n        next if $Exclude_Language{$Language{$fh[$F+1]}{$f}};\n        push @alignment, sprintf \"  + %s ; %s\\n\", $f, $Language{$fh[$F+1]}{$f}\n            if $opt_diff_alignment;\n        ++$Delta_by_Language{ $Language{$fh[$F+1]}{$f} }{'nFiles'}{'added'};\n        # Additionally, add contents of file $f to\n        #        Delta_by_File{$f}{comment/blank/code}{'added'}\n        #        Delta_by_Language{$lang}{comment/blank/code}{'added'}\n        my ($all_line_count,\n            $blank_count   ,\n            $comment_count ,\n           ) = call_counter($f, $Language{$fh[$F+1]}{$f}, \\@Errors);\n        $Delta_by_Language{ $Language{$fh[$F+1]}{$f} }{'comment'}{'added'} +=\n            $comment_count;\n        $Delta_by_Language{ $Language{$fh[$F+1]}{$f} }{'blank'}{'added'}   +=\n            $blank_count;\n        $Delta_by_Language{ $Language{$fh[$F+1]}{$f} }{'code'}{'added'}    +=\n            $all_line_count - $blank_count - $comment_count;\n        $Delta_by_File{ $f }{'comment'}{'added'} = $comment_count;\n        $Delta_by_File{ $f }{'blank'}{'added'}   = $blank_count;\n        $Delta_by_File{ $f }{'code'}{'added'}    =\n            $all_line_count - $blank_count - $comment_count;\n    }\n    push @alignment, \"\\n\";\n\n#print \"removed:\\n\";\n    push @alignment, sprintf \"Files removed: %d\\n\", scalar @files_removed\n        if $opt_diff_alignment;\n    foreach my $f (@files_removed) {\n        next if $already_counted{$f};\n        # Don't proceed unless the file (both L and R versions)\n        # is in a known language.\n        next if $opt_include_lang\n                and not $Include_Language{$Language{$fh[$F]}{$f}};\n        next if $Language{$fh[$F]}{$f} eq \"(unknown)\";\n        next if $Exclude_Language{$Language{$fh[$F]}{$f}};\n        ++$Delta_by_Language{ $Language{$fh[$F]}{$f} }{'nFiles'}{'removed'};\n        push @alignment, sprintf \"  - %s ; %s\\n\", $f, $Language{$fh[$F]}{$f}\n            if $opt_diff_alignment;\n#printf \"%10s -> %s\\n\", $f, $Language{$fh[$F  ]}{$f};\n        # Additionally, add contents of file $f to\n        #        Delta_by_File{$f}{comment/blank/code}{'removed'}\n        #        Delta_by_Language{$lang}{comment/blank/code}{'removed'}\n        my ($all_line_count,\n            $blank_count   ,\n            $comment_count ,\n           ) = call_counter($f, $Language{$fh[$F  ]}{$f}, \\@Errors);\n        $Delta_by_Language{ $Language{$fh[$F  ]}{$f} }{'comment'}{'removed'} +=\n            $comment_count;\n        $Delta_by_Language{ $Language{$fh[$F  ]}{$f} }{'blank'}{'removed'}   +=\n            $blank_count;\n        $Delta_by_Language{ $Language{$fh[$F  ]}{$f} }{'code'}{'removed'}    +=\n            $all_line_count - $blank_count - $comment_count;\n        $Delta_by_File{ $f }{'comment'}{'removed'} = $comment_count;\n        $Delta_by_File{ $f }{'blank'}{'removed'}   = $blank_count;\n        $Delta_by_File{ $f }{'code'}{'removed'}    =\n            $all_line_count - $blank_count - $comment_count;\n    }\n    push @alignment, \"\\n\";\n\n    my $alignment_pairs_index = scalar @alignment;\n    my $n_file_pairs_compared = 0;\n    # Don't know ahead of time how many file pairs will be compared\n    # since duplicates are weeded out below.  The answer is\n    # scalar @file_pairs only if there are no duplicates.\n    push @alignment, sprintf \"File pairs compared: UPDATE_ME\\n\"\n        if $opt_diff_alignment;\n\n    foreach my $pair (@file_pairs) {\n        my $file_L = $pair->[0];\n        my $file_R = $pair->[1];\n        my $Lang_L = $Language{$fh[$F  ]}{$file_L};\n        my $Lang_R = $Language{$fh[$F+1]}{$file_R};\n#print \"main step 6 file_L=$file_L    file_R=$file_R\\n\";\n        ++$nCounted;\n        printf \"Counting:  %d\\r\", $nCounted\n            unless (!$opt_progress_rate or ($nCounted % $opt_progress_rate));\n        next if $Ignored{$file_L};\n        # filter out non-included languages\n        if ($opt_include_lang and not $Include_Language{$Lang_L}\n                              and not $Include_Language{$Lang_R}) {\n            $Ignored{$file_L} = \"--include-lang=$Lang_L\";\n            $Ignored{$file_R} = \"--include-lang=$Lang_R\";\n            next;\n        }\n        # filter out excluded or unrecognized languages\n        if ($Exclude_Language{$Lang_L} or $Exclude_Language{$Lang_R}) {\n            $Ignored{$file_L} = \"--exclude-lang=$Lang_L\";\n            $Ignored{$file_R} = \"--exclude-lang=$Lang_R\";\n            next;\n        }\n        my $not_Filters_by_Language_Lang_LR = 0;\n#print \"file_LR = [$file_L] [$file_R]\\n\";\n#print \"Lang_LR = [$Lang_L] [$Lang_R]\\n\";\n        if (!(@{$Filters_by_Language{$Lang_L} }) or\n            !(@{$Filters_by_Language{$Lang_R} })) {\n            $not_Filters_by_Language_Lang_LR = 1;\n        }\n        if ($not_Filters_by_Language_Lang_LR) {\n            if (($Lang_L eq \"(unknown)\") or ($Lang_R eq \"(unknown)\")) {\n                $Ignored{$fh[$F  ]}{$file_L} = \"language unknown (#1)\";\n                $Ignored{$fh[$F+1]}{$file_R} = \"language unknown (#1)\";\n            } else {\n                $Ignored{$fh[$F  ]}{$file_L} = \"missing Filters_by_Language{$Lang_L}\";\n                $Ignored{$fh[$F+1]}{$file_R} = \"missing Filters_by_Language{$Lang_R}\";\n            }\n            next;\n        }\n\n#print \"DIFF($file_L, $file_R)\\n\";\n        # step 0: compare the two files' contents\n        chomp ( my @lines_L = read_file($file_L) );\n        chomp ( my @lines_R = read_file($file_R) );\n        my $language_file_L = \"\";\n        if (defined $Language{$fh[$F]}{$file_L}) {\n            $language_file_L = $Language{$fh[$F]}{$file_L};\n        } else {\n            # files $file_L and $file_R do not contain known language\n            next;\n        }\n        my $contents_are_same = 1;\n        if (scalar @lines_L == scalar @lines_R) {\n            # same size, must compare line-by-line\n            for (my $i = 0; $i < scalar @lines_L; $i++) {\n                if ($lines_L[$i] ne $lines_R[$i]) {\n                    $contents_are_same = 0;\n                    last;\n                }\n            }\n            if ($contents_are_same) {\n                ++$Delta_by_Language{$language_file_L}{'nFiles'}{'same'};\n            } else {\n                ++$Delta_by_Language{$language_file_L}{'nFiles'}{'modified'};\n            }\n        } else {\n            $contents_are_same = 0;\n            # different sizes, contents have changed\n            ++$Delta_by_Language{$language_file_L}{'nFiles'}{'modified'};\n        }\n        if ($opt_diff_alignment) {\n            my $str =  \"$file_L | $file_R ; $language_file_L\";\n            if ($contents_are_same) {\n                push @alignment, \"  == $str\";\n            } else {\n                push @alignment, \"  != $str\";\n            }\n            ++$n_file_pairs_compared;\n        }\n\n        # step 1: identify comments in both files\n#print \"Diff blank removal L language= $Lang_L\";\n#print \" scalar(lines_L)=\", scalar @lines_L, \"\\n\";\n        my @original_minus_blanks_L\n                    = rm_blanks(  \\@lines_L, $Lang_L, \\%EOL_Continuation_re);\n#print \"1: scalar(original_minus_blanks_L)=\", scalar @original_minus_blanks_L, \"\\n\";\n        @lines_L    = @original_minus_blanks_L;\n#print \"2: scalar(lines_L)=\", scalar @lines_L, \"\\n\";\n        @lines_L    = add_newlines(\\@lines_L); # compensate for rm_comments()\n        @lines_L    = rm_comments( \\@lines_L, $Lang_L, $file_L,\n                                   \\%EOL_Continuation_re);\n#print \"3: scalar(lines_L)=\", scalar @lines_L, \"\\n\";\n\n#print \"Diff blank removal R language= $Lang_R\\n\";\n        my @original_minus_blanks_R\n                    = rm_blanks(  \\@lines_R, $Lang_R, \\%EOL_Continuation_re);\n        @lines_R    = @original_minus_blanks_R;\n        @lines_R    = add_newlines(\\@lines_R); # taken away by rm_comments()\n        @lines_R    = rm_comments( \\@lines_R, $Lang_R, $file_R,\n                                   \\%EOL_Continuation_re);\n\n        my (@diff_LL, @diff_LR, );\n        array_diff( $file_L                  ,   # in\n                   \\@original_minus_blanks_L ,   # in\n                   \\@lines_L                 ,   # in\n                   \"comment\"                 ,   # in\n                   \\@diff_LL, \\@diff_LR      ,   # out\n                   \\@Errors);                    # in/out\n\n        my (@diff_RL, @diff_RR, );\n        array_diff( $file_R                  ,   # in\n                   \\@original_minus_blanks_R ,   # in\n                   \\@lines_R                 ,   # in\n                   \"comment\"                 ,   # in\n                   \\@diff_RL, \\@diff_RR      ,   # out\n                   \\@Errors);                    # in/out\n        # each line of each file is now classified as\n        # code or comment\n\n#use Data::Dumper;\n#print Dumper(\"diff_LL\", \\@diff_LL, \"diff_LR\", \\@diff_LR, );\n#print Dumper(\"diff_RL\", \\@diff_RL, \"diff_RR\", \\@diff_RR, );\n#die;\n        # step 2: separate code from comments for L and R files\n        my @code_L = ();\n        my @code_R = ();\n        my @comm_L = ();\n        my @comm_R = ();\n        foreach my $line_info (@diff_LL) {\n            if      ($line_info->{'type'} eq \"code\"   ) {\n                push @code_L, $line_info->{char};\n            } elsif ($line_info->{'type'} eq \"comment\") {\n                push @comm_L, $line_info->{char};\n            } else {\n                die \"Diff unexpected line type \",\n                    $line_info->{'type'}, \"for $file_L line \",\n                    $line_info->{'lnum'};\n            }\n        }\n        foreach my $line_info (@diff_RL) {\n            if      ($line_info->{type} eq \"code\"   ) {\n                push @code_R, $line_info->{'char'};\n            } elsif ($line_info->{type} eq \"comment\") {\n                push @comm_R, $line_info->{'char'};\n            } else {\n                die \"Diff unexpected line type \",\n                    $line_info->{'type'}, \"for $file_R line \",\n                    $line_info->{'lnum'};\n            }\n        }\n\n        if ($opt_ignore_whitespace) {\n            # strip all whitespace from each line of source code\n            # and comments then use these stripped arrays in diffs\n            foreach (@code_L) { s/\\s+//g }\n            foreach (@code_R) { s/\\s+//g }\n            foreach (@comm_L) { s/\\s+//g }\n            foreach (@comm_R) { s/\\s+//g }\n        }\n        if ($opt_ignore_case) {\n            # change all text to lowercase in diffs\n            foreach (@code_L) { $_ = lc }\n            foreach (@code_R) { $_ = lc }\n            foreach (@comm_L) { $_ = lc }\n            foreach (@comm_R) { $_ = lc }\n        }\n        # step 3: compute code diffs\n        array_diff(\"$file_L v. $file_R\"   ,   # in\n                   \\@code_L               ,   # in\n                   \\@code_R               ,   # in\n                   \"revision\"             ,   # in\n                   \\@diff_LL, \\@diff_LR   ,   # out\n                   \\@Errors);                 # in/out\n#print Dumper(\"diff_LL\", \\@diff_LL, \"diff_LR\", \\@diff_LR, );\n#print Dumper(\"diff_LR\", \\@diff_LR);\n        foreach my $line_info (@diff_LR) {\n            my $status = $line_info->{'desc'}; # same|added|removed|modified\n            ++$Delta_by_Language{$Lang_L}{'code'}{$status};\n            if ($opt_by_file) {\n                ++$Delta_by_File{$file_L}{'code'}{$status};\n            }\n        }\n#use Data::Dumper;\n#print Dumper(\"code diffs:\", \\@diff_LL, \\@diff_LR);\n\n        # step 4: compute comment diffs\n        array_diff(\"$file_L v. $file_R\"   ,   # in\n                   \\@comm_L               ,   # in\n                   \\@comm_R               ,   # in\n                   \"revision\"             ,   # in\n                   \\@diff_LL, \\@diff_LR   ,   # out\n                   \\@Errors);                 # in/out\n#print Dumper(\"comment diff_LR\", \\@diff_LR);\n        foreach my $line_info (@diff_LR) {\n            my $status = $line_info->{'desc'}; # same|added|removed|modified\n            ++$Delta_by_Language{$Lang_L}{'comment'}{$status};\n            if ($opt_by_file) {\n                ++$Delta_by_File{$file_L}{'comment'}{$status};\n            }\n        }\n#print Dumper(\"comment diffs:\", \\@diff_LL, \\@diff_LR);\n\n        # step 5: compute difference in blank lines (kind of pointless)\n        next if $Lang_L eq '(unknown)' or\n                $Lang_R eq '(unknown)';\n        my ($all_line_count_L,\n            $blank_count_L   ,\n            $comment_count_L ,\n           ) = call_counter($file_L, $Lang_L, \\@Errors);\n\n        my ($all_line_count_R,\n            $blank_count_R   ,\n            $comment_count_R ,\n           ) = call_counter($file_R, $Lang_R, \\@Errors);\n\n        if ($blank_count_L <  $blank_count_R) {\n            my $D = $blank_count_R - $blank_count_L;\n            $Delta_by_Language{$Lang_L}{'blank'}{'added'}   += $D;\n        } else {\n            my $D = $blank_count_L - $blank_count_R;\n            $Delta_by_Language{$Lang_L}{'blank'}{'removed'} += $D;\n        }\n        if ($opt_by_file) {\n            if ($blank_count_L <  $blank_count_R) {\n                my $D = $blank_count_R - $blank_count_L;\n                $Delta_by_File{$file_L}{'blank'}{'added'}   += $D;\n            } else {\n                my $D = $blank_count_L - $blank_count_R;\n                $Delta_by_File{$file_L}{'blank'}{'removed'} += $D;\n            }\n        }\n\n        my $code_count_L = $all_line_count_L-$blank_count_L-$comment_count_L;\n        if ($opt_by_file) {\n            $Results_by_File{$file_L}{'code'   } = $code_count_L    ;\n            $Results_by_File{$file_L}{'blank'  } = $blank_count_L   ;\n            $Results_by_File{$file_L}{'comment'} = $comment_count_L ;\n            $Results_by_File{$file_L}{'lang'   } = $Lang_L          ;\n            $Results_by_File{$file_L}{'nFiles' } = 1                ;\n        } else {\n            $Results_by_File{$file_L} = 1;  # just keep track of counted files\n        }\n\n        $Results_by_Language{$Lang_L}{'nFiles'}++;\n        $Results_by_Language{$Lang_L}{'code'}    += $code_count_L   ;\n        $Results_by_Language{$Lang_L}{'blank'}   += $blank_count_L  ;\n        $Results_by_Language{$Lang_L}{'comment'} += $comment_count_L;\n    }\n    if ($opt_diff_alignment) {\n        $alignment[$alignment_pairs_index] =~ s/UPDATE_ME/$n_file_pairs_compared/;\n        write_file($opt_diff_alignment, @alignment);\n    }\n\n}\n#use Data::Dumper;\n#print Dumper(\"Delta_by_Language:\"  , \\%Delta_by_Language);\n#print Dumper(\"Results_by_Language:\", \\%Results_by_Language);\n#print Dumper(\"Delta_by_File:\"      , \\%Delta_by_File);\n#print Dumper(\"Results_by_File:\"    , \\%Results_by_File);\n#die;\nmy @ignored_reasons = map { \"$_: $Ignored{$_}\" } sort keys %Ignored;\nwrite_file($opt_ignored, @ignored_reasons   ) if $opt_ignored;\nwrite_file($opt_counted, sort keys %Results_by_File) if $opt_counted;\n# 1}}}\n# Step 7:  Assemble results.                   {{{1\n#\nmy $end_time = get_time();\nprintf \"%8d file%s ignored.                           \\n\",\n    plural_form(scalar keys %Ignored) unless $opt_quiet;\nprint_errors(\\%Error_Codes, \\@Errors) if @Errors;\nif (!%Delta_by_Language) {\n    print \"Nothing to count.\\n\";\n    exit;\n}\n\nif ($opt_by_file) {\n    @Lines_Out = diff_report($VERSION, get_time() - $start_time,\n                            \"by file\",\n                            \\%Delta_by_File, \\%Scale_Factor);\n} else {\n    @Lines_Out = diff_report($VERSION, get_time() - $start_time,\n                            \"by language\",\n                            \\%Delta_by_Language, \\%Scale_Factor);\n}\n\n# 1}}}\n} else {\n# Step 4:  Separate code from non-code files.  {{{1\nmy $fh = 0;\nif ($opt_list_file or $opt_vcs) {\n    my @list;\n    if ($opt_vcs) {\n        @list = invoke_generator($opt_vcs, \\@ARGV);\n    } else {\n        @list = read_list_file($opt_list_file);\n    }\n    $fh = make_file_list(\\@list, \\%Error_Codes, \\@Errors, \\%Ignored);\n} else {\n    $fh = make_file_list(\\@ARGV, \\%Error_Codes, \\@Errors, \\%Ignored);\n    #     make_file_list populates global variable @file_list via call to\n    #     File::Find's find() which in turn calls files()\n}\nif ($opt_exclude_list_file) {\n    # note: process_exclude_list_file() references global @file_list\n    process_exclude_list_file($opt_exclude_list_file,\n                             \\%Exclude_Dir,\n                             \\%Ignored);\n}\nif ($opt_skip_win_hidden and $ON_WINDOWS) {\n    my @file_list_minus_hidded = ();\n    # eval code to run on Unix without 'missing Win32::File module' error.\n    my $win32_file_invocation = '\n        use Win32::File;\n        foreach my $F (@file_list) {\n            my $attr = undef;\n            Win32::File::GetAttributes($F, $attr);\n            if ($attr & HIDDEN) {\n                $Ignored{$F} = \"Windows hidden file\";\n                print \"Ignoring $F since it is a Windows hidden file\\n\"\n                    if $opt_v > 1;\n            } else {\n                push @file_list_minus_hidded, $F;\n            }\n        }';\n    eval $win32_file_invocation;\n    @file_list = @file_list_minus_hidded;\n}\n#printf \"%8d file%s excluded.                     \\n\",\n#   plural_form(scalar keys %Ignored)\n#   unless $opt_quiet;\n# die print \": \", join(\"\\n: \", @file_list), \"\\n\";\n# 1}}}\n# Step 5:  Remove duplicate files.             {{{1\n#\nmy %Language           = ();\nmy %unique_source_file = ();\nremove_duplicate_files($fh                          ,   # in\n                           \\%Language               ,   # out\n                           \\%unique_source_file     ,   # out\n                      \\%Error_Codes                 ,   # in\n                           \\@Errors                 ,   # out\n                           \\%Ignored                );  # out\nprintf \"%8d unique file%s.                              \\n\",\n    plural_form(scalar keys %unique_source_file)\n    unless $opt_quiet;\n# 1}}}\n# Step 6:  Count code, comments, blank lines.  {{{1\n#\n\nmy %Results_by_Language = ();\nmy %Results_by_File     = ();\nmy $nCounted = 0;\nforeach my $file (sort keys %unique_source_file) {\n    ++$nCounted;\n    printf \"Counting:  %d\\r\", $nCounted\n        unless (!$opt_progress_rate or ($nCounted % $opt_progress_rate));\n    next if $Ignored{$file};\n    if ($opt_include_lang and not $Include_Language{$Language{$file}}) {\n        $Ignored{$file} = \"--include-lang=$Language{$file}\";\n        next;\n    }\n    if ($Exclude_Language{$Language{$file}}) {\n        $Ignored{$file} = \"--exclude-lang=$Language{$file}\";\n        next;\n    }\n    my $Filters_by_Language_Language_file = ! @{$Filters_by_Language{$Language{$file}} };\n    if ($Filters_by_Language_Language_file) {\n        if ($Language{$file} eq \"(unknown)\") {\n            $Ignored{$file} = \"language unknown (#1)\";\n        } else {\n            $Ignored{$file} = \"missing Filters_by_Language{$Language{$file}}\";\n        }\n        next;\n    }\n\n    my ($all_line_count, $blank_count, $comment_count, $code_count);\n    if ($opt_use_sloccount and $Language{$file} =~ /^(C|C\\+\\+|XML|PHP|Pascal|Java)$/) {\n        chomp ($blank_count     = `grep -Pcv '\\\\S' $file`);\n        chomp ($all_line_count  = `cat $file | wc -l`);\n        if      ($Language{$file} =~ /^(C|C\\+\\+)$/) {\n            $code_count = `cat '$file' | c_count      | head -n 1`;\n        } elsif ($Language{$file} eq \"XML\") {\n            $code_count = `cat '$file' | xml_count    | head -n 1`;\n        } elsif ($Language{$file} eq \"PHP\") {\n            $code_count = `cat '$file' | php_count    | head -n 1`;\n        } elsif ($Language{$file} eq \"Pascal\") {\n            $code_count = `cat '$file' | pascal_count | head -n 1`;\n        } elsif ($Language{$file} eq \"Java\") {\n            $code_count = `cat '$file' | java_count   | head -n 1`;\n        } else {\n            die \"SLOCCount match failure: file=[$file] lang=[$Language{$file}]\";\n        }\n        $code_count = substr($code_count, 0, -2);\n        $comment_count = $all_line_count - $code_count - $blank_count;\n    } else {\n        ($all_line_count,\n         $blank_count   ,\n         $comment_count ,) = call_counter($file, $Language{$file}, \\@Errors);\n        $code_count = $all_line_count - $blank_count - $comment_count;\n    }\n    if ($opt_by_file) {\n        $Results_by_File{$file}{'code'   } = $code_count     ;\n        $Results_by_File{$file}{'blank'  } = $blank_count    ;\n        $Results_by_File{$file}{'comment'} = $comment_count  ;\n        $Results_by_File{$file}{'lang'   } = $Language{$file};\n        $Results_by_File{$file}{'nFiles' } = 1;\n    } else {\n        $Results_by_File{$file} = 1;  # just keep track of counted files\n    }\n\n    $Results_by_Language{$Language{$file}}{'nFiles'}++;\n    $Results_by_Language{$Language{$file}}{'code'}    += $code_count   ;\n    $Results_by_Language{$Language{$file}}{'blank'}   += $blank_count  ;\n    $Results_by_Language{$Language{$file}}{'comment'} += $comment_count;\n}\nmy @ignored_reasons = map { \"$_: $Ignored{$_}\" } sort keys %Ignored;\nwrite_file($opt_ignored, @ignored_reasons   ) if $opt_ignored;\nwrite_file($opt_counted, sort keys %Results_by_File) if $opt_counted;\n# 1}}}\n# Step 7:  Assemble results.                   {{{1\n#\nmy $end_time = get_time();\nprintf \"%8d file%s ignored.\\n\", plural_form(scalar keys %Ignored)\n    unless $opt_quiet;\nprint_errors(\\%Error_Codes, \\@Errors) if @Errors;\nexit unless %Results_by_Language;\n\ngenerate_sql($end_time - $start_time,\n            \\%Results_by_File, \\%Scale_Factor) if $opt_sql;\n\nexit if $skip_generate_report;\nif      ($opt_by_file_by_lang) {\n    push @Lines_Out, generate_report( $VERSION, $end_time - $start_time,\n                                      \"by file\",\n                                      \\%Results_by_File,    \\%Scale_Factor);\n    push @Lines_Out, generate_report( $VERSION, $end_time - $start_time,\n                                      \"by language\",\n                                      \\%Results_by_Language, \\%Scale_Factor);\n} elsif ($opt_by_file) {\n    push @Lines_Out, generate_report( $VERSION, $end_time - $start_time,\n                                      \"by file\",\n                                      \\%Results_by_File,    \\%Scale_Factor);\n} else {\n    push @Lines_Out, generate_report( $VERSION, $end_time - $start_time,\n                                      \"by language\",\n                                      \\%Results_by_Language, \\%Scale_Factor);\n}\n# 1}}}\n}\nif ($opt_report_file) { write_file($opt_report_file, @Lines_Out); }\nelse                  { print \"\\n\", join(\"\\n\", @Lines_Out), \"\\n\"; }\nif ($opt_count_diff) {\n    ++$opt_count_diff;\n    exit if $opt_count_diff > 3;\n    goto Top_of_Processing_Loop;\n}\n\nsub exclude_dir_validates {                  # {{{1\n    my ($rh_Exclude_Dir) = @_;\n    my $is_OK = 1;\n    foreach my $dir (keys %{$rh_Exclude_Dir}) {\n        if (($ON_WINDOWS and $dir =~ m{\\\\}) or ($dir =~ m{/})) {\n            $is_OK = 0;\n            warn \"--exclude-dir '$dir' :  cannot specify directory paths\\n\";\n        }\n    }\n    if (!$is_OK) {\n        warn \"Use '--fullpath --not-match-d=REGEX' instead\\n\";\n    }\n    return $is_OK;\n} # 1}}}\nsub process_exclude_list_file {              # {{{1\n    my ($list_file      , # in\n        $rh_exclude_dir , # out\n        $rh_ignored     , # out\n       ) = @_;\n    # note: references global @file_list\n    print \"-> process_exclude_list_file($list_file)\\n\" if $opt_v > 2;\n    # reject a specific set of files and/or directories\n    my @reject_list   = read_list_file($list_file);\n    my @file_reject_list = ();\n    foreach my $F_or_D (@reject_list) {\n        if (is_dir($F_or_D)) {\n            $rh_exclude_dir->{$F_or_D} = 1;\n        } elsif (is_file($F_or_D)) {\n            push @file_reject_list, $F_or_D;\n        }\n    }\n\n    # Normalize file names for better comparison.\n    my %normalized_input   = normalize_file_names(@file_list);\n    my %normalized_reject  = normalize_file_names(@file_reject_list);\n    my %normalized_exclude = normalize_file_names(keys %{$rh_exclude_dir});\n    foreach my $F (keys %normalized_input) {\n        if ($normalized_reject{$F} or is_excluded($F, \\%normalized_exclude)) {\n            my $orig_F = $normalized_input{$F};\n            $rh_ignored->{$orig_F} = \"listed in exclusion file $opt_exclude_list_file\";\n            print \"Ignoring $orig_F because it appears in $opt_exclude_list_file\\n\"\n                if $opt_v > 1;\n        }\n    }\n    print \"<- process_exclude_list_file\\n\" if $opt_v > 2;\n} # 1}}}\nsub combine_results {                        # {{{1\n    # returns 1 if the inputs are categorized by language\n    #         0 if no identifiable language was found\n    my ($ra_report_files, # in\n        $report_type    , # in  \"by language\" or \"by report file\"\n        $rhh_count      , # out count{TYPE}{nFiles|code|blank|comment|scaled}\n        $rhaa_Filters_by_Language , # in\n       ) = @_;\n\n    print \"-> combine_results(report_type=$report_type)\\n\" if $opt_v > 2;\n    my $found_language = 0;\n\n    foreach my $file (@{$ra_report_files}) {\n        my $IN = new IO::File $file, \"r\";\n        if (!defined $IN) {\n            warn \"Unable to read $file; ignoring.\\n\";\n            next;\n        }\n        while (<$IN>) {\n            next if /^(http|Language|SUM|-----)/;\n            if (!$opt_by_file  and\n                m{^(.*?)\\s+         # language\n                   (\\d+)\\s+         # files\n                   (\\d+)\\s+         # blank\n                   (\\d+)\\s+         # comments\n                   (\\d+)\\s+         # code\n                   (                #    next four entries missing with -nno3\n                   x\\s+             # x\n                   \\d+\\.\\d+\\s+      # scale\n                   =\\s+             # =\n                   (\\d+\\.\\d+)\\s*    # scaled code\n                   )?\n                   $}x) {\n                if ($report_type eq \"by language\") {\n                    if (!defined $rhaa_Filters_by_Language->{$1}) {\n                        warn \"Unrecognized language '$1' in $file ignored\\n\";\n                        next;\n                    }\n                    # above test necessary to avoid trying to sum reports\n                    # of reports (which have no language breakdown).\n                    $found_language = 1;\n                    $rhh_count->{$1   }{'nFiles' } += $2;\n                    $rhh_count->{$1   }{'blank'  } += $3;\n                    $rhh_count->{$1   }{'comment'} += $4;\n                    $rhh_count->{$1   }{'code'   } += $5;\n                    $rhh_count->{$1   }{'scaled' } += $7 if $opt_3;\n                } else {\n                    $rhh_count->{$file}{'nFiles' } += $2;\n                    $rhh_count->{$file}{'blank'  } += $3;\n                    $rhh_count->{$file}{'comment'} += $4;\n                    $rhh_count->{$file}{'code'   } += $5;\n                    $rhh_count->{$file}{'scaled' } += $7 if $opt_3;\n                }\n            } elsif ($opt_by_file  and\n                m{^(.*?)\\s+         # language\n                   (\\d+)\\s+         # blank\n                   (\\d+)\\s+         # comments\n                   (\\d+)\\s+         # code\n                   (                #    next four entries missing with -nno3\n                   x\\s+             # x\n                   \\d+\\.\\d+\\s+      # scale\n                   =\\s+             # =\n                   (\\d+\\.\\d+)\\s*    # scaled code\n                   )?\n                   $}x) {\n                if ($report_type eq \"by language\") {\n                    next unless %{$rhaa_Filters_by_Language->{$1}};\n                    # above test necessary to avoid trying to sum reports\n                    # of reports (which have no language breakdown).\n                    $found_language = 1;\n                    $rhh_count->{$1   }{'nFiles' } +=  1;\n                    $rhh_count->{$1   }{'blank'  } += $2;\n                    $rhh_count->{$1   }{'comment'} += $3;\n                    $rhh_count->{$1   }{'code'   } += $4;\n                    $rhh_count->{$1   }{'scaled' } += $6 if $opt_3;\n                } else {\n                    $rhh_count->{$file}{'nFiles' } +=  1;\n                    $rhh_count->{$file}{'blank'  } += $2;\n                    $rhh_count->{$file}{'comment'} += $3;\n                    $rhh_count->{$file}{'code'   } += $4;\n                    $rhh_count->{$file}{'scaled' } += $6 if $opt_3;\n                }\n            }\n        }\n    }\n    print \"<- combine_results\\n\" if $opt_v > 2;\n    return $found_language;\n} # 1}}}\nsub compute_denominator {                    # {{{1\n    my ($method, $nCode, $nComment, $nBlank, ) = @_;\n    print \"-> compute_denominator\\n\" if $opt_v > 2;\n    my %den        = ( \"c\" => $nCode );\n       $den{\"cm\"}  = $den{\"c\"}  + $nComment;\n       $den{\"cmb\"} = $den{\"cm\"} + $nBlank;\n       $den{\"cb\"}  = $den{\"c\"}  + $nBlank;\n\n    print \"<- compute_denominator\\n\" if $opt_v > 2;\n    return $den{ $method };\n} # 1}}}\nsub yaml_to_json_separators {                # {{{1\n    # YAML and JSON are closely related.  Their differences can be captured\n    # by trailing commas ($C), braces ($open_B, $close_B), and\n    # quotes around text ($Q).\n    my ($Q, $open_B, $close_B, $start, $C);\n    if ($opt_json) {\n       $C       = ',';\n       $Q       = '\"';\n       $open_B  = '{';\n       $close_B = '}';\n       $start   = '{';\n    } else {\n       $C       = '';\n       $Q       = '' ;\n       $open_B  = '' ;\n       $close_B = '';\n       $start   = \"---\\n# $URL\\n\";\n    }\n    return ($Q, $open_B, $close_B, $start, $C);\n} # 1}}}\nsub diff_report     {                        # {{{1\n    # returns an array of lines containing the results\n    print \"-> diff_report\\n\" if $opt_v > 2;\n\n    if ($opt_xml) {\n        print \"<- diff_report\\n\" if $opt_v > 2;\n        return diff_xml_report(@_)\n###     return diff_xml_yaml_json_report(@_)\n    } elsif ($opt_yaml) {\n        print \"<- diff_report\\n\" if $opt_v > 2;\n        return diff_yaml_report(@_)\n    } elsif ($opt_json) {\n        print \"<- diff_report\\n\" if $opt_v > 2;\n        return diff_json_report(@_)\n    } elsif ($opt_csv or $opt_md) {\n        print \"<- diff_report\\n\" if $opt_v > 2;\n        return diff_csv_report(@_)\n    }\n\n    my ($version    , # in\n        $elapsed_sec, # in\n        $report_type, # in  \"by language\" | \"by report file\" | \"by file\"\n        $rhhh_count , # in  count{TYPE}{nFiles|code|blank|comment}{a|m|r|s}\n        $rh_scale   , # in\n       ) = @_;\n\n#use Data::Dumper;\n#print \"diff_report: \", Dumper($rhhh_count), \"\\n\";\n    my @results       = ();\n\n    my $languages     = ();\n    my %sum           = (); # sum{nFiles|blank|comment|code}{same|modified|added|removed}\n    my $max_len       = 0;\n    foreach my $language (keys %{$rhhh_count}) {\n        foreach my $V (qw(nFiles blank comment code)) {\n            foreach my $S (qw(added same modified removed)) {\n                $rhhh_count->{$language}{$V}{$S} = 0 unless\n                    defined $rhhh_count->{$language}{$V}{$S};\n                $sum{$V}{$S}  += $rhhh_count->{$language}{$V}{$S};\n            }\n        }\n        $max_len      = length($language) if length($language) > $max_len;\n    }\n    my $column_1_offset = 0;\n       $column_1_offset = $max_len - 17 if $max_len > 17;\n    $elapsed_sec = 0.5 unless $elapsed_sec;\n\n    my $spacing_0 = 23;\n    my $spacing_1 = 13;\n    my $spacing_2 =  9;\n    my $spacing_3 = 17;\n    if (!$opt_3) {\n        $spacing_1 = 19;\n        $spacing_2 = 14;\n        $spacing_3 = 28;\n    }\n    $spacing_0 += $column_1_offset;\n    $spacing_1 += $column_1_offset;\n    $spacing_3 += $column_1_offset;\n    my %Format = (\n        '1' => { 'xml' => 'name=\"%s\" ',\n                 'txt' => \"\\%-${spacing_0}s \",\n               },\n        '2' => { 'xml' => 'name=\"%s\" ',\n                 'txt' => \"\\%-${spacing_3}s \",\n               },\n        '3' => { 'xml' => 'files_count=\"%d\" ',\n                 'txt' => '%5d ',\n               },\n        '4' => { 'xml' => 'blank=\"%d\" comment=\"%d\" code=\"%d\" ',\n                 'txt' => \"\\%${spacing_2}d \\%${spacing_2}d \\%${spacing_2}d\",\n               },\n        '5' => { 'xml' => 'blank=\"%.2f\" comment=\"%.2f\" code=\"%d\" ',\n                 'txt' => \"\\%3.2f \\%3.2f \\%${spacing_2}d\",\n               },\n        '6' => { 'xml' => 'factor=\"%.2f\" scaled=\"%.2f\" ',\n                 'txt' => ' x %6.2f = %14.2f',\n               },\n    );\n    my $Style = \"txt\";\n       $Style = \"xml\" if $opt_xml ;\n       $Style = \"xml\" if $opt_yaml;  # not a typo; just set to anything but txt\n       $Style = \"xml\" if $opt_json;  # not a typo; just set to anything but txt\n       $Style = \"xml\" if $opt_csv ;  # not a typo; just set to anything but txt\n\n    my $hyphen_line = sprintf \"%s\", '-' x (79 + $column_1_offset);\n       $hyphen_line = sprintf \"%s\", '-' x (68 + $column_1_offset)\n            if (!$opt_3) and (68 + $column_1_offset) > 79;\n    my $data_line  = \"\";\n    my $first_column;\n    my $BY_LANGUAGE = 0;\n    my $BY_FILE     = 0;\n    if      ($report_type eq \"by language\") {\n        $first_column = \"Language\";\n        $BY_LANGUAGE  = 1;\n    } elsif ($report_type eq \"by file\")     {\n        $first_column = \"File\";\n        $BY_FILE      = 1;\n    } else {\n        $first_column = \"Report File\";\n    }\n\n    my $header_line  = sprintf \"%s v %s\", $URL, $version;\n    my $sum_files    = 1;\n    my $sum_lines    = 1;\n       $header_line .= sprintf(\"  T=%.2f s (%.1f files/s, %.1f lines/s)\",\n                        $elapsed_sec           ,\n                        $sum_files/$elapsed_sec,\n                        $sum_lines/$elapsed_sec) unless $opt_sum_reports;\n    if ($Style eq \"txt\") {\n        push @results, output_header($header_line, $hyphen_line, $BY_FILE);\n    } elsif ($Style eq \"csv\") {\n        die \"csv\";\n    }\n\n    # column headers\n    if (!$opt_3 and $BY_FILE) {\n        my $spacing_n = $spacing_1 - 11;\n        $data_line  = sprintf \"%-${spacing_n}s\" , $first_column;\n    } else {\n        $data_line  = sprintf \"%-${spacing_1}s \", $first_column;\n    }\n    if ($BY_FILE) {\n        $data_line .= sprintf \"%${spacing_2}s\"   , \"\"     ;\n    } else {\n        $data_line .= sprintf \"%${spacing_2}s \"  , \"files\";\n    }\n    my $PCT_symbol = \"\";\n       $PCT_symbol = \" \\%\" if $opt_by_percent;\n    $data_line .= sprintf \"%${spacing_2}s %${spacing_2}s %${spacing_2}s\",\n        \"blank${PCT_symbol}\"         ,\n        \"comment${PCT_symbol}\"       ,\n        \"code\";\n\n    if ($Style eq \"txt\") {\n        push @results, $data_line;\n        push @results, $hyphen_line;\n    }\n\n####foreach my $lang_or_file (keys %{$rhhh_count}) {\n####    $rhhh_count->{$lang_or_file}{'code'} = 0 unless\n####        defined $rhhh_count->{$lang_or_file}{'code'};\n####}\n    foreach my $lang_or_file (sort {\n                                 $rhhh_count->{$b}{'code'} <=>\n                                 $rhhh_count->{$a}{'code'}\n                               }\n                          keys %{$rhhh_count}) {\n\n        if ($BY_FILE) {\n            push @results, rm_leading_tempdir($lang_or_file, \\%TEMP_DIR);\n        } else {\n            push @results, $lang_or_file;\n        }\n        foreach my $S (qw(same modified added removed)) {\n            my $indent = $spacing_1 - 2;\n            my $line .= sprintf \" %-${indent}s\", $S;\n            if ($BY_FILE) {\n                $line .= sprintf \"   \";\n            } else {\n                $line .= sprintf \"  %${spacing_2}s\", $rhhh_count->{$lang_or_file}{'nFiles'}{$S};\n            }\n            if ($opt_by_percent) {\n                my $DEN = compute_denominator($opt_by_percent  ,\n                    $rhhh_count->{$lang_or_file}{'code'}{$S}   ,\n                    $rhhh_count->{$lang_or_file}{'comment'}{$S},\n                    $rhhh_count->{$lang_or_file}{'blank'}{$S}  );\n                if ($rhhh_count->{$lang_or_file}{'code'}{$S} > 0) {\n                    $line .= sprintf \" %14.2f %14.2f %${spacing_2}s\",\n                        $rhhh_count->{$lang_or_file}{'blank'}{$S}   / $DEN * 100,\n                        $rhhh_count->{$lang_or_file}{'comment'}{$S} / $DEN * 100,\n                        $rhhh_count->{$lang_or_file}{'code'}{$S}    ;\n                } else {\n                    $line .= sprintf \" %14.2f %14.2f %${spacing_2}s\",\n                        0.0, 0.0, $rhhh_count->{$lang_or_file}{'code'}{$S}    ;\n                }\n            } else {\n                $line .= sprintf \" %${spacing_2}s %${spacing_2}s %${spacing_2}s\",\n                    $rhhh_count->{$lang_or_file}{'blank'}{$S}   ,\n                    $rhhh_count->{$lang_or_file}{'comment'}{$S} ,\n                    $rhhh_count->{$lang_or_file}{'code'}{$S}    ;\n            }\n            push @results, $line;\n        }\n    }\n    push @results, $hyphen_line;\n    push @results, \"SUM:\";\n    foreach my $S (qw(same modified added removed)) {\n        my $indent = $spacing_1 - 2;\n        my $line .= sprintf \" %-${indent}s\", $S;\n            if ($BY_FILE) {\n                $line .= sprintf \"   \";\n            } else {\n                $line .= sprintf \"  %${spacing_2}s\", $sum{'nFiles'}{$S};\n            }\n        if ($opt_by_percent) {\n            my $DEN = compute_denominator($opt_by_percent,\n                $sum{'code'}{$S}, $sum{'comment'}{$S}, $sum{'blank'}{$S});\n            if ($sum{'code'}{$S} > 0) {\n                $line .= sprintf \" %14.2f %14.2f %${spacing_2}s\",\n                    $sum{'blank'}{$S}   / $DEN * 100,\n                    $sum{'comment'}{$S} / $DEN * 100,\n                    $sum{'code'}{$S}    ;\n            } else {\n                $line .= sprintf \" %14.2f %14.2f %${spacing_2}s\",\n                    0.0, 0.0, $sum{'code'}{$S}    ;\n            }\n        } else {\n            $line .= sprintf \" %${spacing_2}s %${spacing_2}s %${spacing_2}s\",\n                $sum{'blank'}{$S}   ,\n                $sum{'comment'}{$S} ,\n                $sum{'code'}{$S}    ;\n        }\n        push @results, $line;\n    }\n    push @results, $hyphen_line;\n    write_xsl_file() if $opt_xsl and $opt_xsl eq $CLOC_XSL;\n    print \"<- diff_report\\n\" if $opt_v > 2;\n\n    return @results;\n} # 1}}}\nsub xml_yaml_or_json_header {                # {{{1\n    my ($URL, $version, $elapsed_sec, $sum_files, $sum_lines, $by_file) = @_;\n    print \"-> xml_yaml_or_json_header\\n\" if $opt_v > 2;\n    my $header      = \"\";\n    my $file_rate   = $sum_files/$elapsed_sec;\n    my $line_rate   = $sum_lines/$elapsed_sec;\n    my $type        = \"\";\n       $type        = \"diff_\" if $opt_diff;\n    my $report_file = \"\";\n    if ($opt_report_file) {\n        if ($opt_sum_reports) {\n            if ($by_file) {\n                $report_file = \"  <report_file>$opt_report_file.file</report_file>\"\n            } else {\n                $report_file = \"  <report_file>$opt_report_file.lang</report_file>\"\n            }\n        } else {\n            $report_file = \"  <report_file>$opt_report_file</report_file>\"\n        }\n    }\n    if ($opt_xml) {\n        $header = \"<?xml version=\\\"1.0\\\"?>\";\n        $header .= \"\\n<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"\" . $opt_xsl . \"\\\"?>\" if $opt_xsl;\n        $header .= \"<${type}results>\n<header>\n  <cloc_url>$URL</cloc_url>\n  <cloc_version>$version</cloc_version>\n  <elapsed_seconds>$elapsed_sec</elapsed_seconds>\n  <n_files>$sum_files</n_files>\n  <n_lines>$sum_lines</n_lines>\n  <files_per_second>$file_rate</files_per_second>\n  <lines_per_second>$line_rate</lines_per_second>\";\n        $header .= \"\\n$report_file\"\n            if $opt_report_file;\n        $header .= \"\\n</header>\";\n    } elsif ($opt_yaml or $opt_json) {\n        my ($Q, $open_B, $close_B, $start, $C) = yaml_to_json_separators();\n        $header = \"${start}${Q}header${Q} : $open_B\n  ${Q}cloc_url${Q}           : ${Q}$URL${Q}${C}\n  ${Q}cloc_version${Q}       : ${Q}$version${Q}${C}\n  ${Q}elapsed_seconds${Q}    : $elapsed_sec${C}\n  ${Q}n_files${Q}            : $sum_files${C}\n  ${Q}n_lines${Q}            : $sum_lines${C}\n  ${Q}files_per_second${Q}   : $file_rate${C}\n  ${Q}lines_per_second${Q}   : $line_rate\";\n        if ($opt_report_file) {\n            if ($opt_sum_reports) {\n                if ($by_file) {\n                    $header .= \"$C\\n  ${Q}report_file${Q}        : ${Q}$opt_report_file.file${Q}\"\n                } else {\n                    $header .= \"$C\\n  ${Q}report_file${Q}        : ${Q}$opt_report_file.lang${Q}\"\n                }\n            } else {\n                $header .= \"$C\\n  ${Q}report_file${Q}        : ${Q}$opt_report_file${Q}\";\n            }\n        }\n        $header .= \"${close_B}${C}\";\n    }\n    print \"<- xml_yaml_or_json_header\\n\" if $opt_v > 2;\n    return $header;\n} # 1}}}\nsub diff_yaml_report {                       # {{{1\n    # returns an array of lines containing the results\n    my ($version    , # in\n        $elapsed_sec, # in\n        $report_type, # in  \"by language\" | \"by report file\" | \"by file\"\n        $rhhh_count , # in  count{TYPE}{nFiles|code|blank|comment}{a|m|r|s}\n        $rh_scale   , # in\n       ) = @_;\n    print \"-> diff_yaml_report\\n\" if $opt_v > 2;\n    $elapsed_sec = 0.5 unless $elapsed_sec;\n    my @results       = ();\n    my %sum           = ();\n    my ($sum_lines, $sum_files, $BY_FILE, $BY_LANGUAGE) =\n        diff_header_sum($report_type, $rhhh_count, \\%sum);\n\n    if (!$ALREADY_SHOWED_HEADER) {\n        push @results,\n              xml_yaml_or_json_header($URL, $version, $elapsed_sec,\n                                 $sum_files, $sum_lines, $BY_FILE);\n        $ALREADY_SHOWED_HEADER = 1;\n    }\n    foreach my $S (qw(added same modified removed)) {\n        push @results, \"$S :\";\n        foreach my $F_or_L (keys %{$rhhh_count}) {\n            push @results, \"  $F_or_L :\";\n            foreach my $k (keys %{$rhhh_count->{$F_or_L}}) {\n                next if $k eq \"lang\"; # present only in those cases\n                                      # where code exists for action $S\n                $rhhh_count->{$F_or_L}{$k}{$S} = 0 unless\n                    defined $rhhh_count->{$F_or_L}{$k}{$S};\n                push @results,\n                    \"    $k : $rhhh_count->{$F_or_L}{$k}{$S}\";\n            }\n        }\n    }\n    print \"<- diff_yaml_report\\n\" if $opt_v > 2;\n    return @results;\n} # 1}}}\nsub diff_json_report {                       # {{{1\n    # returns an array of lines containing the results\n    my ($version    , # in\n        $elapsed_sec, # in\n        $report_type, # in  \"by language\" | \"by report file\" | \"by file\"\n        $rhhh_count , # in  count{TYPE}{nFiles|code|blank|comment}{a|m|r|s}\n        $rh_scale   , # in\n       ) = @_;\n    print \"-> diff_json_report\\n\" if $opt_v > 2;\n    $elapsed_sec = 0.5 unless $elapsed_sec;\n    my @results       = ();\n    my %sum           = ();\n    my ($sum_lines, $sum_files, $BY_FILE, $BY_LANGUAGE) =\n        diff_header_sum($report_type, $rhhh_count, \\%sum);\n\n    if (!$ALREADY_SHOWED_HEADER) {\n        push @results,\n              xml_yaml_or_json_header($URL, $version, $elapsed_sec,\n                                 $sum_files, $sum_lines, $BY_FILE);\n        $ALREADY_SHOWED_HEADER = 1;\n    }\n    foreach my $S (qw(added same modified removed)) {\n        push @results, \" \\\"$S\\\" : {\";\n        foreach my $F_or_L (keys %{$rhhh_count}) {\n            push @results, \"  \\\"$F_or_L\\\" : {\";\n            foreach my $k (keys %{$rhhh_count->{$F_or_L}}) {\n                next if $k eq \"lang\"; # present only in those cases\n                                      # where code exists for action $S\n                $rhhh_count->{$F_or_L}{$k}{$S} = 0 unless\n                    defined $rhhh_count->{$F_or_L}{$k}{$S};\n                push @results,\n                    \"    \\\"$k\\\" : \\\"$rhhh_count->{$F_or_L}{$k}{$S}\\\",\";\n            }\n            $results[-1] =~ s/,\\s*$//;\n            push @results, \"  },\"\n        }\n        $results[-1] =~ s/,\\s*$//;\n        push @results, \"  },\"\n    }\n    $results[-1] =~ s/,\\s*$//;\n    push @results, \"}\";\n    print \"<- diff_json_report\\n\" if $opt_v > 2;\n    return @results;\n} # 1}}}\nsub diff_header_sum {                        # {{{1\n    my ($report_type, # in  \"by language\" | \"by report file\" | \"by file\"\n        $rhhh_count , # in  count{TYPE}{nFiles|code|blank|comment}{a|m|r|s}\n        $rhh_sum    , # out sum{nFiles|blank|comment|code}{same|modified|added|removed}\n       ) = @_;\n\n    my $sum_files = 0;\n    my $sum_lines = 0;\n    foreach my $language (keys %{$rhhh_count}) {\n        foreach my $V (qw(nFiles blank comment code)) {\n            foreach my $S (qw(added same modified removed)) {\n                $rhhh_count->{$language}{$V}{$S} = 0 unless\n                    defined $rhhh_count->{$language}{$V}{$S};\n                $rhh_sum->{$V}{$S}  += $rhhh_count->{$language}{$V}{$S};\n                if ($V eq \"nFiles\") {\n                    $sum_files += $rhhh_count->{$language}{$V}{$S};\n                } else {\n                    $sum_lines += $rhhh_count->{$language}{$V}{$S};\n                }\n            }\n        }\n    }\n\n    my $BY_LANGUAGE = 0;\n    my $BY_FILE     = 0;\n    if      ($report_type eq \"by language\") {\n        $BY_LANGUAGE  = 1;\n    } elsif ($report_type eq \"by file\")     {\n        $BY_FILE      = 1;\n    }\n    return $sum_lines, $sum_files, $BY_FILE, $BY_LANGUAGE;\n} # 1}}}\nsub diff_xml_report {                        # {{{1\n    # returns an array of lines containing the results\n    my ($version    , # in\n        $elapsed_sec, # in\n        $report_type, # in  \"by language\" | \"by report file\" | \"by file\"\n        $rhhh_count , # in  count{TYPE}{nFiles|code|blank|comment}{a|m|r|s}\n        $rh_scale   , # in\n       ) = @_;\n    print \"-> diff_xml_report\\n\" if $opt_v > 2;\n    my ($Q, $open_B, $close_B, $start, $C) = yaml_to_json_separators();\n\n#print \"diff_report: \", Dumper($rhhh_count), \"\\n\";\n    $elapsed_sec = 0.5 unless $elapsed_sec;\n    my @results       = ();\n    my %sum           = ();\n    my $languages     = ();\n\n    my ($sum_lines, $sum_files, $BY_FILE, $BY_LANGUAGE) =\n        diff_header_sum($report_type, $rhhh_count, \\%sum);\n\n    my $data_line   = \"\";\n\n    if (!$ALREADY_SHOWED_HEADER) {\n        push @results,\n              xml_yaml_or_json_header($URL, $version, $elapsed_sec,\n                                 $sum_files, $sum_lines, $BY_FILE);\n        $ALREADY_SHOWED_HEADER = 1;\n    }\n\n    foreach my $S (qw(same modified added removed)) {\n        push @results, \"  <$S>\";\n        foreach my $lang_or_file (sort {\n                                     $rhhh_count->{$b}{'code'} <=>\n                                     $rhhh_count->{$a}{'code'}\n                                   }\n                              keys %{$rhhh_count}) {\n            my $L = \"\";\n\n            if ($BY_FILE) {\n                $L .= sprintf \"    <file name=\\\"%s\\\" files_count=\\\"1\\\" \",\n                    xml_metachars(\n                        rm_leading_tempdir($lang_or_file, \\%TEMP_DIR));\n            } else {\n                $L .= sprintf \"    <language name=\\\"%s\\\" files_count=\\\"%d\\\" \",\n                        $lang_or_file ,\n                        $rhhh_count->{$lang_or_file}{'nFiles'}{$S};\n            }\n            if ($opt_by_percent) {\n              my $DEN = compute_denominator($opt_by_percent            ,\n                            $rhhh_count->{$lang_or_file}{'code'}{$S}   ,\n                            $rhhh_count->{$lang_or_file}{'comment'}{$S},\n                            $rhhh_count->{$lang_or_file}{'blank'}{$S}  );\n              foreach my $T (qw(blank comment)) {\n                  if ($rhhh_count->{$lang_or_file}{'code'}{$S} > 0) {\n                    $L .= sprintf \"%s=\\\"%.2f\\\" \",\n                            $T, $rhhh_count->{$lang_or_file}{$T}{$S} / $DEN * 100;\n                  } else {\n                    $L .= sprintf \"%s=\\\"0.0\\\" \", $T;\n                  }\n              }\n              foreach my $T (qw(code)) {\n                  $L .= sprintf \"%s=\\\"%d\\\" \",\n                          $T, $rhhh_count->{$lang_or_file}{$T}{$S};\n              }\n            } else {\n              foreach my $T (qw(blank comment code)) {\n                  $L .= sprintf \"%s=\\\"%d\\\" \",\n                          $T, $rhhh_count->{$lang_or_file}{$T}{$S};\n              }\n            }\n            push @results, $L . \"/>\";\n        }\n\n\n        my $L = sprintf \"    <total sum_files=\\\"%d\\\" \", $sum{'nFiles'}{$S};\n        if ($opt_by_percent) {\n          my $DEN = compute_denominator($opt_by_percent,\n                        $sum{'code'}{$S}   ,\n                        $sum{'comment'}{$S},\n                        $sum{'blank'}{$S}  );\n          foreach my $V (qw(blank comment)) {\n              if ($sum{'code'}{$S} > 0) {\n                  $L .= sprintf \"%s=\\\"%.2f\\\" \", $V, $sum{$V}{$S} / $DEN * 100;\n              } else {\n                  $L .= sprintf \"%s=\\\"0.0\\\" \", $V;\n              }\n          }\n          foreach my $V (qw(code)) {\n              $L .= sprintf \"%s=\\\"%d\\\" \", $V, $sum{$V}{$S};\n          }\n        } else {\n          foreach my $V (qw(blank comment code)) {\n              $L .= sprintf \"%s=\\\"%d\\\" \", $V, $sum{$V}{$S};\n          }\n        }\n        push @results, $L . \"/>\";\n        push @results, \"  </$S>\";\n    }\n\n    push @results, \"</diff_results>\";\n    write_xsl_file() if $opt_xsl and $opt_xsl eq $CLOC_XSL;\n    print \"<- diff_xml_report\\n\" if $opt_v > 2;\n    return @results;\n} # 1}}}\nsub diff_csv_report {                        # {{{1\n    # returns an array of lines containing the results\n    my ($version    , # in\n        $elapsed_sec, # in\n        $report_type, # in  \"by language\" | \"by report file\" | \"by file\"\n        $rhhh_count , # in  count{TYPE}{nFiles|code|blank|comment}{a|m|r|s}\n        $rh_scale   , # in  unused\n       ) = @_;\n    print \"-> diff_csv_report\\n\" if $opt_v > 2;\n\n#use Data::Dumper;\n#print \"diff_csv_report: \", Dumper($rhhh_count), \"\\n\";\n#die;\n    my @results       = ();\n    my $languages     = ();\n\n    my $data_line   = \"\";\n    my $BY_LANGUAGE = 0;\n    my $BY_FILE     = 0;\n    if      ($report_type eq \"by language\") {\n        $BY_LANGUAGE  = 1;\n    } elsif ($report_type eq \"by file\")     {\n        $BY_FILE      = 1;\n    }\n    my $DELIM = \",\";\n       $DELIM = $opt_csv_delimiter if defined $opt_csv_delimiter;\n\n    $elapsed_sec = 0.5 unless $elapsed_sec;\n\n    my $line = \"Language${DELIM} \";\n       $line = \"File${DELIM} \" if $BY_FILE;\n    foreach my $item (qw(files blank comment code)) {\n        next if $BY_FILE and $item eq 'files';\n        foreach my $symbol ( '==', '!=', '+', '-', ) {\n            $line .= \"$symbol $item${DELIM} \";\n        }\n    }\n    $line .= \"\\\"$URL v $version T=$elapsed_sec s\\\"\";\n    push @results, $line;\n\n    foreach my $lang_or_file (keys %{$rhhh_count}) {\n        $rhhh_count->{$lang_or_file}{'code'}{'added'} = 0 unless\n            defined $rhhh_count->{$lang_or_file}{'code'};\n    }\n    foreach my $lang_or_file (sort {\n                                 $rhhh_count->{$b}{'code'} <=>\n                                 $rhhh_count->{$a}{'code'}\n                               }\n                          keys %{$rhhh_count}) {\n        if ($BY_FILE) {\n            $line = rm_leading_tempdir($lang_or_file, \\%TEMP_DIR) . \"$DELIM \";\n        } else {\n            $line = $lang_or_file . \"${DELIM} \";\n        }\n        if ($opt_by_percent) {\n          foreach my $item (qw(nFiles)) {\n              next if $BY_FILE and $item eq 'nFiles';\n              foreach my $symbol (qw(same modified added removed)) {\n                  if (defined $rhhh_count->{$lang_or_file}{$item}{$symbol}) {\n                      $line .= \"$rhhh_count->{$lang_or_file}{$item}{$symbol}${DELIM} \";\n                  } else {\n                      $line .= \"0${DELIM} \";\n                  }\n              }\n          }\n          foreach my $item (qw(blank comment)) {\n              foreach my $symbol (qw(same modified added removed)) {\n                  if (defined $rhhh_count->{$lang_or_file}{$item}{$symbol} and\n                      defined $rhhh_count->{$lang_or_file}{'code'}{$symbol} and\n                      $rhhh_count->{$lang_or_file}{'code'}{$symbol} > 0) {\n                      $line .= sprintf(\"%.2f\", $rhhh_count->{$lang_or_file}{$item}{$symbol} / $rhhh_count->{$lang_or_file}{'code'}{$symbol} * 100).${DELIM};\n                  } else {\n                      $line .= \"0.00${DELIM} \";\n                  }\n              }\n          }\n          foreach my $item (qw(code)) {\n              foreach my $symbol (qw(same modified added removed)) {\n                  if (defined $rhhh_count->{$lang_or_file}{$item}{$symbol}) {\n                      $line .= \"$rhhh_count->{$lang_or_file}{$item}{$symbol}${DELIM} \";\n                  } else {\n                      $line .= \"0${DELIM} \";\n                  }\n              }\n          }\n        } else {\n          foreach my $item (qw(nFiles blank comment code)) {\n              next if $BY_FILE and $item eq 'nFiles';\n              foreach my $symbol (qw(same modified added removed)) {\n                  if (defined $rhhh_count->{$lang_or_file}{$item}{$symbol}) {\n                      $line .= \"$rhhh_count->{$lang_or_file}{$item}{$symbol}${DELIM} \";\n                  } else {\n                      $line .= \"0${DELIM} \";\n                  }\n              }\n          }\n        }\n        push @results, $line;\n    }\n\n    print \"<- diff_csv_report\\n\" if $opt_v > 2;\n    return @results;\n} # 1}}}\nsub rm_leading_tempdir {                     # {{{1\n    my ($in_file, $rh_temp_dirs, ) = @_;\n    my $clean_filename = $in_file;\n    foreach my $temp_d (keys %{$rh_temp_dirs}) {\n        if ($ON_WINDOWS) {\n        # \\ -> / necessary to allow the next if test's\n        # m{} to work in the presence of spaces in file names\n            $temp_d         =~ s{\\\\}{/}g;\n            $clean_filename =~ s{\\\\}{/}g;\n        }\n        if ($clean_filename =~ m{^$temp_d/}) {\n            $clean_filename =~ s{^$temp_d/}{};\n            last;\n        }\n    }\n    $clean_filename =~ s{/}{\\\\}g if $ON_WINDOWS; # then go back from / to \\\n    return $clean_filename;\n} # 1}}}\nsub generate_sql    {                        # {{{1\n    my ($elapsed_sec, # in\n        $rhh_count  , # in  count{TYPE}{lang|code|blank|comment|scaled}\n        $rh_scale   , # in\n       ) = @_;\n    print \"-> generate_sql\\n\" if $opt_v > 2;\n\n#print \"generate_sql A [$opt_sql_project]\\n\";\n    $opt_sql_project = cwd() unless defined $opt_sql_project;\n    $opt_sql_project = '' unless defined $opt_sql_project; # have seen cwd() fail\n#print \"generate_sql B [$opt_sql_project]\\n\";\n    $opt_sql_project =~ s{/}{\\\\}g if $ON_WINDOWS;\n#print \"generate_sql C [$opt_sql_project]\\n\";\n\n    my $schema = undef;\n    if ($opt_sql_style eq \"oracle\") {\n        $schema = \"\nCREATE TABLE metadata\n(\n  timestamp   TIMESTAMP,\n  project     VARCHAR2(500 CHAR),\n  elapsed_s   NUMBER(10, 6)\n)\n/\n\nCREATE TABLE t\n(\n  project        VARCHAR2(500 CHAR),\n  language       VARCHAR2(500 CHAR),\n  file_fullname  VARCHAR2(500 CHAR),\n  file_dirname   VARCHAR2(500 CHAR),\n  file_basename  VARCHAR2(500 CHAR),\n  nblank         INTEGER,\n  ncomment       INTEGER,\n  ncode          INTEGER,\n  nscaled        NUMBER(10, 6)\n)\n/\n\n\";\n    } else {\n        $schema = \"\ncreate table metadata (          -- $URL v $VERSION\n                timestamp varchar(500),\n                Project   varchar(500),\n                elapsed_s real);\ncreate table t        (\n                Project       varchar(500)   ,\n                Language      varchar(500)   ,\n                File          varchar(500)   ,\n                File_dirname  varchar(500)   ,\n                File_basename varchar(500)   ,\n                nBlank        integer        ,\n                nComment      integer        ,\n                nCode         integer        ,\n                nScaled       real           );\n\";\n    }\n    $opt_sql = \"-\" if $opt_sql eq \"1\";\n\n    my $open_mode = \">\";\n       $open_mode = \">>\" if $opt_sql_append;\n\n    my $fh = new IO::File; # $opt_sql, \"w\";\n    if (!$fh->open(\"${open_mode}${opt_sql}\")) {\n        die \"Unable to write to $opt_sql  $!\\n\";\n    }\n    print $fh $schema unless defined $opt_sql_append;\n\n    if ($opt_sql_style eq \"oracle\") {\n        printf $fh \"insert into metadata values(TO_TIMESTAMP('%s','yyyy-mm-dd hh24:mi:ss'), '%s', %f);\\n\",\n                    strftime(\"%Y-%m-%d %H:%M:%S\", localtime(time())),\n                    $opt_sql_project, $elapsed_sec;\n    } else {\n        print $fh \"begin transaction;\\n\";\n        printf $fh \"insert into metadata values('%s', '%s', %f);\\n\",\n                    strftime(\"%Y-%m-%d %H:%M:%S\", localtime(time())),\n                    $opt_sql_project, $elapsed_sec;\n    }\n\n    my $nIns = 0;\n    foreach my $file (keys %{$rhh_count}) {\n        my $language = $rhh_count->{$file}{'lang'};\n        my $clean_filename = $file;\n        # If necessary (that is, if the input contained an\n        # archive file [.tar.gz, etc]), strip the temporary\n        # directory name which was used to expand the archive\n        # from the file name.\n\n        $clean_filename = rm_leading_tempdir($clean_filename, \\%TEMP_DIR);\n        $clean_filename =~ s/\\'/''/g;  # double embedded single quotes\n                                       # to escape them\n\n        printf $fh \"insert into t values('%s', '%s', '%s', '%s', '%s', \" .\n                   \"%d, %d, %d, %f);\\n\",\n                    $opt_sql_project           ,\n                    $language                  ,\n                    $clean_filename            ,\n                    dirname( $clean_filename)  ,\n                    basename($clean_filename)  ,\n                    $rhh_count->{$file}{'blank'},\n                    $rhh_count->{$file}{'comment'},\n                    $rhh_count->{$file}{'code'}   ,\n                    $rhh_count->{$file}{'code'}*$rh_scale->{$language};\n\n        ++$nIns;\n        if (!($nIns % 10_000) and ($opt_sql_style ne \"oracle\")) {\n            print $fh \"commit;\\n\";\n            print $fh \"begin transaction;\\n\";\n        }\n    }\n    if ($opt_sql_style ne \"oracle\") {\n        print $fh \"commit;\\n\";\n    }\n\n    $fh->close unless $opt_sql eq \"-\"; # don't try to close STDOUT\n    print \"<- generate_sql\\n\" if $opt_v > 2;\n\n    # sample query:\n    #\n    #   select project, language,\n    #          sum(nCode)     as Code,\n    #          sum(nComment)  as Comments,\n    #          sum(nBlank)    as Blank,\n    #          sum(nCode)+sum(nComment)+sum(nBlank) as All_Lines,\n    #          100.0*sum(nComment)/(sum(nCode)+sum(nComment)) as Comment_Pct\n    #          from t group by Project, Language order by Project, Code desc;\n    #\n} # 1}}}\nsub output_header   {                        # {{{1\n    my ($header_line,\n        $hyphen_line,\n        $BY_FILE    ,)    = @_;\n    print \"-> output_header\\n\" if $opt_v > 2;\n    my @R = ();\n    if      ($opt_xml) {\n        if (!$ALREADY_SHOWED_XML_SECTION) {\n            push @R, \"<?xml version=\\\"1.0\\\"?>\";\n            push @R, '<?xml-stylesheet type=\"text/xsl\" href=\"' .\n                            $opt_xsl . '\"?>' if $opt_xsl;\n            push @R, \"<results>\";\n            push @R, \"<header>$header_line</header>\";\n            $ALREADY_SHOWED_XML_SECTION = 1;\n        }\n        if ($BY_FILE) {\n            push @R, \"<files>\";\n        } else {\n            push @R, \"<languages>\";\n        }\n    } elsif ($opt_yaml) {\n        push @R, \"---\\n# $header_line\";\n    } elsif ($opt_csv or $opt_md) {\n        # append the header to the end of the column headers\n        # to keep the output a bit cleaner from a spreadsheet\n        # perspective\n    } else {\n        if ($ALREADY_SHOWED_HEADER) {\n            push @R, \"\";\n        } else {\n            push @R, $header_line;\n            $ALREADY_SHOWED_HEADER = 1;\n        }\n        push @R, $hyphen_line;\n    }\n    print \"<- output_header\\n\" if $opt_v > 2;\n    return @R;\n} # 1}}}\nsub generate_report {                        # {{{1\n    # returns an array of lines containing the results\n    my ($version    , # in\n        $elapsed_sec, # in\n        $report_type, # in  \"by language\" | \"by report file\" | \"by file\"\n        $rhh_count  , # in  count{TYPE}{nFiles|code|blank|comment|scaled}\n        $rh_scale   , # in\n       ) = @_;\n\n    print \"-> generate_report\\n\" if $opt_v > 2;\n    my $DELIM = \",\";\n       $DELIM = $opt_csv_delimiter if defined $opt_csv_delimiter;\n       $DELIM = \"|\" if defined $opt_md;\n\n    my @results       = ();\n\n    my $languages     = ();\n\n    my $sum_files     = 0;\n    my $sum_code      = 0;\n    my $sum_blank     = 0;\n    my $sum_comment   = 0;\n    my $max_len       = 0;\n    foreach my $language (keys %{$rhh_count}) {\n        $sum_files   += $rhh_count->{$language}{'nFiles'} ;\n        $sum_blank   += $rhh_count->{$language}{'blank'}  ;\n        $sum_comment += $rhh_count->{$language}{'comment'};\n        $sum_code    += $rhh_count->{$language}{'code'}   ;\n        $max_len      = length($language) if length($language) > $max_len;\n    }\n    my $column_1_offset = 0;\n       $column_1_offset = $max_len - 17 if $max_len > 17;\n    my $sum_lines = $sum_blank + $sum_comment + $sum_code;\n    $elapsed_sec = 0.5 unless $elapsed_sec;\n\n    my $spacing_0 = 23;\n    my $spacing_1 = 13;\n    my $spacing_2 =  9;\n    my $spacing_3 = 17;\n    if (!$opt_3) {\n        $spacing_1 = 19;\n        $spacing_2 = 14;\n        $spacing_3 = 28;\n    }\n    $spacing_0 += $column_1_offset;\n    $spacing_1 += $column_1_offset;\n    $spacing_3 += $column_1_offset;\n    my %Format = (\n        '1' => { 'xml' => 'name=\"%s\" ',\n                 'txt' => \"\\%-${spacing_0}s \",\n               },\n        '2' => { 'xml' => 'name=\"%s\" ',\n                 'txt' => \"\\%-${spacing_3}s \",\n               },\n        '3' => { 'xml' => 'files_count=\"%d\" ',\n                 'txt' => '%5d ',\n               },\n        '4' => { 'xml' => 'blank=\"%d\" comment=\"%d\" code=\"%d\" ',\n                 'txt' => \"\\%${spacing_2}d \\%${spacing_2}d \\%${spacing_2}d\",\n               },\n        '5' => { 'xml' => 'blank=\"%3.2f\" comment=\"%3.2f\" code=\"%d\" ',\n                 'txt' => \"\\%14.2f \\%14.2f \\%${spacing_2}d\",\n               },\n        '6' => { 'xml' => 'factor=\"%.2f\" scaled=\"%.2f\" ',\n                 'txt' => ' x %6.2f = %14.2f',\n               },\n    );\n    my $Style = \"txt\";\n       $Style = \"xml\" if $opt_xml ;\n       $Style = \"xml\" if $opt_yaml;  # not a typo; just set to anything but txt\n       $Style = \"xml\" if $opt_json;  # not a typo; just set to anything but txt\n       $Style = \"xml\" if $opt_csv ;  # not a typo; just set to anything but txt\n\n    my $hyphen_line = sprintf \"%s\", '-' x (79 + $column_1_offset);\n       $hyphen_line = sprintf \"%s\", '-' x (68 + $column_1_offset)\n            if (!$opt_sum_reports) and (!$opt_3) and (68 + $column_1_offset) > 79;\n    my $data_line  = \"\";\n    my $first_column;\n    my $BY_LANGUAGE = 0;\n    my $BY_FILE     = 0;\n    if      ($report_type eq \"by language\") {\n        $first_column = \"Language\";\n        $BY_LANGUAGE  = 1;\n    } elsif ($report_type eq \"by file\")     {\n        $first_column = \"File\";\n        $BY_FILE      = 1;\n    } elsif ($report_type eq \"by report file\")     {\n        $first_column = \"File\";\n    } else {\n        $first_column = \"Report File\";\n    }\n\n    my $header_line  = sprintf \"%s v %s\", $URL, $version;\n       $header_line .= sprintf(\"  T=%.2f s (%.1f files/s, %.1f lines/s)\",\n                        $elapsed_sec           ,\n                        $sum_files/$elapsed_sec,\n                        $sum_lines/$elapsed_sec) unless $opt_sum_reports;\n    if ($opt_xml or $opt_yaml or $opt_json) {\n        if (!$ALREADY_SHOWED_HEADER) {\n            push @results, xml_yaml_or_json_header($URL, $version, $elapsed_sec,\n                                                   $sum_files, $sum_lines, $BY_FILE);\n            $ALREADY_SHOWED_HEADER = 1 unless $opt_sum_reports;\n            # --sum-reports yields two xml or yaml files, one by\n            # language and one by report file, each of which needs a header\n        }\n        if ($opt_xml) {\n            if ($BY_FILE or ($report_type eq \"by report file\")) {\n                push @results, \"<files>\";\n            } else {\n                push @results, \"<languages>\";\n            }\n        }\n    } else {\n        push @results, output_header($header_line, $hyphen_line, $BY_FILE);\n    }\n\n    if ($Style eq \"txt\") {\n        # column headers\n        if (!$opt_3 and $BY_FILE) {\n            my $spacing_n = $spacing_1 - 11;\n            $data_line  = sprintf \"%-${spacing_n}s \", $first_column;\n        } else {\n            $data_line  = sprintf \"%-${spacing_1}s \", $first_column;\n        }\n        if ($BY_FILE) {\n            $data_line .= sprintf \"%${spacing_2}s \"  , \" \"    ;\n        } else {\n            $data_line .= sprintf \"%${spacing_2}s \"  , \"files\";\n        }\n        my $PCT_symbol = \"\";\n           $PCT_symbol = \" \\%\" if $opt_by_percent;\n        $data_line .= sprintf \"%${spacing_2}s %${spacing_2}s %${spacing_2}s\",\n            \"blank${PCT_symbol}\"   ,\n            \"comment${PCT_symbol}\" ,\n            \"code\";\n        $data_line .= sprintf \" %8s   %14s\",\n            \"scale\"         ,\n            \"3rd gen. equiv\"\n              if $opt_3;\n        if ($opt_md) {\n            my @col_header  = ();\n            if ($data_line =~ m{\\s%}) {\n                $data_line =~ s{\\s%}{_%}g;\n                foreach my $w ( split(' ', $data_line) ) {\n                    $w =~ s{_%}{ %};\n                    push @col_header, $w;\n                }\n            } else {\n                push @col_header, split(' ', $data_line);\n            }\n            my @col_hyphens    = ( '-------:') x scalar(@col_header);\n               $col_hyphens[0] =   ':-------'; # first column left justified\n            push @results, join(\"|\", @col_header );\n            push @results, join(\"|\", @col_hyphens);\n        } else {\n            push @results, $data_line;\n            push @results, $hyphen_line;\n        }\n    }\n\n    if ($opt_csv)  {\n        my $header2;\n        if ($BY_FILE) {\n            $header2 = \"language${DELIM}filename\";\n        } else {\n            $header2 = \"files${DELIM}language\";\n        }\n        $header2 .= \"${DELIM}blank${DELIM}comment${DELIM}code\";\n        $header2 .= \"${DELIM}scale${DELIM}3rd gen. equiv\" if $opt_3;\n        $header2 .= ${DELIM} . '\"' . $header_line . '\"';\n        push @results, $header2;\n    }\n\n    my $sum_scaled = 0;\n####foreach my $lang_or_file (keys %{$rhh_count}) {\n####    $rhh_count->{$lang_or_file}{'code'} = 0 unless\n####        defined $rhh_count->{$lang_or_file}{'code'};\n####}\n    foreach my $lang_or_file (sort {\n                                 $rhh_count->{$b}{'code'} <=>\n                                 $rhh_count->{$a}{'code'}\n                               }\n                          keys %{$rhh_count}) {\n        next if $lang_or_file eq \"by report file\";\n        my ($factor, $scaled);\n        if ($BY_LANGUAGE or $BY_FILE) {\n            $factor = 1;\n            if ($BY_LANGUAGE) {\n                if (defined $rh_scale->{$lang_or_file}) {\n                    $factor = $rh_scale->{$lang_or_file};\n                } else {\n                    warn \"No scale factor for $lang_or_file; using 1.00\";\n                }\n            } else { # by individual code file\n                if ($report_type ne \"by report file\") {\n                    next unless defined $rhh_count->{$lang_or_file}{'lang'};\n                    next unless defined $rh_scale->{$rhh_count->{$lang_or_file}{'lang'}};\n                    $factor = $rh_scale->{$rhh_count->{$lang_or_file}{'lang'}};\n                }\n            }\n            $scaled = $factor*$rhh_count->{$lang_or_file}{'code'};\n        } else {\n            if (!defined $rhh_count->{$lang_or_file}{'scaled'}) {\n                $opt_3 = 0;\n                # If we're summing together files previously generated\n                # with --no3 then rhh_count->{$lang_or_file}{'scaled'}\n                # this variable will be undefined.  That should only\n                # happen when summing together by file however.\n            } elsif ($BY_LANGUAGE) {\n                warn \"Missing scaled language info for $lang_or_file\\n\";\n            }\n            if ($opt_3) {\n                $scaled =         $rhh_count->{$lang_or_file}{'scaled'};\n                $factor = $scaled/$rhh_count->{$lang_or_file}{'code'};\n            }\n        }\n\n        if ($BY_FILE) {\n            my $clean_filename = rm_leading_tempdir($lang_or_file, \\%TEMP_DIR);\n               $clean_filename = xml_metachars($clean_filename) if $opt_xml;\n            $data_line  = sprintf $Format{'1'}{$Style}, $clean_filename;\n        } else {\n            $data_line  = sprintf $Format{'2'}{$Style}, $lang_or_file;\n        }\n        $data_line .= sprintf $Format{3}{$Style}  ,\n                        $rhh_count->{$lang_or_file}{'nFiles'} unless $BY_FILE;\n        if ($opt_by_percent) {\n          my $DEN = compute_denominator($opt_by_percent       ,\n                        $rhh_count->{$lang_or_file}{'code'}   ,\n                        $rhh_count->{$lang_or_file}{'comment'},\n                        $rhh_count->{$lang_or_file}{'blank'}  );\n          $data_line .= sprintf $Format{5}{$Style}  ,\n              $rhh_count->{$lang_or_file}{'blank'}   / $DEN * 100,\n              $rhh_count->{$lang_or_file}{'comment'} / $DEN * 100,\n              $rhh_count->{$lang_or_file}{'code'}   ;\n        } else {\n          $data_line .= sprintf $Format{4}{$Style}  ,\n              $rhh_count->{$lang_or_file}{'blank'}  ,\n              $rhh_count->{$lang_or_file}{'comment'},\n              $rhh_count->{$lang_or_file}{'code'}   ;\n        }\n        $data_line .= sprintf $Format{6}{$Style}  ,\n            $factor                               ,\n            $scaled if $opt_3;\n        $sum_scaled  += $scaled if $opt_3;\n\n        if ($opt_xml) {\n            if (defined $rhh_count->{$lang_or_file}{'lang'}) {\n                my $lang = $rhh_count->{$lang_or_file}{'lang'};\n                if (!defined $languages->{$lang}) {\n                    $languages->{$lang} = $lang;\n                }\n                $data_line.=' language=\"' . $lang . '\" ';\n            }\n            if ($BY_FILE or ($report_type eq \"by report file\")) {\n                push @results, \"  <file \" . $data_line . \"/>\";\n            } else {\n                push @results, \"  <language \" . $data_line . \"/>\";\n            }\n        } elsif ($opt_yaml or $opt_json) {\n            my ($Q, $open_B, $close_B, $start, $C) = yaml_to_json_separators();\n            push @results,\"${Q}$lang_or_file${Q} :$open_B\";\n            push @results,\"  ${Q}nFiles${Q}: \" . $rhh_count->{$lang_or_file}{'nFiles'} . $C\n                unless $BY_FILE;\n            if ($opt_by_percent) {\n              my $DEN = compute_denominator($opt_by_percent       ,\n                            $rhh_count->{$lang_or_file}{'code'}   ,\n                            $rhh_count->{$lang_or_file}{'comment'},\n                            $rhh_count->{$lang_or_file}{'blank'}  );\n              push @results,\"  ${Q}blank_pct${Q}: \"   .\n                sprintf(\"%3.2f\", $rhh_count->{$lang_or_file}{'blank'} / $DEN * 100) . $C;\n              push @results,\"  ${Q}comment_pct${Q}: \" .\n                sprintf(\"%3.2f\", $rhh_count->{$lang_or_file}{'comment'} / $DEN * 100) . $C;\n              push @results,\"  ${Q}code${Q}: \"    . $rhh_count->{$lang_or_file}{'code'}  . $C;\n            } else {\n              push @results,\"  ${Q}blank${Q}: \"   . $rhh_count->{$lang_or_file}{'blank'}   . $C;\n              push @results,\"  ${Q}comment${Q}: \" . $rhh_count->{$lang_or_file}{'comment'} . $C;\n              push @results,\"  ${Q}code${Q}: \"    . $rhh_count->{$lang_or_file}{'code'}    . $C;\n            }\n            push @results,\"  ${Q}language${Q}: \"  . $Q . $rhh_count->{$lang_or_file}{'lang'} . $Q . $C\n                if $BY_FILE;\n            if ($opt_3) {\n                push @results, \"  ${Q}scaled${Q}: \" . $scaled . $C;\n                push @results, \"  ${Q}factor${Q}: \" . $factor . $C;\n            }\n            if ($opt_json) { # replace the trailing comma with }, on the last line\n                $results[-1] =~ s/,\\s*$/},/;\n            }\n        } elsif ($opt_csv or $opt_md) {\n            my $extra_3 = \"\";\n               $extra_3 = \"${DELIM}$factor${DELIM}$scaled\" if $opt_3;\n            my $first_column = undef;\n            my $clean_name   = $lang_or_file;\n            my $str;\n            if ($opt_csv) {\n                if ($BY_FILE) {\n                    $first_column = $rhh_count->{$lang_or_file}{'lang'};\n                    $clean_name   = rm_leading_tempdir($lang_or_file, \\%TEMP_DIR);\n                } else {\n                    $first_column = $rhh_count->{$lang_or_file}{'nFiles'};\n                }\n                $str = $first_column   . ${DELIM} .\n                       $clean_name     . ${DELIM};\n            } else {\n                if ($BY_FILE) {\n                    $first_column = $rhh_count->{$lang_or_file}{'lang'};\n                    $clean_name   = rm_leading_tempdir($lang_or_file, \\%TEMP_DIR);\n                    $str = $clean_name . ${DELIM};\n                } else {\n                    $first_column = $rhh_count->{$lang_or_file}{'nFiles'};\n                    $str = $clean_name     . ${DELIM} .\n                           $first_column   . ${DELIM};\n                }\n            }\n            if ($opt_by_percent) {\n              my $DEN = compute_denominator($opt_by_percent               ,\n                            $rhh_count->{$lang_or_file}{'code'}   ,\n                            $rhh_count->{$lang_or_file}{'comment'},\n                            $rhh_count->{$lang_or_file}{'blank'}  );\n              $str .= sprintf(\"%3.2f\", $rhh_count->{$lang_or_file}{'blank'}   / $DEN * 100) . ${DELIM} .\n                      sprintf(\"%3.2f\", $rhh_count->{$lang_or_file}{'comment'} / $DEN * 100) . ${DELIM} .\n                      $rhh_count->{$lang_or_file}{'code'};\n            } else {\n              $str .= $rhh_count->{$lang_or_file}{'blank'}  . ${DELIM} .\n                      $rhh_count->{$lang_or_file}{'comment'}. ${DELIM} .\n                      $rhh_count->{$lang_or_file}{'code'};\n            }\n            $str .= $extra_3;\n            push @results, $str;\n\n        } else {\n            push @results, $data_line;\n        }\n    }\n\n    my $avg_scale = 1;  # weighted average of scale factors\n       $avg_scale = sprintf(\"%.2f\", $sum_scaled / $sum_code)\n            if $sum_code and $opt_3;\n\n    if ($opt_xml) {\n        $data_line = \"\";\n        if (!$BY_FILE) {\n            $data_line .= sprintf \"sum_files=\\\"%d\\\" \", $sum_files;\n        }\n        if ($opt_by_percent) {\n          my $DEN = compute_denominator($opt_by_percent    ,\n                        $sum_code, $sum_comment, $sum_blank);\n          $data_line .= sprintf $Format{'5'}{$Style},\n              $sum_blank   / $DEN * 100,\n              $sum_comment / $DEN * 100,\n              $sum_code    ;\n        } else {\n          $data_line .= sprintf $Format{'4'}{$Style},\n              $sum_blank   ,\n              $sum_comment ,\n              $sum_code    ;\n        }\n        $data_line .= sprintf $Format{'6'}{$Style},\n            $avg_scale   ,\n            $sum_scaled  if $opt_3;\n        push @results, \"  <total \" . $data_line . \"/>\";\n\n        if ($BY_FILE or ($report_type eq \"by report file\")) {\n            push @results, \"</files>\";\n        } else {\n            foreach my $language (keys %{$languages}) {\n                push @results, '  <language name=\"' . $language . '\"/>';\n            }\n            push @results, \"</languages>\";\n        }\n\n        if (!$opt_by_file_by_lang or $ALREADY_SHOWED_XML_SECTION) {\n            push @results, \"</results>\";\n        } else {\n            $ALREADY_SHOWED_XML_SECTION = 1;\n        }\n    } elsif ($opt_yaml or $opt_json) {\n        my ($Q, $open_B, $close_B, $start, $C) = yaml_to_json_separators();\n        push @results, \"${Q}SUM${Q}: ${open_B}\";\n        if ($opt_by_percent) {\n          my $DEN = compute_denominator($opt_by_percent    ,\n                        $sum_code, $sum_comment, $sum_blank);\n          push @results, \"  ${Q}blank${Q}: \"  . sprintf(\"%.2f\", $sum_blank   / $DEN * 100) . $C;\n          push @results, \"  ${Q}comment${Q}: \". sprintf(\"%.2f\", $sum_comment / $DEN * 100) . $C;\n          push @results, \"  ${Q}code${Q}: \"   . $sum_code    . $C;\n        } else {\n          push @results, \"  ${Q}blank${Q}: \"  . $sum_blank   . $C;\n          push @results, \"  ${Q}comment${Q}: \". $sum_comment . $C;\n          push @results, \"  ${Q}code${Q}: \"   . $sum_code    . $C;\n        }\n        push @results, \"  ${Q}nFiles${Q}: \" . $sum_files   . $C;\n        if ($opt_3) {\n            push @results, \"  ${Q}scaled${Q}: \" . $sum_scaled . $C;\n            push @results, \"  ${Q}factor${Q}: \" . $avg_scale  . $C;\n        }\n        if ($opt_json) {\n            $results[-1] =~ s/,\\s*$/} }/;\n        }\n    } elsif ($opt_csv) {\n        # do nothing\n    } else {\n\n        if ($BY_FILE) {\n            $data_line  = sprintf \"%-${spacing_0}s \", \"SUM:\"  ;\n        } else {\n            $data_line  = sprintf \"%-${spacing_1}s \", \"SUM:\"  ;\n            $data_line .= sprintf \"%${spacing_2}d \", $sum_files;\n        }\n        if ($opt_by_percent) {\n          my $DEN = compute_denominator($opt_by_percent    ,\n                        $sum_code, $sum_comment, $sum_blank);\n          $data_line .= sprintf $Format{'5'}{$Style},\n              $sum_blank   / $DEN * 100,\n              $sum_comment / $DEN * 100,\n              $sum_code    ;\n        } else {\n          $data_line .= sprintf $Format{'4'}{$Style},\n              $sum_blank   ,\n              $sum_comment ,\n              $sum_code    ;\n        }\n        $data_line .= sprintf $Format{'6'}{$Style},\n            $avg_scale   ,\n            $sum_scaled if $opt_3;\n        if ($opt_md) {\n            my @words = split(' ', $data_line);\n            my $n_cols = scalar(@words);\n#           my $n_cols = scalar(split(' ', $data_line));  # deprecated\n            $data_line =~ s/\\s+/\\|/g;\n            my @col_hyphens    = ( '--------') x $n_cols;\n            push @results, join(\"|\", @col_hyphens);\n            push @results, $data_line   if $sum_files > 1 or $opt_sum_one;\n            unshift @results, ( \"cloc|$header_line\", \"--- | ---\", \"\", );\n        } else {\n            push @results, $hyphen_line if $sum_files > 1 or $opt_sum_one;\n            push @results, $data_line   if $sum_files > 1 or $opt_sum_one;\n            push @results, $hyphen_line;\n        }\n    }\n    write_xsl_file() if $opt_xsl and $opt_xsl eq $CLOC_XSL;\n    print \"<- generate_report\\n\" if $opt_v > 2;\n    return @results;\n} # 1}}}\nsub print_errors {                           # {{{1\n    my ($rh_Error_Codes, # in\n        $raa_errors    , # in\n       ) = @_;\n\n    print \"-> print_errors\\n\" if $opt_v > 2;\n    my %error_string = reverse(%{$rh_Error_Codes});\n    my $nErrors      = scalar @{$raa_errors};\n    warn sprintf \"\\n%d error%s:\\n\", plural_form(scalar @Errors);\n    for (my $i = 0; $i < $nErrors; $i++) {\n        warn sprintf \"%s:  %s\\n\",\n                     $error_string{ $raa_errors->[$i][0] },\n                     $raa_errors->[$i][1] ;\n    }\n    print \"<- print_errors\\n\" if $opt_v > 2;\n\n} # 1}}}\nsub write_lang_def {                         # {{{1\n    my ($file                     ,\n        $rh_Language_by_Extension , # in\n        $rh_Language_by_Script    , # in\n        $rh_Language_by_File      , # in\n        $rhaa_Filters_by_Language , # in\n        $rh_Not_Code_Extension    , # in\n        $rh_Not_Code_Filename     , # in\n        $rh_Scale_Factor          , # in\n        $rh_EOL_Continuation_re   , # in\n       ) = @_;\n\n    print \"-> write_lang_def($file)\\n\" if $opt_v > 2;\n    my $OUT = new IO::File $file, \"w\";\n    die \"Unable to write to $file\\n\" unless defined $OUT;\n\n    foreach my $language (sort keys %{$rhaa_Filters_by_Language}) {\n        next if $language =~ /Brain/;\n        next if $language eq \"MATLAB/Mathematica/Objective C/MUMPS/Mercury\" or\n                $language eq \"PHP/Pascal\"                       or\n                $language eq \"Pascal/Puppet\"                    or\n                $language eq \"Lisp/OpenCL\"                      or\n                $language eq \"Lisp/Julia\"                       or\n                $language eq \"Perl/Prolog\"                      or\n                $language eq \"D/dtrace\"                         or\n                $language eq \"IDL/Qt Project/Prolog\"            or\n                $language eq \"Fortran 77/Forth\"                 or\n                $language eq \"F#/Forth\"                         or\n                $language eq \"Verilog-SystemVerilog/Coq\"        or\n                $language eq \"TypeScript/Qt Linguist\"           or\n                $language eq \"Qt/Glade\"                         or\n                $language eq \"(unknown)\";\n        printf $OUT \"%s\\n\", $language;\n        foreach my $filter (@{$rhaa_Filters_by_Language->{$language}}) {\n            printf $OUT \"    filter %s\", $filter->[0];\n            printf $OUT \" %s\", $filter->[1] if defined $filter->[1];\n            # $filter->[0] == 'remove_between_general',\n            #                 'remove_between_regex', and\n            #                 'remove_matches_2re' have two args\n            printf $OUT \" %s\", $filter->[2] if defined $filter->[2];\n            print  $OUT \"\\n\";\n        }\n        foreach my $ext (sort keys %{$rh_Language_by_Extension}) {\n            if ($language eq $rh_Language_by_Extension->{$ext}) {\n                printf $OUT \"    extension %s\\n\", $ext;\n            }\n        }\n        foreach my $filename (sort keys %{$rh_Language_by_File}) {\n            if ($language eq $rh_Language_by_File->{$filename}) {\n                printf $OUT \"    filename %s\\n\", $filename;\n            }\n        }\n        foreach my $script_exe (sort keys %{$rh_Language_by_Script}) {\n            if ($language eq $rh_Language_by_Script->{$script_exe}) {\n                printf $OUT \"    script_exe %s\\n\", $script_exe;\n            }\n        }\n        printf $OUT \"    3rd_gen_scale %.2f\\n\", $rh_Scale_Factor->{$language};\n        if (defined $rh_EOL_Continuation_re->{$language}) {\n            printf $OUT \"    end_of_line_continuation %s\\n\",\n                $rh_EOL_Continuation_re->{$language};\n        }\n    }\n\n    $OUT->close;\n    print \"<- write_lang_def\\n\" if $opt_v > 2;\n} # 1}}}\nsub read_lang_def {                          # {{{1\n    my ($file                     ,\n        $rh_Language_by_Extension , # out\n        $rh_Language_by_Script    , # out\n        $rh_Language_by_File      , # out\n        $rhaa_Filters_by_Language , # out\n        $rh_Not_Code_Extension    , # out\n        $rh_Not_Code_Filename     , # out\n        $rh_Scale_Factor          , # out\n        $rh_EOL_Continuation_re   , # out\n        $rh_EOL_abc,\n       ) = @_;\n\n\n    print \"-> read_lang_def($file)\\n\" if $opt_v > 2;\n    my $IN = new IO::File $file, \"r\";\n    die \"Unable to read $file.\\n\" unless defined $IN;\n\n    my $language = \"\";\n    while (<$IN>) {\n        next if /^\\s*#/ or /^\\s*$/;\n\n        if (/^(\\w+.*?)\\s*$/) {\n            $language = $1;\n            next;\n        }\n        die \"Missing computer language name, line $. of $file\\n\"\n            unless $language;\n\n        if      (/^\\s{4}filter\\s+(remove_between_(general|2re|regex))\n                       \\s+(\\S+)\\s+(\\S+)s*$/x) {\n            push @{$rhaa_Filters_by_Language->{$language}}, [\n                  $1 , $3 , $4 ]\n\n        } elsif (/^\\s{4}filter\\s+(\\w+)\\s*$/) {\n            push @{$rhaa_Filters_by_Language->{$language}}, [ $1 ]\n\n        } elsif (/^\\s{4}filter\\s+(\\w+)\\s+(.*?)\\s*$/) {\n            push @{$rhaa_Filters_by_Language->{$language}}, [ $1 , $2 ]\n\n        } elsif (/^\\s{4}extension\\s+(\\S+)\\s*$/) {\n            if (defined $rh_Language_by_Extension->{$1}) {\n                die \"File extension collision:  $1 \",\n                    \"maps to languages '$rh_Language_by_Extension->{$1}' \",\n                    \"and '$language'\\n\" ,\n                    \"Edit $file and remove $1 from one of these two \",\n                    \"language definitions.\\n\";\n            }\n            $rh_Language_by_Extension->{$1} = $language;\n\n        } elsif (/^\\s{4}filename\\s+(\\S+)\\s*$/) {\n            $rh_Language_by_File->{$1} = $language;\n\n        } elsif (/^\\s{4}script_exe\\s+(\\S+)\\s*$/) {\n            $rh_Language_by_Script->{$1} = $language;\n\n        } elsif (/^\\s{4}3rd_gen_scale\\s+(\\S+)\\s*$/) {\n            $rh_Scale_Factor->{$language} = $1;\n\n        } elsif (/^\\s{4}end_of_line_continuation\\s+(\\S+)\\s*$/) {\n            $rh_EOL_Continuation_re->{$language} = $1;\n\n        } else {\n            die \"Unexpected data line $. of $file:\\n$_\\n\";\n        }\n\n    }\n    $IN->close;\n    print \"<- read_lang_def\\n\" if $opt_v > 2;\n} # 1}}}\nsub merge_lang_def {                         # {{{1\n    my ($file                     ,\n        $rh_Language_by_Extension , # in/out\n        $rh_Language_by_Script    , # in/out\n        $rh_Language_by_File      , # in/out\n        $rhaa_Filters_by_Language , # in/out\n        $rh_Not_Code_Extension    , # in/out\n        $rh_Not_Code_Filename     , # in/out\n        $rh_Scale_Factor          , # in/out\n        $rh_EOL_Continuation_re   , # in/out\n        $rh_EOL_abc,\n       ) = @_;\n\n\n    print \"-> merge_lang_def($file)\\n\" if $opt_v > 2;\n    my $IN = new IO::File $file, \"r\";\n    die \"Unable to read $file.\\n\" unless defined $IN;\n\n    my $language        = \"\";\n    my $already_know_it = undef;\n    while (<$IN>) {\n        next if /^\\s*#/ or /^\\s*$/;\n\n        if (/^(\\w+.*?)\\s*$/) {\n            $language = $1;\n            $already_know_it = defined $rh_Scale_Factor->{$language};\n            next;\n        }\n        die \"Missing computer language name, line $. of $file\\n\"\n            unless $language;\n\n        if      (/^    filter\\s+(\\w+)\\s*$/) {\n            next if $already_know_it;\n            push @{$rhaa_Filters_by_Language->{$language}}, [ $1 ]\n\n        } elsif (/^    filter\\s+(\\w+)\\s+(.*?)\\s*$/) {\n            next if $already_know_it;\n            push @{$rhaa_Filters_by_Language->{$language}}, [ $1 , $2 ]\n\n        } elsif (/^    extension\\s+(\\S+)\\s*$/) {\n            next if $already_know_it;\n            if (defined $rh_Language_by_Extension->{$1}) {\n                die \"File extension collision:  $1 \",\n                    \"maps to languages '$rh_Language_by_Extension->{$1}' \",\n                    \"and '$language'\\n\" ,\n                    \"Edit $file and remove $1 from one of these two \",\n                    \"language definitions.\\n\";\n            }\n            $rh_Language_by_Extension->{$1} = $language;\n\n        } elsif (/^    filename\\s+(\\S+)\\s*$/) {\n            next if $already_know_it;\n            $rh_Language_by_File->{$1} = $language;\n\n        } elsif (/^    script_exe\\s+(\\S+)\\s*$/) {\n            next if $already_know_it;\n            $rh_Language_by_Script->{$1} = $language;\n\n        } elsif (/^    3rd_gen_scale\\s+(\\S+)\\s*$/) {\n            next if $already_know_it;\n            $rh_Scale_Factor->{$language} = $1;\n\n        } elsif (/^    end_of_line_continuation\\s+(\\S+)\\s*$/) {\n            next if $already_know_it;\n            $rh_EOL_Continuation_re->{$language} = $1;\n\n        } else {\n            die \"Unexpected data line $. of $file:\\n$_\\n\";\n        }\n\n    }\n    $IN->close;\n    print \"<- merge_lang_def\\n\" if $opt_v > 2;\n} # 1}}}\nsub print_extension_info {                   # {{{1\n    my ($extension,) = @_;\n    if ($extension) {  # show information on this extension\n        foreach my $ext (sort {lc $a cmp lc $b } keys %Language_by_Extension) {\n            # Language_by_Extension{f}    = 'Fortran 77'\n            next if $Language_by_Extension{$ext} =~ /Brain/;\n            printf \"%-15s -> %s\\n\", $ext, $Language_by_Extension{$ext}\n                if $ext =~ m{$extension}i;\n        }\n    } else {           # show information on all  extensions\n        foreach my $ext (sort {lc $a cmp lc $b } keys %Language_by_Extension) {\n            next if $Language_by_Extension{$ext} =~ /Brain/;\n            # Language_by_Extension{f}    = 'Fortran 77'\n            printf \"%-15s -> %s\\n\", $ext, $Language_by_Extension{$ext};\n        }\n    }\n} # 1}}}\nsub print_language_info {                    # {{{1\n    my ($language,\n        $prefix ,) = @_;\n    my %extensions = (); # the subset matched by the given $language value\n    if ($language) {  # show information on this language\n        foreach my $ext (sort {lc $a cmp lc $b } keys %Language_by_Extension) {\n            # Language_by_Extension{f}    = 'Fortran 77'\n            push @{$extensions{$Language_by_Extension{$ext}} }, $ext\n                if lc $Language_by_Extension{$ext} eq lc $language;\n#               if $Language_by_Extension{$ext} =~ m{$language}i;\n        }\n    } else {          # show information on all  languages\n        foreach my $ext (sort {lc $a cmp lc $b } keys %Language_by_Extension) {\n            # Language_by_Extension{f}    = 'Fortran 77'\n            push @{$extensions{$Language_by_Extension{$ext}} }, $ext\n        }\n    }\n\n    # add exceptions (one file extension mapping to multiple languages)\n    if (!$language or $language =~ /^(Objective C|MATLAB|Mathematica|MUMPS|Mercury)$/i) {\n        push @{$extensions{'Objective C'}}, \"m\";\n        push @{$extensions{'MATLAB'}}     , \"m\";\n        push @{$extensions{'Mathematica'}}, \"m\";\n        push @{$extensions{'MUMPS'}}      , \"m\";\n        delete $extensions{'MATLAB/Mathematica/Objective C/MUMPS/Mercury'};\n    }\n    if (!$language or $language =~ /^(Lisp|OpenCL)$/i) {\n        push @{$extensions{'Lisp'}}  , \"cl\";\n        push @{$extensions{'OpenCL'}}, \"cl\";\n        delete $extensions{'Lisp/OpenCL'};\n    }\n    if (!$language or $language =~ /^(Lisp|Julia)$/i) {\n        push @{$extensions{'Lisp'}}  , \"jl\";\n        push @{$extensions{'Julia'}} , \"jl\";\n        delete $extensions{'Lisp/Julia'};\n    }\n    if (!$language or $language =~ /^(Perl|Prolog)$/i) {\n        push @{$extensions{'Perl'}}  , \"pl\";\n        push @{$extensions{'Prolog'}}, \"pl\";\n        delete $extensions{'Perl/Prolog'};\n    }\n    if (!$language or $language =~ /^(IDL|Qt Project|Prolog)$/i) {\n        push @{$extensions{'IDL'}}       , \"pro\";\n        push @{$extensions{'Qt Project'}}, \"pro\";\n        push @{$extensions{'Prolog'}}    , \"pro\";\n        delete $extensions{'IDL/Qt Project/Prolog'};\n    }\n    if (!$language or $language =~ /^(D|dtrace)$/i) {\n        push @{$extensions{'D'}}       , \"d\";\n        push @{$extensions{'dtrace'}}  , \"d\";\n        delete $extensions{'D/dtrace'};\n    }\n    if (!$language or $language =~ /^Forth$/) {\n        push @{$extensions{'Forth'}}     , \"fs\";\n        push @{$extensions{'Forth'}}     , \"f\";\n        push @{$extensions{'Forth'}}     , \"for\";\n        delete $extensions{'Fortran 77/Forth'};\n        delete $extensions{'F#/Forth'};\n    }\n    if (!$language or $language =~ /^Fortran 77$/) {\n        push @{$extensions{'Fortran 77'}}, \"f\";\n        push @{$extensions{'Fortran 77'}}, \"for\";\n        push @{$extensions{'F#'}}        , \"fs\";\n        delete $extensions{'Fortran 77/Forth'};\n    }\n    if (!$language or $language =~ /^F#$/) {\n        push @{$extensions{'F#'}}        , \"fs\";\n        delete $extensions{'F#/Forth'};\n    }\n    if (!$language or $language =~ /^(Verilog-SystemVerilog|Coq)$/) {\n        push @{$extensions{'Coq'}}                   , \"v\";\n        push @{$extensions{'Verilog-SystemVerilog'}} , \"v\";\n        delete $extensions{'Verilog-SystemVerilog/Coq'};\n    }\n    if (!$language or $language =~ /^(TypeScript|Qt Linguist)$/) {\n        push @{$extensions{'TypeScript'}}  , \"ts\";\n        push @{$extensions{'Qt Linguist'}} , \"ts\";\n        delete $extensions{'TypeScript/Qt Linguist'};\n    }\n    if (!$language or $language =~ /^(Qt|Glade)$/) {\n        push @{$extensions{'Glade'}} , \"ui\";\n        push @{$extensions{'Qt'}}    , \"ui\";\n        delete $extensions{'Qt/Glade'};\n    }\n    if (!$language or $language =~ /^(Ant)$/i) {\n        push @{$extensions{'Ant'}}  , \"build.xml\";\n        delete $extensions{'Ant/XML'};\n    }\n    if ($opt_explain) {\n        return unless $extensions{$language};\n        if ($prefix) {\n            printf \"%s %s\\n\", $prefix, join(\", \", @{$extensions{$language}});\n        } else {\n            printf \"%-26s (%s)\\n\", $language, join(\", \", @{$extensions{$language}});\n        }\n    } else {\n        if (%extensions) {\n            foreach my $lang (sort {lc $a cmp lc $b } keys %extensions) {\n                next if $lang =~ /Brain/;\n                if ($prefix) {\n                    printf \"%s %s\\n\", $prefix, join(\", \", @{$extensions{$lang}});\n                } else {\n                    printf \"%-26s (%s)\\n\", $lang, join(\", \", @{$extensions{$lang}});\n                }\n            }\n        }\n    }\n} # 1}}}\nsub print_language_filters {                 # {{{1\n    my ($language,) = @_;\n    if (!$Filters_by_Language{$language} or\n        !@{$Filters_by_Language{$language}}) {\n        warn \"Unknown language: $language\\n\";\n        warn \"Use --show-lang to list all defined languages.\\n\";\n        return;\n    }\n    printf \"%s\\n\", $language;\n    foreach my $filter (@{$Filters_by_Language{$language}}) {\n        printf \"    filter %s\", $filter->[0];\n        printf \"  %s\", $filter->[1] if defined $filter->[1];\n        printf \"  %s\", $filter->[2] if defined $filter->[2];\n        print  \"\\n\";\n    }\n    print_language_info($language, \"    extensions:\");\n} # 1}}}\nsub make_file_list {                         # {{{1\n    my ($ra_arg_list,  # in   file and/or directory names to examine\n        $rh_Err     ,  # in   hash of error codes\n        $raa_errors ,  # out  errors encountered\n        $rh_ignored ,  # out  files not recognized as computer languages\n        ) = @_;\n    print \"-> make_file_list(@{$ra_arg_list})\\n\" if $opt_v > 2;\n\n    my ($fh, $filename);\n    if ($opt_categorized) {\n        $filename = $opt_categorized;\n        $fh = new IO::File $filename, \"+>\";  # open for read/write\n        die \"Unable to write to $filename:  $!\\n\" unless defined $fh;\n    } elsif ($opt_sdir) {\n        # write to the user-defined scratch directory\n        $filename = $opt_sdir . '/cloc_file_list.txt';\n        $fh = new IO::File $filename, \"+>\";  # open for read/write\n        die \"Unable to write to $filename:  $!\\n\" unless defined $fh;\n    } else {\n        # let File::Temp create a suitable temporary file\n        ($fh, $filename) = tempfile(UNLINK => 1);  # delete file on exit\n        print \"Using temp file list [$filename]\\n\" if $opt_v;\n    }\n\n    my @dir_list = ();\n    foreach my $file_or_dir (@{$ra_arg_list}) {\n#print \"make_file_list file_or_dir=$file_or_dir\\n\";\n        my $size_in_bytes = 0;\n        if (!-r $file_or_dir) {\n            push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file_or_dir];\n            next;\n        }\n        if (is_file($file_or_dir)) {\n            if (!(-s $file_or_dir)) {   # 0 sized file, named pipe, socket\n                $rh_ignored->{$file_or_dir} = 'zero sized file';\n                next;\n            } elsif (-B $file_or_dir and !$opt_read_binary_files) {\n                # avoid binary files unless user insists on reading them\n                if ($opt_unicode) {\n                    # only ignore if not a Unicode file w/trivial\n                    # ASCII transliteration\n                    if (!unicode_file($file_or_dir)) {\n                        $rh_ignored->{$file_or_dir} = 'binary file';\n                        next;\n                    }\n                } else {\n                    $rh_ignored->{$file_or_dir} = 'binary file';\n                    next;\n                }\n            }\n            push @file_list, \"$file_or_dir\";\n        } elsif (is_dir($file_or_dir)) {\n            push @dir_list, $file_or_dir;\n        } else {\n            push @{$raa_errors}, [$rh_Err->{'Neither file nor directory'} , $file_or_dir];\n            $rh_ignored->{$file_or_dir} = 'not file, not directory';\n        }\n    }\n\n    # apply exclusion rules to file names passed in on the command line\n    my @new_file_list = ();\n    foreach my $File (@file_list) {\n        my ($volume, $directories, $filename) = File::Spec->splitpath( $File );\n        my $ignore_this_file = 0;\n        foreach my $Sub_Dir ( File::Spec->splitdir($directories) ) {\n            if ($Exclude_Dir{$Sub_Dir}) {\n                $Ignored{$Sub_Dir} = \"($File) --exclude-dir=$Sub_Dir\";\n                $ignore_this_file = 1;\n                last;\n            }\n        }\n        push @new_file_list, $File unless $ignore_this_file;\n    }\n    @file_list = @new_file_list;\n\n    foreach my $dir (@dir_list) {\n#print \"make_file_list dir=$dir  Exclude_Dir{$dir}=$Exclude_Dir{$dir}\\n\";\n        # populates global variable @file_list\n        if ($Exclude_Dir{$dir}) {\n            $Ignored{$dir} = \"--exclude-dir=$Exclude_Dir{$dir}\";\n            next;\n        }\n        find({wanted     => \\&files            ,\n              preprocess => \\&find_preprocessor,\n              follow     =>  $opt_follow_links }, $dir);\n    }\n    # there's a possibility of file duplication if user provided a list\n    # file or --vcs command that returns directory names; squash these\n    my %unique_file_list = map { $_ => 1 } @file_list;\n    @file_list = sort keys %unique_file_list;\n\n    $nFiles_Found = scalar @file_list;\n    printf \"%8d text file%s.\\n\", plural_form($nFiles_Found) unless $opt_quiet;\n    write_file($opt_found, sort @file_list) if $opt_found;\n\n    my $nFiles_Categorized = 0;\n    foreach my $file (@file_list) {\n        printf \"classifying $file\\n\" if $opt_v > 2;\n\n        my $basename = basename $file;\n        if ($Not_Code_Filename{$basename}) {\n            $rh_ignored->{$file} = \"listed in \" . '$' .\n                \"Not_Code_Filename{$basename}\";\n            next;\n        } elsif ($basename =~ m{~$}) {\n            $rh_ignored->{$file} = \"temporary editor file\";\n            next;\n        }\n\n        my $size_in_bytes = (stat $file)[7];\n        my $language      = \"\";\n        if ($All_One_Language) {\n            # user over-rode auto-language detection by using\n            # --force-lang with just a language name (no extension)\n            $language      = $All_One_Language;\n        } else {\n            $language      = classify_file($file      ,\n                                           $rh_Err    ,\n                                           $raa_errors,\n                                           $rh_ignored);\n        }\ndie  \"make_file_list($file) undef size\" unless defined $size_in_bytes;\ndie  \"make_file_list($file) undef lang\" unless defined $language;\n        printf $fh \"%d,%s,%s\\n\", $size_in_bytes, $language, $file;\n        ++$nFiles_Categorized;\n        #printf \"classified %d files\\n\", $nFiles_Categorized\n        #    unless (!$opt_progress_rate or\n        #            ($nFiles_Categorized % $opt_progress_rate));\n    }\n    printf \"classified %d files\\r\", $nFiles_Categorized\n        if !$opt_quiet and $nFiles_Categorized > 1;\n\n    print \"<- make_file_list()\\n\" if $opt_v > 2;\n\n    return $fh;   # handle to the file containing the list of files to process\n}  # 1}}}\nsub invoke_generator {                       # {{{1\n    my ($generator, $ra_user_inputs) = @_;\n    # If user provided file/directory inputs, only return\n    # generated files that are in user's request.\n    # Populates global variable %Ignored.\n    print \"-> invoke_generator($generator)\\n\" if $opt_v > 2;\n    open(FH, \"$generator |\") or\n        die \"Failed to pipe $generator: $!\";\n    my @files = ();\n    while(<FH>) {\n        chomp;\n        my $F = $_;\n        print \"VCS input:  $F\\n\" if $opt_v >= 2;\n        if (!defined $ra_user_inputs or !@{$ra_user_inputs}) {\n            push @files, $F;\n        } else {\n            # is this file desired?\n            my $want_this_one = 0;\n            foreach my $file_dir (@{$ra_user_inputs}) {\n                if (/^$file_dir/) {\n                    $want_this_one = 1;\n                    last;\n                }\n            }\n            push @files, $F if $want_this_one;\n        }\n    }\n    close(FH);\n    # apply match/not-match file/dir filters to the list so far\n    my @post_filter = ();\n    foreach my $F (@files) {\n        if ($opt_match_f) {\n            push @post_filter, $F if basename($F) =~ m{$opt_match_f};\n            next;\n        }\n        if ($opt_match_d) {\n            push @post_filter, $F if $F =~ m{$opt_match_d};\n            next;\n        }\n        if ($opt_not_match_d) {\n            if ($opt_fullpath and $F =~ m{$opt_not_match_d}) {\n                $Ignored{$F} = \"--not-match-d=$opt_not_match_d\";\n                next;\n            } elsif (basename($F) =~ m{$opt_not_match_d}) {\n                $Ignored{$F} = \"--not-match-d (basename) =$opt_not_match_d\";\n                next;\n            }\n        }\n        if ($opt_not_match_f) {\n            push @post_filter, $F unless basename($F) =~ m{$opt_not_match_f};\n            next;\n        }\n        push @post_filter, $F;\n    }\n    print \"<- invoke_generator\\n\" if $opt_v > 2;\n    return @post_filter;\n} # 1}}}\nsub remove_duplicate_files {                 # {{{1\n    my ($fh                   , # in\n        $rh_Language          , # out\n        $rh_unique_source_file, # out\n        $rh_Err               , # in\n        $raa_errors           , # out  errors encountered\n        $rh_ignored           , # out\n        ) = @_;\n\n    # Check for duplicate files by comparing file sizes.\n    # Where files are equally sized, compare their MD5 checksums.\n    print \"-> remove_duplicate_files\\n\" if $opt_v > 2;\n\n    my $n = 0;\n    my %files_by_size = (); # files_by_size{ # bytes } = [ list of files ]\n    seek($fh, 0, 0); # rewind to beginning of the temp file\n    while (<$fh>) {\n        ++$n;\n        my ($size_in_bytes, $language, $file) = split(/,/, $_, 3);\n        chomp($file);\n        $rh_Language->{$file} = $language;\n        push @{$files_by_size{$size_in_bytes}}, $file;\n        if ($opt_skip_uniqueness) {\n            $rh_unique_source_file->{$file} = 1;\n        }\n    }\n    return if $opt_skip_uniqueness;\n    if ($opt_progress_rate and ($n > $opt_progress_rate)) {\n        printf \"Duplicate file check %d files (%d known unique)\\r\",\n            $n, scalar keys %files_by_size;\n    }\n    $n = 0;\n    foreach my $bytes (sort {$a <=> $b} keys %files_by_size) {\n        ++$n;\n        printf \"Unique: %8d files                                          \\r\",\n            $n unless (!$opt_progress_rate or ($n % $opt_progress_rate));\n        if (scalar @{$files_by_size{$bytes}} == 1) {\n            # only one file is this big; must be unique\n            $rh_unique_source_file->{$files_by_size{$bytes}[0]} = 1;\n            next;\n        } else {\n#print \"equally sized files: \",join(\", \", @{$files_by_size{$bytes}}), \"\\n\";\n            # Files in the list @{$files_by_size{$bytes} all are\n            # $bytes long.  Sort the list by file basename.\n\n          # # sorting on basename causes repeatability problems\n          # # if the basename is not unique (eg \"includeA/x.h\"\n          # # and \"includeB/x.h\".  Instead, sort on full path.\n          # # Ref bug #114.\n          # my @sorted_bn = ();\n          # my %BN = map { basename($_) => $_ } @{$files_by_size{$bytes}};\n          # foreach my $F (sort keys %BN) {\n          #     push @sorted_bn, $BN{$F};\n          # }\n\n            my @sorted_bn = sort @{$files_by_size{$bytes}};\n\n            foreach my $F (different_files(\\@sorted_bn  ,\n                                            $rh_Err     ,\n                                            $raa_errors ,\n                                            $rh_ignored ) ) {\n                $rh_unique_source_file->{$F} = 1;\n            }\n        }\n    }\n    print \"<- remove_duplicate_files\\n\" if $opt_v > 2;\n} # 1}}}\nsub find_preprocessor {                      # {{{1\n    # invoked by File::Find's find() each time it enters a new directory\n    # Reads global variable %Exclude_Dir.\n    # Populates global variable %Ignored.\n    # Reject files/directories in cwd which are in the exclude list.\n    print \"-> find_preprocessor(\", cwd(), \")\\n\" if $opt_v > 2;\n    my @ok = ();\n\n#printf \"TOP find_preprocessor\\n\";\n\n    foreach my $F_or_D (@_) {  # pure file or directory name, no separators\n        next if $F_or_D =~ /^\\.{1,2}$/;  # skip .  and  ..\n        if ($Exclude_Dir{$F_or_D}) {\n            $Ignored{$File::Find::name} = \"--exclude-dir=$Exclude_Dir{$F_or_D}\";\n        } else {\n#printf \"  F_or_D=%-20s File::Find::name=%s\\n\", $F_or_D, $File::Find::name;\n            if ($opt_not_match_d) {\n                if ($opt_fullpath and $File::Find::name =~ m{$opt_not_match_d}) {\n                    $Ignored{$File::Find::name} = \"--not-match-d=$opt_not_match_d\";\n                } elsif (!-d $F_or_D and basename($File::Find::name) =~ m{$opt_not_match_d}) {\n                    $Ignored{$File::Find::name} = \"--not-match-d (basename) =$opt_not_match_d\";\n                } else {\n                    push @ok, $F_or_D;\n                }\n            } else {\n                push @ok, $F_or_D;\n            }\n        }\n    }\n\n    print \"<- find_preprocessor(@ok)\\n\" if $opt_v > 2;\n    return @ok;\n} # 1}}}\nsub files {                                  # {{{1\n    # invoked by File::Find's find()   Populates global variable @file_list.\n    # See also find_preprocessor() which prunes undesired directories.\n\n    my $Dir = cwd(); # not $File::Find::dir which just gives relative path\n    if ($opt_fullpath) {\n        # look at as much of the path as is known\n        if ($opt_match_f    ) {\n            return unless $File::Find::name =~ m{$opt_match_f};\n        }\n        if ($opt_not_match_f) {\n            return if     $File::Find::name =~ m{$opt_not_match_f};\n        }\n    } else {\n        # only look at the basename\n        if ($opt_match_f    ) { return unless /$opt_match_f/;     }\n        if ($opt_not_match_f) { return if     /$opt_not_match_f/; }\n    }\n    if ($opt_match_d    ) { return unless $Dir =~ m{$opt_match_d}     }\n\n    my $nBytes = -s $_ ;\n    if (!$nBytes) {\n        $Ignored{$File::Find::name} = 'zero sized file';\n        printf \"files(%s)  zero size\\n\", $File::Find::name if $opt_v > 5;\n    }\n    return unless $nBytes  ; # attempting other tests w/pipe or socket will hang\n    if ($nBytes > $opt_max_file_size*1024**2) {\n        $Ignored{$File::Find::name} = \"file size of \" .\n            $nBytes/1024**2 . \" MB exceeds max file size of \" .\n            \"$opt_max_file_size MB\";\n        printf \"file(%s)  exceeds $opt_max_file_size MB\\n\",\n            $File::Find::name if $opt_v > 5;\n        return;\n    }\n    my $is_dir = is_dir($_);\n    my $is_bin = -B     $_ ;\n    printf \"files(%s)  size=%d is_dir=%d  -B=%d\\n\",\n        $File::Find::name, $nBytes, $is_dir, $is_bin if $opt_v > 5;\n    $is_bin = 0 if $opt_unicode and unicode_file($_);\n    $is_bin = 0 if $opt_read_binary_files;\n    return if $is_dir or $is_bin;\n    ++$nFiles_Found;\n    printf \"%8d files\\r\", $nFiles_Found\n        unless (!$opt_progress_rate or ($nFiles_Found % $opt_progress_rate));\n    push @file_list, $File::Find::name;\n} # 1}}}\nsub archive_files {                          # {{{1\n    # invoked by File::Find's find()  Populates global variable @binary_archive\n    foreach my $ext (keys %Known_Binary_Archives) {\n        push @binary_archive, $File::Find::name\n            if $File::Find::name =~ m{$ext$};\n    }\n} # 1}}}\nsub is_file {                                # {{{1\n    # portable method to test if item is a file\n    # (-f doesn't work in ActiveState Perl on Windows)\n    my $item = shift @_;\n\n    if ($ON_WINDOWS) {\n        my $mode = (stat $item)[2];\n           $mode = 0 unless $mode;\n        if ($mode & 0100000) { return 1; }\n        else                 { return 0; }\n    } else {\n        return (-f $item);  # works on Unix, Linux, CygWin, z/OS\n    }\n} # 1}}}\nsub is_dir {                                 # {{{1\n    # portable method to test if item is a directory\n    # (-d doesn't work in older versions of ActiveState Perl on Windows)\n    my $item = shift @_;\n\n    if ($ON_WINDOWS) {\n        my $mode = (stat $item)[2];\n           $mode = 0 unless $mode;\n        if ($mode & 0040000) { return 1; }\n        else                 { return 0; }\n    } else {\n        return (-d $item);  # works on Unix, Linux, CygWin, z/OS\n    }\n} # 1}}}\nsub is_excluded {                            # {{{1\n    my ($file       , # in\n        $excluded   , # in   hash of excluded directories\n       ) = @_;\n    my($filename, $filepath, $suffix) = fileparse($file);\n    foreach my $path (sort keys %{$excluded}) {\n        return 1 if ($filepath =~ m{^$path/}i);\n    }\n} # 1}}}\nsub classify_file {                          # {{{1\n    my ($full_file   , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n        $rh_ignored  , # out\n       ) = @_;\n\n    print \"-> classify_file($full_file)\\n\" if $opt_v > 2;\n    my $language = \"(unknown)\";\n\n    if (basename($full_file) eq \"-\" && defined $opt_stdin_name) {\n       $full_file = $opt_stdin_name;\n    }\n\n    my $look_at_first_line = 0;\n    my $file = basename $full_file;\n    if ($opt_autoconf and $file =~ /\\.in$/) {\n       $file =~ s/\\.in$//;\n    }\n    return $language if $Not_Code_Filename{$file}; # (unknown)\n    return $language if $file =~ m{~$}; # a temp edit file (unknown)\n    if (defined $Language_by_File{$file}) {\n        if      ($Language_by_File{$file} eq \"Ant/XML\") {\n            return Ant_or_XML(  $full_file, $rh_Err, $raa_errors);\n        } elsif ($Language_by_File{$file} eq \"Maven/XML\") {\n            return Maven_or_XML($full_file, $rh_Err, $raa_errors);\n        } else {\n            return $Language_by_File{$file};\n        }\n    }\n\n    if ($file =~ /\\.([^\\.]+)$/) { # has an extension\n      print \"$full_file extension=[$1]\\n\" if $opt_v > 2;\n      my $extension = $1;\n         # Windows file names are case insensitive so map\n         # all extensions to lowercase there.\n         $extension = lc $extension if $ON_WINDOWS;\n      my @extension_list = ( $extension );\n      if ($file =~ /\\.([^\\.]+\\.[^\\.]+)$/) { # has a double extension\n          my $extension = $1;\n          $extension = lc $extension if $ON_WINDOWS;\n          unshift @extension_list, $extension;  # examine double ext first\n      }\n      foreach my $extension (@extension_list) {\n        if ($Not_Code_Extension{$extension} and\n           !$Forced_Extension{$extension}) {\n           # If .1 (for example) is an extension that would ordinarily be\n           # ignored but the user has insisted this be counted with the\n           # --force-lang option, then go ahead and count it.\n            $rh_ignored->{$full_file} =\n                'listed in $Not_Code_Extension{' . $extension . '}';\n            return $language;\n        }\n        if (defined $Language_by_Extension{$extension}) {\n            if ($Language_by_Extension{$extension} eq\n                'MATLAB/Mathematica/Objective C/MUMPS/Mercury') {\n                my $lang_M_or_O = \"\";\n                matlab_or_objective_C($full_file ,\n                                      $rh_Err    ,\n                                      $raa_errors,\n                                     \\$lang_M_or_O);\n                if ($lang_M_or_O) {\n                    return $lang_M_or_O;\n                } else { # an error happened in matlab_or_objective_C()\n                    $rh_ignored->{$full_file} =\n                        'failure in matlab_or_objective_C()';\n                    return $language; # (unknown)\n                }\n            } elsif ($Language_by_Extension{$extension} eq 'PHP/Pascal') {\n                if (really_is_php($full_file)) {\n                    return 'PHP';\n                } elsif (really_is_incpascal($full_file)) {\n                    return 'Pascal';\n                } else {\n                    return $language; # (unknown)\n                }\n            } elsif ($Language_by_Extension{$extension} eq 'Pascal/Puppet') {\n                my $lang_Pasc_or_Pup = \"\";\n                pascal_or_puppet(     $full_file ,\n                                      $rh_Err    ,\n                                      $raa_errors,\n                                     \\$lang_Pasc_or_Pup);\n                if ($lang_Pasc_or_Pup) {\n                    return $lang_Pasc_or_Pup;\n                } else { # an error happened in pascal_or_puppet()\n                    $rh_ignored->{$full_file} =\n                        'failure in pascal_or_puppet()';\n                    return $language; # (unknown)\n                }\n            } elsif ($Language_by_Extension{$extension} eq 'Lisp/OpenCL') {\n                return Lisp_or_OpenCL($full_file, $rh_Err, $raa_errors);\n            } elsif ($Language_by_Extension{$extension} eq 'Lisp/Julia') {\n                return Lisp_or_Julia( $full_file, $rh_Err, $raa_errors);\n            } elsif ($Language_by_Extension{$extension} eq 'Perl/Prolog') {\n                return Perl_or_Prolog($full_file, $rh_Err, $raa_errors);\n            } elsif ($Language_by_Extension{$extension} eq\n                     'IDL/Qt Project/Prolog') {\n                return IDL_or_QtProject($full_file, $rh_Err, $raa_errors);\n            } elsif ($Language_by_Extension{$extension} eq 'D/dtrace') {\n                # is it D or an init.d shell script?\n                my $a_script = really_is_D($full_file, $rh_Err, $raa_errors);\n                if ($a_script) {\n                    # could be dtrace, sh, bash or anything one would\n                    # write an init.d script in\n                    if (defined $Language_by_Script{$a_script}) {\n                        return $Language_by_Script{$a_script};\n                    } else {\n                        $rh_ignored->{$full_file} =\n                            \"Unrecognized script language, '$a_script'\";\n                    }\n                } else {\n                    return 'D';\n                }\n            } elsif ($Language_by_Extension{$extension} eq 'Fortran 77/Forth') {\n                return Forth_or_Fortran($full_file, $rh_Err, $raa_errors);\n            } elsif ($Language_by_Extension{$extension} eq 'F#/Forth') {\n                return Forth_or_Fsharp( $full_file, $rh_Err, $raa_errors);\n            } elsif ($Language_by_Extension{$extension} eq 'Verilog-SystemVerilog/Coq') {\n                return Verilog_or_Coq( $full_file, $rh_Err, $raa_errors);\n            } elsif ($Language_by_Extension{$extension} eq 'Smarty') {\n                if ($extension eq \"smarty\") {\n                    # unambiguous -- if ends with .smarty, is Smarty\n                    return $Language_by_Extension{$extension};\n                }\n                # Smarty extension .tpl is generic; make sure the\n                # file at least roughly resembles PHP.  Alternatively,\n                # if the user forces the issue, do the count.\n                my $force_smarty = 0;\n                foreach (@opt_force_lang) {\n                    if (lc($_) eq \"smarty,tpl\") {\n                        $force_smarty = 1;\n                        last;\n                    }\n                }\n                if (really_is_php($full_file) or $force_smarty) {\n                    return 'Smarty';\n                } else {\n                    return $language; # (unknown)\n                }\n            } elsif ($Language_by_Extension{$extension} eq 'TypeScript/Qt Linguist') {\n                return TypeScript_or_QtLinguist( $full_file, $rh_Err, $raa_errors);\n            } elsif ($Language_by_Extension{$extension} eq 'Qt/Glade') {\n                return Qt_or_Glade( $full_file, $rh_Err, $raa_errors);\n            } elsif ($Language_by_Extension{$extension} eq 'Brainfuck') {\n                if (really_is_bf($full_file)) {\n                    return $Language_by_Extension{$extension};\n                } else {\n                    return $language; # (unknown)\n                }\n            } else {\n                return $Language_by_Extension{$extension};\n            }\n        } else { # has an unmapped file extension\n            $look_at_first_line = 1;\n        }\n      }\n    } elsif (defined $Language_by_File{lc $file}) {\n        return $Language_by_File{lc $file};\n    } elsif ($opt_lang_no_ext and\n             defined $Filters_by_Language{$opt_lang_no_ext}) {\n        return $opt_lang_no_ext;\n    } else {  # no file extension\n        $look_at_first_line = 1;\n    }\n\n    if ($look_at_first_line) {\n        # maybe it is a shell/Perl/Python/Ruby/etc script that\n        # starts with pound bang:\n        #   #!/usr/bin/perl\n        #   #!/usr/bin/env perl\n        my $script_language = peek_at_first_line($full_file ,\n                                                 $rh_Err    ,\n                                                 $raa_errors);\n        if (!$script_language) {\n            $rh_ignored->{$full_file} = \"language unknown (#2)\";\n            # returns (unknown)\n        }\n        if (defined $Language_by_Script{$script_language}) {\n            if (defined $Filters_by_Language{\n                            $Language_by_Script{$script_language}}) {\n                $language = $Language_by_Script{$script_language};\n            } else {\n                $rh_ignored->{$full_file} =\n                    \"undefined:  Filters_by_Language{\" .\n                    $Language_by_Script{$script_language} .\n                    \"} for scripting language $script_language\";\n                # returns (unknown)\n            }\n        } else {\n            $rh_ignored->{$full_file} = \"language unknown (#3)\";\n            # returns (unknown)\n        }\n    }\n    print \"<- classify_file($full_file)=$language\\n\" if $opt_v > 2;\n    return $language;\n} # 1}}}\nsub peek_at_first_line {                     # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> peek_at_first_line($file)\\n\" if $opt_v > 2;\n\n    my $script_language = \"\";\n    if (!-r $file) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $script_language;\n    }\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        print \"<- peek_at_first_line($file)\\n\" if $opt_v > 2;\n        return $script_language;\n    }\n    chomp(my $first_line = <$IN>);\n    if (defined $first_line) {\n#print \"peek_at_first_line of [$file] first_line=[$first_line]\\n\";\n        if ($first_line =~ /^#\\!\\s*(\\S.*?)$/) {\n#print \"peek_at_first_line 1=[$1]\\n\";\n            my @pound_bang = split(' ', $1);\n#print \"peek_at_first_line basename 0=[\", basename($pound_bang[0]), \"]\\n\";\n            if (basename($pound_bang[0]) eq \"env\" and\n                scalar @pound_bang > 1) {\n                $script_language = $pound_bang[1];\n#print \"peek_at_first_line pound_bang A $pound_bang[1]\\n\";\n            } else {\n                $script_language = basename $pound_bang[0];\n#print \"peek_at_first_line pound_bang B $script_language\\n\";\n            }\n        }\n    }\n    $IN->close;\n    print \"<- peek_at_first_line($file)\\n\" if $opt_v > 2;\n    return $script_language;\n} # 1}}}\nsub different_files {                        # {{{1\n    # See which of the given files are unique by computing each file's MD5\n    # sum.  Return the subset of files which are unique.\n    my ($ra_files    , # in\n        $rh_Err      , # in\n        $raa_errors  , # out\n        $rh_ignored  , # out\n       ) = @_;\n\n    print \"-> different_files(@{$ra_files})\\n\" if $opt_v > 2;\n    my %file_hash = ();  # file_hash{md5 hash} = [ file1, file2, ... ]\n    foreach my $F (@{$ra_files}) {\n        next if is_dir($F);  # needed for Windows\n        my $IN = new IO::File $F, \"r\";\n        if (!defined $IN) {\n            push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $F];\n            $rh_ignored->{$F} = 'cannot read';\n        } else {\n            if ($HAVE_Digest_MD5) {\n                binmode $IN;\n                my $MD5 = Digest::MD5->new->addfile($IN)->hexdigest;\n#print \"$F, $MD5\\n\";\n                push @{$file_hash{$MD5}}, $F;\n            } else {\n                # all files treated unique\n                push @{$file_hash{$F}}, $F;\n            }\n            $IN->close;\n        }\n    }\n\n    # Loop over file sets having identical MD5 sums.  Within\n    # each set, pick the file that most resembles known source\n    # code.\n    my @unique = ();\n    for my $md5 (sort keys %file_hash) {\n        my $i_best = 0;\n        for (my $i = 1; $i < scalar(@{$file_hash{$md5}}); $i++) {\n            my $F = $file_hash{$md5}[$i];\n            my (@nul_a, %nul_h);\n            my $language = classify_file($F, $rh_Err,\n                                        # don't save these errors; pointless\n                                        \\@nul_a, \\%nul_h);\n            $i_best = $i if $language ne \"(unknown)\";\n        }\n        # keep the best one found and identify the rest as ignored\n        for (my $i = 0; $i < scalar(@{$file_hash{$md5}}); $i++) {\n            if ($i == $i_best) {\n                push @unique, $file_hash{$md5}[$i_best];\n            } else {\n                $rh_ignored->{$file_hash{$md5}[$i]} = \"duplicate of \" .\n                    $file_hash{$md5}[$i_best];\n            }\n        }\n\n    }\n    print \"<- different_files(@unique)\\n\" if $opt_v > 2;\n    return @unique;\n} # 1}}}\nsub call_counter {                           # {{{1\n    my ($file     , # in\n        $language , # in\n        $ra_Errors, # out\n       ) = @_;\n\n    # Logic:  pass the file through the following filters:\n    #         1. remove blank lines\n    #         2. remove comments using each filter defined for this language\n    #            (example:  SQL has two, remove_starts_with(--) and\n    #             remove_c_comments() )\n    #         3. compute comment lines as\n    #               total lines - blank lines - lines left over after all\n    #                   comment filters have been applied\n\n    print \"-> call_counter($file, $language)\\n\" if $opt_v > 2;\n#print \"call_counter:  \", Dumper(@routines), \"\\n\";\n\n    my @lines = ();\n    my $ascii = \"\";\n    if (-B $file and $opt_unicode) {\n        # was binary so must be unicode\n\n        $/ = undef;\n        my $IN = new IO::File $file, \"r\";\n        my $bin_text = <$IN>;\n        $IN->close;\n        $/ = \"\\n\";\n\n        $ascii = unicode_to_ascii( $bin_text );\n        @lines = split(\"\\n\", $ascii );\n        foreach (@lines) { $_ = \"$_\\n\"; }\n\n    } else {\n        # regular text file\n        @lines = read_file($file);\n        $ascii = join('', @lines);\n    }\n\n    my @original_lines = @lines;\n    my $total_lines    = scalar @lines;\n\n    print_lines($file, \"Original file:\", \\@lines) if $opt_print_filter_stages;\n    @lines = rm_blanks(\\@lines, $language, \\%EOL_Continuation_re); # remove blank lines\n    my $blank_lines = $total_lines - scalar @lines;\n    print_lines($file, \"Blank lines removed:\", \\@lines)\n        if $opt_print_filter_stages;\n\n    @lines = rm_comments(\\@lines, $language, $file,\n                               \\%EOL_Continuation_re);\n\n    my $comment_lines = $total_lines - $blank_lines - scalar  @lines;\n    if ($opt_strip_comments) {\n        my $stripped_file = \"\";\n        if ($opt_original_dir) {\n            $stripped_file =          $file . \".$opt_strip_comments\";\n        } else {\n            $stripped_file = basename $file . \".$opt_strip_comments\";\n        }\n        write_file($stripped_file, @lines);\n    }\n    if ($opt_html and !$opt_diff) {\n        chomp(@original_lines);  # includes blank lines, comments\n        chomp(@lines);           # no blank lines, no comments\n\n        my (@diff_L, @diff_R, %count);\n\n        # remove blank lines to get better quality diffs; count\n        # blank lines separately\n        my @original_lines_minus_white = ();\n        # however must keep track of how many blank lines were removed and\n        # where they were removed so that the HTML display can include it\n        my %blank_line  = ();\n        my $insert_line = 0;\n        foreach (@original_lines) {\n            if (/^\\s*$/) {\n               ++$count{blank}{same};\n               ++$blank_line{ $insert_line };\n            } else {\n                ++$insert_line;\n                push @original_lines_minus_white, $_;\n            }\n        }\n\n        array_diff( $file                       ,   # in\n                   \\@original_lines_minus_white ,   # in\n                   \\@lines                      ,   # in\n                   \"comment\"                    ,   # in\n                   \\@diff_L, \\@diff_R,          ,   # out\n                    $ra_Errors);                    # in/out\n        write_comments_to_html($file, \\@diff_L, \\@diff_R, \\%blank_line);\n#print Dumper(\"count\", \\%count);\n    }\n\n    print \"<- call_counter($total_lines, $blank_lines, $comment_lines)\\n\"\n        if $opt_v > 2;\n    return ($total_lines, $blank_lines, $comment_lines);\n} # 1}}}\nsub windows_glob {                           # {{{1\n    # Windows doesn't expand wildcards.  Use code from Sean M. Burke's\n    # Win32::Autoglob module to do this.\n    return map {;\n        ( defined($_) and m/[\\*\\?]/ ) ? sort(glob($_)) : $_\n          } @_;\n} # 1}}}\nsub write_file {                             # {{{1\n    my ($file  , # in\n        @lines , # in\n       ) = @_;\n\n#print \"write_file 1 [$file]\\n\";\n    # Do ~ expansion (by Tim LaBerge, fixes bug 2787984)\n    my $preglob_filename = $file;\n#print \"write_file 2 [$preglob_filename]\\n\";\n    if ($ON_WINDOWS) {\n        $file = (windows_glob($file))[0];\n    } else {\n        $file = File::Glob::glob($file);\n    }\n#print \"write_file 3 [$file]\\n\";\n    $file = $preglob_filename unless $file;\n#print \"write_file 4 [$file]\\n\";\n\n    print \"-> write_file($file)\\n\" if $opt_v > 2;\n\n    # Create the destination directory if it doesn't already exist.\n    my $abs_file_path = File::Spec->rel2abs( $file );\n    my ($volume, $directories, $filename) = File::Spec->splitpath( $abs_file_path );\n    mkpath($volume . $directories, 1, 0777);\n\n    my $OUT = new IO::File $file, \"w\";\n    if (defined $OUT) {\n        chomp(@lines);\n        print $OUT join(\"\\n\", @lines), \"\\n\";\n        $OUT->close;\n    } else {\n        warn \"Unable to write to $file\\n\";\n    }\n    print \"Wrote $file\" unless $opt_quiet;\n    print \", $CLOC_XSL\" if $opt_xsl and $opt_xsl eq $CLOC_XSL;\n    print \"\\n\" unless $opt_quiet;\n\n    print \"<- write_file\\n\" if $opt_v > 2;\n} # 1}}}\nsub read_file  {                             # {{{1\n    my ($file, ) = @_;\n    my %BoM = (\n        \"fe ff\"           => 2 ,\n        \"ff fe\"           => 2 ,\n        \"ef bb bf\"        => 3 ,\n        \"f7 64 4c\"        => 3 ,\n        \"0e fe ff\"        => 3 ,\n        \"fb ee 28\"        => 3 ,\n        \"00 00 fe ff\"     => 4 ,\n        \"ff fe 00 00\"     => 4 ,\n        \"2b 2f 76 38\"     => 4 ,\n        \"2b 2f 76 39\"     => 4 ,\n        \"2b 2f 76 2b\"     => 4 ,\n        \"2b 2f 76 2f\"     => 4 ,\n        \"dd 73 66 73\"     => 4 ,\n        \"84 31 95 33\"     => 4 ,\n        \"2b 2f 76 38 2d\"  => 5 ,\n        );\n\n    print \"-> read_file($file)\\n\" if $opt_v > 2;\n    my @lines = ();\n    my $IN = new IO::File $file, \"r\";\n    if (defined $IN) {\n        @lines = <$IN>;\n        $IN->close;\n        if ($lines[$#lines]) {  # test necessary for zero content files\n                                # (superfluous?)\n            # Some files don't end with a new line.  Force this:\n            $lines[$#lines] .= \"\\n\" unless $lines[$#lines] =~ m/\\n$/;\n        }\n    } else {\n        warn \"Unable to read $file\\n\";\n    }\n\n    # Are first few characters of the file Unicode Byte Order\n    # Marks (http://en.wikipedia.org/wiki/Byte_Order_Mark)?\n    # If yes, remove them.\n    if (@lines) {\n        my @chrs   = split('', $lines[0]);\n        my $n_chrs = scalar @chrs;\n        my ($n2, $n3, $n4, $n5) = ('', '', '', '');\n        $n2 = sprintf(\"%x %x\", map  ord, @chrs[0,1]) if $n_chrs >= 2;\n        $n3 = sprintf(\"%s %x\", $n2, ord  $chrs[2])   if $n_chrs >= 3;\n        $n4 = sprintf(\"%s %x\", $n3, ord  $chrs[3])   if $n_chrs >= 4;\n        $n5 = sprintf(\"%s %x\", $n4, ord  $chrs[4])   if $n_chrs >= 5;\n        if      (defined $BoM{$n2}) { $lines[0] = substr $lines[0], 2;\n        } elsif (defined $BoM{$n3}) { $lines[0] = substr $lines[0], 3;\n        } elsif (defined $BoM{$n4}) { $lines[0] = substr $lines[0], 4;\n        } elsif (defined $BoM{$n5}) { $lines[0] = substr $lines[0], 5;\n        }\n    }\n\n    # Trim DOS line endings.  This allows Windows files\n    # to be diff'ed with Unix files without line endings\n    # causing every line to differ.\n    foreach (@lines) { s/\\cM$// }\n\n    print \"<- read_file\\n\" if $opt_v > 2;\n    return @lines;\n} # 1}}}\nsub rm_blanks {                              # {{{1\n    my ($ra_in    ,\n        $language ,\n        $rh_EOL_continuation_re) = @_;\n    print \"-> rm_blanks(language=$language)\\n\" if $opt_v > 2;\n#print \"rm_blanks: language = [$language]\\n\";\n    my @out = ();\n    if ($language eq \"COBOL\") {\n        @out = remove_cobol_blanks($ra_in);\n    } else {\n        # removes blank lines\n        if (defined $rh_EOL_continuation_re->{$language}) {\n            @out = remove_matches_2re($ra_in, '^\\s*$',\n                                      $rh_EOL_continuation_re->{$language});\n        } else {\n            @out = remove_matches($ra_in, '^\\s*$');\n        }\n    }\n\n    print \"<- rm_blanks(language=$language)\\n\" if $opt_v > 2;\n    return @out;\n} # 1}}}\nsub rm_comments {                            # {{{1\n    my ($ra_lines , # in, must be free of blank lines\n        $language , # in\n        $file     , # in (some language counters, eg Haskell, need\n                    #     access to the original file)\n        $rh_EOL_continuation_re , # in\n       ) = @_;\n    print \"-> rm_comments(file=$file)\\n\" if $opt_v > 2;\n    my @routines       = @{$Filters_by_Language{$language}};\n    my @lines          = @{$ra_lines};\n    my @original_lines = @{$ra_lines};\n\n    if (!scalar @original_lines) {\n        return @lines;\n    }\n\n    foreach my $call_string (@routines) {\n        my $subroutine = $call_string->[0];\n        if (! defined &{$subroutine}) {\n            warn \"rm_comments undefined subroutine $subroutine for $file\\n\";\n            next;\n        }\n        print \"rm_comments file=$file sub=$subroutine\\n\" if $opt_v > 1;\n        my @args  = @{$call_string};\n        shift @args; # drop the subroutine name\n        if (@args and $args[0] eq '>filename<') {\n            shift   @args;\n            unshift @args, $file;\n        }\n#use Data::Dumper;\n#print \"\\ncall_string=\", Dumper($call_string);\n#print \"args=\\n\";\n#print Dumper(\\@args);\n#print \"lines before=\\n\";\n#print Dumper(\\@lines);\n\n        no strict 'refs';\n        @lines = &{$subroutine}(\\@lines, @args);   # apply filter...\n\n#print \"lines after=\\n\";\n#print Dumper(\\@lines);\n\n        print_lines($file, \"After $subroutine(@args)\", \\@lines)\n            if $opt_print_filter_stages;\n        # then remove blank lines which are created by comment removal\n        if (defined $rh_EOL_continuation_re->{$language}) {\n            @lines = remove_matches_2re(\\@lines, '^\\s*$',\n                                        $rh_EOL_continuation_re->{$language});\n        } else {\n            @lines = remove_matches(\\@lines, '^\\s*$');\n        }\n\n        print_lines($file, \"post $subroutine(@args) blank cleanup:\", \\@lines)\n            if $opt_print_filter_stages;\n    }\n    # Exception for scripting languages:  treat the first #! line as code.\n    # Will need to add it back in if it was removed earlier.\n    if (defined $Script_Language{$language} and\n        $original_lines[0] =~ /^#!/ and\n        (scalar(@lines) == 0 or\n         $lines[0] ne $original_lines[0])) {\n        unshift @lines, $original_lines[0];  # add the first line back\n    }\n\n    foreach (@lines) { chomp }   # make sure no spurious newlines were added\n\n    print \"<- rm_comments\\n\" if $opt_v > 2;\n    return @lines;\n} # 1}}}\nsub remove_f77_comments {                    # {{{1\n    my ($ra_lines, ) = @_;\n    print \"-> remove_f77_comments\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    foreach (@{$ra_lines}) {\n        next if m{^[*cC]};\n        next if m{^\\s*!};\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_f77_comments\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_f90_comments {                    # {{{1\n    # derived from SLOCCount\n    my ($ra_lines, ) = @_;\n    print \"-> remove_f90_comments\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    foreach (@{$ra_lines}) {\n        # a comment is              m/^\\s*!/\n        # an empty line is          m/^\\s*$/\n        # a HPF statement is        m/^\\s*!hpf\\$/i\n        # an Open MP statement is   m/^\\s*!omp\\$/i\n        if (! m/^(\\s*!|\\s*$)/ || m/^\\s*!(hpf|omp)\\$/i) {\n            push @save_lines, $_;\n        }\n    }\n\n    print \"<- remove_f90_comments\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_matches {                         # {{{1\n    my ($ra_lines, # in\n        $pattern , # in   Perl regular expression (case insensitive)\n       ) = @_;\n    print \"-> remove_matches(pattern=$pattern)\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    foreach (@{$ra_lines}) {\n#chomp;\n#print \"remove_matches [$pattern] [$_]\\n\";\n        next if m{$pattern}i;\n#       s{$pattern}{}i;\n#       next unless /\\S/; # at least one non space\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_matches\\n\" if $opt_v > 2;\n#print \"remove_matches returning\\n   \", join(\"\\n   \", @save_lines), \"\\n\";\n    return @save_lines;\n} # 1}}}\nsub remove_matches_2re {                     # {{{1\n    my ($ra_lines, # in\n        $pattern1, # in Perl regex 1 (case insensitive) to match\n        $pattern2, # in Perl regex 2 (case insensitive) to not match prev line\n       ) = @_;\n    print \"-> remove_matches_2re(pattern=$pattern1,$pattern2)\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    for (my $i = 0; $i < scalar @{$ra_lines}; $i++) {\n#       chomp($ra_lines->[$i]);\n#print \"remove_matches_2re [$pattern1] [$pattern2] [$ra_lines->[$i]]\\n\";\n        if ($i) {\n#print \"remove_matches_2re prev=[$ra_lines->[$i-1]] this=[$ra_lines->[$i]]\\n\";\n            next if ($ra_lines->[$i]   =~ m{$pattern1}i) and\n                    ($ra_lines->[$i-1] !~ m{$pattern2}i);\n        } else {\n            # on first line\n            next if $ra_lines->[$i]   =~  m{$pattern1}i;\n        }\n        push @save_lines, $ra_lines->[$i];\n    }\n\n    print \"<- remove_matches_2re\\n\" if $opt_v > 2;\n#print \"remove_matches_2re returning\\n   \", join(\"\\n   \", @save_lines), \"\\n\";\n    return @save_lines;\n} # 1}}}\nsub remove_inline {                          # {{{1\n    my ($ra_lines, # in\n        $pattern , # in   Perl regular expression (case insensitive)\n       ) = @_;\n    print \"-> remove_inline(pattern=$pattern)\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    unless ($opt_inline) {\n        return @{$ra_lines};\n    }\n    my $nLines_affected = 0;\n    foreach (@{$ra_lines}) {\n#chomp; print \"remove_inline [$pattern] [$_]\\n\";\n        if (m{$pattern}i) {\n            ++$nLines_affected;\n            s{$pattern}{}i;\n        }\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_inline\\n\" if $opt_v > 2;\n#print \"remove_inline returning\\n   \", join(\"\\n   \", @save_lines), \"\\n\";\n    return @save_lines;\n} # 1}}}\nsub remove_above {                           # {{{1\n    my ($ra_lines, $marker, ) = @_;\n    print \"-> remove_above(marker=$marker)\\n\" if $opt_v > 2;\n\n    # Make two passes through the code:\n    # 1. check if the marker exists\n    # 2. remove anything above the marker if it exists,\n    #    do nothing if the marker does not exist\n\n    # Pass 1\n    my $found_marker = 0;\n    for (my $line_number  = 1;\n            $line_number <= scalar @{$ra_lines};\n            $line_number++) {\n        if ($ra_lines->[$line_number-1] =~ m{$marker}) {\n            $found_marker = $line_number;\n            last;\n        }\n    }\n\n    # Pass 2 only if needed\n    my @save_lines = ();\n    if ($found_marker) {\n        my $n = 1;\n        foreach (@{$ra_lines}) {\n            push @save_lines, $_\n                if $n >= $found_marker;\n            ++$n;\n        }\n    } else { # marker wasn't found; save all lines\n        foreach (@{$ra_lines}) {\n            push @save_lines, $_;\n        }\n    }\n\n    print \"<- remove_above\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_below {                           # {{{1\n    my ($ra_lines, $marker, ) = @_;\n    print \"-> remove_below(marker=$marker)\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    foreach (@{$ra_lines}) {\n        last if m{$marker};\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_below\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_below_above {                     # {{{1\n    my ($ra_lines, $marker_below, $marker_above, ) = @_;\n    # delete lines delimited by start and end line markers such\n    # as Perl POD documentation\n    print \"-> remove_below_above(markerB=$marker_below, A=$marker_above)\\n\"\n        if $opt_v > 2;\n\n    my @save_lines = ();\n    my $between    = 0;\n    foreach (@{$ra_lines}) {\n        if (!$between and m{$marker_below}) {\n            $between    = 1;\n            next;\n        }\n        if ($between and m{$marker_above}) {\n            $between    = 0;\n            next;\n        }\n        next if $between;\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_below_above\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_between {                         # {{{1\n    my ($ra_lines, $marker, ) = @_;\n    # $marker must contain one of the balanced pairs understood\n    # by Regexp::Common::balanced, namely\n    # '{}'  '()'  '[]'  or  '<>'\n\n    print \"-> remove_between(marker=$marker)\\n\" if $opt_v > 2;\n    my %acceptable = ('{}'=>1,  '()'=>1,  '[]'=>1,  '<>'=>1, );\n    die \"remove_between:  invalid delimiter '$marker'\\n\",\n        \"the delimiter must be one of these four pairs:\\n\",\n        \"{}  ()  []  <>\\n\" unless\n        $acceptable{$marker};\n\n    Install_Regexp_Common() unless $HAVE_Rexexp_Common;\n\n    my $all_lines = join(\"\", @{$ra_lines});\n\n    no strict 'vars';\n    # otherwise get:\n    #  Global symbol \"%RE\" requires explicit package name at cloc line xx.\n    if ($all_lines =~ m/$RE{balanced}{-parens => $marker}/) {\n        no warnings;\n        $all_lines =~ s/$1//g;\n    }\n\n    print \"<- remove_between\\n\" if $opt_v > 2;\n    return split(\"\\n\", $all_lines);\n} # 1}}}\nsub remove_between_general {                 # {{{1\n    my ($ra_lines, $start_marker, $end_marker, ) = @_;\n    # Start and end markers may be any length strings.\n\n    print \"-> remove_between_general(start=$start_marker, end=$end_marker)\\n\"\n        if $opt_v > 2;\n\n    my $all_lines = join(\"\", @{$ra_lines});\n\n    my @save_lines = ();\n    my $in_comment = 0;\n    foreach (@{$ra_lines}) {\n\n        next if /^\\s*$/;\n        s/\\Q$start_marker\\E.*?\\Q$end_marker\\E//g;  # strip one-line comments\n        next if /^\\s*$/;\n        if ($in_comment) {\n            if (/\\Q$end_marker\\E/) {\n                s/^.*?\\Q$end_marker\\E//;\n                $in_comment = 0;\n            }\n            next if $in_comment;\n        }\n        next if /^\\s*$/;\n        $in_comment = 1 if /^(.*?)\\Q$start_marker\\E/; # $1 may be blank or code\n        next if defined $1 and $1 =~ /^\\s*$/; # leading blank; all comment\n        if ($in_comment) {\n            # part code, part comment; strip the comment and keep the code\n            s/^(.*?)\\Q$start_marker\\E.*$/$1/;\n        }\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_between_general\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_between_regex   {                 # {{{1\n    my ($ra_lines, $start_RE, $end_RE, ) = @_;\n    # Start and end regex's may be any length strings.\n\n    print \"-> remove_between_regex(start=$start_RE, end=$end_RE)\\n\"\n        if $opt_v > 2;\n\n    my $all_lines = join(\"\", @{$ra_lines});\n\n    my @save_lines = ();\n    my $in_comment = 0;\n    foreach (@{$ra_lines}) {\n\n        next if /^\\s*$/;\n        s/${start_RE}.*?${end_RE}//g;  # strip one-line comments\n        next if /^\\s*$/;\n        if ($in_comment) {\n            if (/$end_RE/) {\n                s/^.*?${end_RE}//;\n                $in_comment = 0;\n            }\n            next if $in_comment;\n        }\n        next if /^\\s*$/;\n        $in_comment = 1 if /^(.*?)${start_RE}/; # $1 may be blank or code\n        next if defined $1 and $1 =~ /^\\s*$/; # leading blank; all comment\n        if ($in_comment) {\n            # part code, part comment; strip the comment and keep the code\n            s/^(.*?)${start_RE}.*$/$1/;\n        }\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_between_regex\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub replace_between_regex  {                 # {{{1\n    my ($ra_lines, $start_RE, $end_RE, $replace_RE, ) = @_;\n    # Start and end regex's may be any length strings.\n\n    print \"-> replace_between_regex(start=$start_RE, end=$end_RE)\\n\"\n        if $opt_v > 2;\n\n    my $all_lines = join(\"\", @{$ra_lines});\n\n    my @save_lines = ();\n    my $in_comment = 0;\n    foreach (@{$ra_lines}) {\n\n        next if /^\\s*$/;\n        s/${start_RE}.*?${end_RE}/${replace_RE}/eeg;  # strip one-line comments\n        next if /^\\s*$/;\n        if ($in_comment) {\n            if (/$end_RE/) {\n                s/^.*?${end_RE}/${replace_RE}/ee;\n                $in_comment = 0;\n            }\n            next if $in_comment;\n        }\n        next if /^\\s*$/;\n        $in_comment = 1 if /^(.*?)${start_RE}/; # $1 may be blank or code\n        next if defined $1 and $1 =~ /^\\s*$/; # leading blank; all comment\n        if ($in_comment) {\n            # part code, part comment; strip the comment and keep the code\n            s/^(.*?)${start_RE}.*$/$1/;\n        }\n        push @save_lines, $_;\n    }\n\n    print \"<- replace_between_regex\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_cobol_blanks {                    # {{{1\n    # subroutines derived from SLOCCount\n    my ($ra_lines, ) = @_;\n\n    my $free_format = 0;  # Support \"free format\" source code.\n    my @save_lines  = ();\n\n    foreach (@{$ra_lines}) {\n        next if m/^\\s*$/;\n        my $line = expand($_);  # convert tabs to equivalent spaces\n        $free_format = 1 if $line =~ m/^......\\$.*SET.*SOURCEFORMAT.*FREE/i;\n        if ($free_format) {\n            push @save_lines, $_;\n        } else {\n            # Greg Toth:\n            #  (1) Treat lines with any alphanum in cols 1-6 and\n            #      blanks in cols 7 through 71 as blank line, and\n            #  (2) Treat lines with any alphanum in cols 1-6 and\n            #      slash (/) in col 7 as blank line (this is a\n            #      page eject directive).\n            push @save_lines, $_ unless m/^\\d{6}\\s*$/             or\n                                        ($line =~ m/^.{6}\\s{66}/) or\n                                        ($line =~ m/^......\\//);\n        }\n    }\n    return @save_lines;\n} # 1}}}\nsub remove_cobol_comments {                  # {{{1\n    # subroutines derived from SLOCCount\n    my ($ra_lines, ) = @_;\n\n    my $free_format = 0;  # Support \"free format\" source code.\n    my @save_lines  = ();\n\n    foreach (@{$ra_lines}) {\n        if (m/^......\\$.*SET.*SOURCEFORMAT.*FREE/i) {$free_format = 1;}\n        if ($free_format) {\n            push @save_lines, $_ unless m{^\\s*\\*};\n        } else {\n            push @save_lines, $_ unless m{^......\\*} or m{^\\*};\n        }\n    }\n    return @save_lines;\n} # 1}}}\nsub remove_jcl_comments {                    # {{{1\n    my ($ra_lines, ) = @_;\n\n    print \"-> remove_jcl_comments\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    my $in_comment = 0;\n    foreach (@{$ra_lines}) {\n        next if /^\\s*$/;\n        next if m{^\\s*//\\*};\n        last if m{^\\s*//\\s*$};\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_jcl_comments\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_jsp_comments {                    # {{{1\n    #  JSP comment is   <%--  body of comment   --%>\n    my ($ra_lines, ) = @_;\n\n    print \"-> remove_jsp_comments\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    my $in_comment = 0;\n    foreach (@{$ra_lines}) {\n\n        next if /^\\s*$/;\n        s/<\\%\\-\\-.*?\\-\\-\\%>//g;  # strip one-line comments\n        next if /^\\s*$/;\n        if ($in_comment) {\n            if (/\\-\\-\\%>/) {\n                s/^.*?\\-\\-\\%>//;\n                $in_comment = 0;\n            }\n        }\n        next if /^\\s*$/;\n        $in_comment = 1 if /^(.*?)<\\%\\-\\-/;\n        next if defined $1 and $1 =~ /^\\s*$/;\n        next if ($in_comment);\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_jsp_comments\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_html_comments {                   # {{{1\n    #  HTML comment is   <!--  body of comment   -->\n    #  Need to use my own routine until the HTML comment regex in\n    #  the Regexp::Common module can handle  <!--  --  -->\n    my ($ra_lines, ) = @_;\n\n    print \"-> remove_html_comments\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    my $in_comment = 0;\n    foreach (@{$ra_lines}) {\n\n        next if /^\\s*$/;\n        s/<!\\-\\-.*?\\-\\->//g;  # strip one-line comments\n        next if /^\\s*$/;\n        if ($in_comment) {\n            if (/\\-\\->/) {\n                s/^.*?\\-\\->//;\n                $in_comment = 0;\n            }\n        }\n        next if /^\\s*$/;\n        $in_comment = 1 if /^(.*?)<!\\-\\-/;\n        next if defined $1 and $1 =~ /^\\s*$/;\n        next if ($in_comment);\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_html_comments\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_bf_comments {                     # {{{1\n    my ($ra_lines, ) = @_;\n\n    print \"-> remove_bf_comments\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    my $in_comment = 0;\n    foreach (@{$ra_lines}) {\n\n        s/[^<>+-.,\\[\\]]+//g;\n        next if /^\\s*$/;\n        push @save_lines, $_;\n    }\n\n    print \"<- remove_bf_comments\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub really_is_bf {                           # {{{1\n    my ($file, ) = @_;\n\n    print \"-> really_is_bf\\n\" if $opt_v > 2;\n    my $n_bf_indicators  = 0;\n    my @lines = read_file($file);\n    foreach my $L (@lines) {\n        my $ind = 0;\n        if ($L =~ /([+-]{4,}  |          # at least four +'s or -'s in a row\n                   [\\[\\]]{4,} |          # at least four [ or ] in a row\n                   [<>][+-]   |          # >- or >+ or <+ or <-\n                   <{3,}      |          # at least three < in a row\n                   ^\\s*[\\[\\]]\\s*$)/x) {  # [ or ] on line by itself\n            ++$n_bf_indicators;\n            $ind = 1;\n        }\n        # if ($ind) { print \"YES: $L\"; } else { print \"NO : $L\"; }\n    }\n    my $ratio = $n_bf_indicators/scalar(@lines);\n    my $decision = ($ratio > 0.5) || ($n_bf_indicators > 5);\n    printf \"<- really_is_bf(Y/N=%d %s, R=%.3f, N=%d)\\n\",\n            $decision, $file, $ratio, $n_bf_indicators if $opt_v > 2;\n    return $decision;\n} # 1}}}\nsub remove_intented_block {                  # {{{1\n    # Haml block comments are defined by a silent comment marker like\n    #    /\n    # or\n    #    -#\n    # followed by indented text on subsequent lines.\n    # http://haml.info/docs/yardoc/file.REFERENCE.html#comments\n    my ($ra_lines, $regex, ) = @_;\n\n    print \"-> remove_intented_block\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    my $in_comment = 0;\n    foreach (@{$ra_lines}) {\n\n        next if /^\\s*$/;\n        my $line = expand($_);  # convert tabs to equivalent spaces\n        if ($in_comment) {\n            $line =~ /^(\\s*)/;\n            # print \"indent=\", length $1, \"\\n\";\n            if (length $1 < $in_comment) {\n                # indent level is less than comment level\n                # are back in code\n                $in_comment = 0;\n            } else {\n                # still in comments, don't use this line\n                next;\n            }\n        } elsif ($line =~ m{$regex}) {\n            if ($1) {\n                $in_comment = length($1) + 1; # number of leading spaces + 1\n            } else {\n                $in_comment = 1;\n            }\n            # print \"in_comment=$in_comment\\n\";\n            next;\n        }\n        push @save_lines, $line;\n    }\n\n    print \"<- remove_intented_block\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub remove_haml_block {                      # {{{1\n    # Haml block comments are defined by a silent comment marker like\n    #    /\n    # or\n    #    -#\n    # followed by indented text on subsequent lines.\n    # http://haml.info/docs/yardoc/file.REFERENCE.html#comments\n    my ($ra_lines, ) = @_;\n\n    return remove_intented_block($ra_lines, '^(\\s*)(/|-#)\\s*$');\n\n} # 1}}}\nsub remove_pug_block {                       # {{{1\n    # Haml block comments are defined by a silent comment marker like\n    #    //\n    # followed by indented text on subsequent lines.\n    # http://jade-lang.com/reference/comments/\n    my ($ra_lines, ) = @_;\n    return remove_intented_block($ra_lines, '^(\\s*)(//)\\s*$');\n} # 1}}}\nsub remove_slim_block {                      # {{{1\n    # slim comments start with /\n    # followed by indented text on subsequent lines.\n    # http://www.rubydoc.info/gems/slim/frames\n    my ($ra_lines, ) = @_;\n    return remove_intented_block($ra_lines, '^(\\s*)(/[^!])');\n} # 1}}}\nsub add_newlines {                           # {{{1\n    my ($ra_lines, ) = @_;\n    print \"-> add_newlines \\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    foreach (@{$ra_lines}) {\n\n        push @save_lines, \"$_\\n\";\n    }\n\n    print \"<- add_newlines \\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub docstring_to_C {                         # {{{1\n    my ($ra_lines, ) = @_;\n    # Converts Python docstrings to C comments.\n\n    print \"-> docstring_to_C()\\n\" if $opt_v > 2;\n\n    my $in_docstring = 0;\n    foreach (@{$ra_lines}) {\n        while (/\"\"\"/) {\n            if (!$in_docstring) {\n                s{[uU]?\"\"\"}{/*};\n                $in_docstring = 1;\n            } else {\n                s{\"\"\"}{*/};\n                $in_docstring = 0;\n            }\n        }\n    }\n\n    print \"<- docstring_to_C\\n\" if $opt_v > 2;\n    return @{$ra_lines};\n} # 1}}}\nsub Forth_paren_to_C  {                      # {{{1\n    my ($ra_lines, ) = @_;\n    # Converts Forth comment parentheses to C comments.\n\n    print \"-> Forth_paren_to_C()\\n\" if $opt_v > 2;\n\n    my $in_comment = 0;\n    foreach (@{$ra_lines}) {\n        while (/\\s\\(\\s/ or ($in_comment and /\\)/)) {\n            if (/\\s\\(\\s.*?\\)/) {\n                # in-line parenthesis comment; handle here\n                s/\\s+\\(\\s+.*?\\)//g;\n            } elsif (!$in_comment and /\\s\\(\\s/) {\n                s{\\s+\\(\\s+}{/*};\n                $in_comment = 1;\n            } elsif ($in_comment and /\\)/) {\n                s{\\)}{*/};\n                $in_comment = 0;\n            }\n        }\n    }\n\n    print \"<- Forth_paren_to_C\\n\" if $opt_v > 2;\n    return @{$ra_lines};\n} # 1}}}\nsub powershell_to_C {                        # {{{1\n    my ($ra_lines, ) = @_;\n    # Converts PowerShell block comment markers to C comments.\n\n    print \"-> powershell_to_C()\\n\" if $opt_v > 2;\n\n    my $in_docstring = 0;\n    foreach (@{$ra_lines}) {\n        s{<#}{/*}g;\n        s{#>}{*/}g;\n    }\n\n    print \"<- powershell_to_C\\n\" if $opt_v > 2;\n    return @{$ra_lines};\n} # 1}}}\nsub smarty_to_C {                            # {{{1\n    my ($ra_lines, ) = @_;\n    # Converts Smarty comments to C comments.\n\n    print \"-> smarty_to_C()\\n\" if $opt_v > 2;\n\n    foreach (@{$ra_lines}) {\n        s[{\\*][/*]g;\n        s[\\*}][*/]g;\n    }\n\n    print \"<- smarty_to_C\\n\" if $opt_v > 2;\n    return @{$ra_lines};\n} # 1}}}\nsub determine_lit_type {                     # {{{1\n  my ($file) = @_;\n\n  open (FILE, $file);\n  while (<FILE>) {\n    if (m/^\\\\begin\\{code\\}/) { close FILE; return 2; }\n    if (m/^>\\s/) { close FILE; return 1; }\n  }\n\n  return 0;\n} # 1}}}\nsub remove_haskell_comments {                # {{{1\n    # Bulk of code taken from SLOCCount's haskell_count script.\n    # Strips out {- .. -} and -- comments and counts the rest.\n    # Pragmas, {-#...}, are counted as SLOC.\n    # BUG: Doesn't handle strings with embedded block comment markers gracefully.\n    #      In practice, that shouldn't be a problem.\n    my ($ra_lines, $file, ) = @_;\n\n    print \"-> remove_haskell_comments\\n\" if $opt_v > 2;\n\n    my @save_lines = ();\n    my $in_comment = 0;\n    my $incomment  = 0;\n    my ($literate, $inlitblock) = (0,0);\n\n    $literate = 1 if $file =~ /\\.lhs$/;\n    if($literate) { $literate = determine_lit_type($file) }\n\n    foreach (@{$ra_lines}) {\n        if ($literate == 1) {\n            if (!s/^>//) { s/.*//; }\n        } elsif ($literate == 2) {\n            if ($inlitblock) {\n                if (m/^\\\\end\\{code\\}/) { s/.*//; $inlitblock = 0; }\n            } elsif (!$inlitblock) {\n                if (m/^\\\\begin\\{code\\}/) { s/.*//; $inlitblock = 1; }\n                else { s/.*//; }\n            }\n        }\n\n        if ($incomment) {\n            if (m/\\-\\}/) { s/^.*?\\-\\}//;  $incomment = 0;}\n            else { s/.*//; }\n        }\n        if (!$incomment) {\n            s/--.*//;\n            s!{-[^#].*?-}!!g;\n            if (m/{-/ && (!m/{-#/)) {\n              s/{-.*//;\n              $incomment = 1;\n            }\n        }\n        if (m/\\S/) { push @save_lines, $_; }\n    }\n#   if ($incomment) {print \"ERROR: ended in comment in $ARGV\\n\";}\n\n    print \"<- remove_haskell_comments\\n\" if $opt_v > 2;\n    return @save_lines;\n} # 1}}}\nsub print_lines {                            # {{{1\n    my ($file     , # in\n        $title    , # in\n        $ra_lines , # in\n       ) = @_;\n    printf \"->%-30s %s\\n\", $file, $title;\n    for (my $i = 0; $i < scalar @{$ra_lines}; $i++) {\n        printf \"%5d | %s\", $i+1, $ra_lines->[$i];\n        print \"\\n\" unless $ra_lines->[$i] =~ m{\\n$}\n    }\n} # 1}}}\nsub set_constants {                          # {{{1\n    my ($rh_Language_by_Extension , # out\n        $rh_Language_by_Script    , # out\n        $rh_Language_by_File      , # out\n        $rhaa_Filters_by_Language , # out\n        $rh_Not_Code_Extension    , # out\n        $rh_Not_Code_Filename     , # out\n        $rh_Scale_Factor          , # out\n        $rh_Known_Binary_Archives , # out\n        $rh_EOL_continuation_re   , # out\n       ) = @_;\n# 1}}}\n%{$rh_Language_by_Extension} = (             # {{{1\n            'abap'        => 'ABAP'                  ,\n            'ac'          => 'm4'                    ,\n            'ada'         => 'Ada'                   ,\n            'adb'         => 'Ada'                   ,\n            'ads'         => 'Ada'                   ,\n            'adso'        => 'ADSO/IDSM'             ,\n            'ahk'         => 'AutoHotkey'            ,\n            'aj'          => 'AspectJ'               ,\n            'am'          => 'make'                  ,\n            'ample'       => 'AMPLE'                 ,\n            'as'          => 'ActionScript'          ,\n            'dofile'      => 'AMPLE'                 ,\n            'startup'     => 'AMPLE'                 ,\n            'asa'         => 'ASP'                   ,\n            'asax'        => 'ASP.Net'               ,\n            'ascx'        => 'ASP.Net'               ,\n            'asm'         => 'Assembly'              ,\n            'asmx'        => 'ASP.Net'               ,\n            'asp'         => 'ASP'                   ,\n            'aspx'        => 'ASP.Net'               ,\n            'master'      => 'ASP.Net'               ,\n            'sitemap'     => 'ASP.Net'               ,\n            'cshtml'      => 'Razor'                 ,\n            'awk'         => 'awk'                   ,\n            'bash'        => 'Bourne Again Shell'    ,\n            'bas'         => 'Visual Basic'          ,\n            'dxl'         => 'DOORS Extension Language',\n            'bat'         => 'DOS Batch'             ,\n            'BAT'         => 'DOS Batch'             ,\n            'cmd'         => 'DOS Batch'             ,\n            'CMD'         => 'DOS Batch'             ,\n            'btm'         => 'DOS Batch'             ,\n            'BTM'         => 'DOS Batch'             ,\n            'blade.php'   => 'Blade'                 ,\n            'build.xml'   => 'Ant'                   ,\n            'b'           => 'Brainfuck'             ,\n            'bf'          => 'Brainfuck'             ,\n            'cbl'         => 'COBOL'                 ,\n            'CBL'         => 'COBOL'                 ,\n            'c'           => 'C'                     ,\n            'C'           => 'C++'                   ,\n            'cc'          => 'C++'                   ,\n            'c++'         => 'C++'                   ,\n            'ccs'         => 'CCS'                   ,\n            'cfc'         => 'ColdFusion CFScript'   ,\n            'cfm'         => 'ColdFusion'            ,\n            'cl'          => 'Lisp/OpenCL'           ,\n            'clj'         => 'Clojure'               ,\n            'cljs'        => 'ClojureScript'         ,\n            'cljc'        => 'ClojureC'              ,\n            'cls'         => 'Visual Basic'          , # also Apex Class\n            'CMakeLists.txt' => 'CMake'              ,\n            'cmake'       => 'CMake'                 ,\n            'cob'         => 'COBOL'                 ,\n            'COB'         => 'COBOL'                 ,\n            'coffee'      => 'CoffeeScript'          ,\n            'component'   => 'Visualforce Component' ,\n            'cpp'         => 'C++'                   ,\n            'cr'          => 'Crystal'               ,\n            'cs'          => 'C#'                    ,\n            'csh'         => 'C Shell'               ,\n            'cson'        => 'CSON'                  ,\n            'css'         => \"CSS\"                   ,\n            'ctl'         => 'Visual Basic'          ,\n            'cu'          => 'CUDA'                  ,\n            'cuh'         => 'CUDA'                  , # CUDA header file\n            'cxx'         => 'C++'                   ,\n            'd'           => 'D/dtrace'              ,\n# in addition, .d can map to init.d files typically written as\n# bash or sh scripts\n            'da'          => 'DAL'                   ,\n            'dart'        => 'Dart'                  ,\n            'def'         => 'Windows Module Definition',\n            'diff'        => 'diff'                  ,\n            'dmap'        => 'NASTRAN DMAP'          ,\n            'dpr'         => 'Pascal'                ,\n            'dita'        => 'DITA'                  ,\n            'dsr'         => 'Visual Basic'          ,\n            'dtd'         => 'DTD'                   ,\n            'ec'          => 'C'                     ,\n            'ecpp'        => 'ECPP'                  ,\n            'eex'         => 'EEx'                   ,\n            'el'          => 'Lisp'                  ,\n            'elm'         => 'Elm'                   ,\n            'exs'         => 'Elixir'                ,\n            'ex'          => 'Elixir'                ,\n            'erb'         => 'ERB'                   ,\n            'ERB'         => 'ERB'                   ,\n            'erl'         => 'Erlang'                ,\n            'exp'         => 'Expect'                ,\n            '4th'         => 'Forth'                 ,\n            'forth'       => 'Forth'                 ,\n            'fr'          => 'Forth'                 ,\n            'frt'         => 'Forth'                 ,\n            'fth'         => 'Forth'                 ,\n            'f83'         => 'Forth'                 ,\n            'fb'          => 'Forth'                 ,\n            'fpm'         => 'Forth'                 ,\n            'e4'          => 'Forth'                 ,\n            'rx'          => 'Forth'                 ,\n            'ft'          => 'Forth'                 ,\n            'f77'         => 'Fortran 77'            ,\n            'F77'         => 'Fortran 77'            ,\n            'f90'         => 'Fortran 90'            ,\n            'F90'         => 'Fortran 90'            ,\n            'f95'         => 'Fortran 95'            ,\n            'F95'         => 'Fortran 95'            ,\n            'f'           => 'Fortran 77/Forth'      ,\n            'F'           => 'Fortran 77'            ,\n            'for'         => 'Fortran 77/Forth'      ,\n            'FOR'         => 'Fortran 77'            ,\n            'ftl'         => 'Freemarker Template'   ,\n            'ftn'         => 'Fortran 77'            ,\n            'FTN'         => 'Fortran 77'            ,\n            'fmt'         => 'Oracle Forms'          ,\n            'focexec'     => 'Focus'                 ,\n            'frm'         => 'Visual Basic'          ,\n            'fs'          => 'F#/Forth'              ,\n            'fsi'         => 'F#'                    ,\n            'g'           => 'Antlr'                 ,\n            'gnumakefile' => 'make'                  ,\n            'Gnumakefile' => 'make'                  ,\n            'gd'          => 'GDScript'              ,\n            'glsl'        => 'GLSL'                  ,\n\t\t\t'vert'        => 'GLSL'                  ,\n\t\t\t'tesc'        => 'GLSL'                  ,\n\t\t\t'tese'        => 'GLSL'                  ,\n\t\t\t'geom'        => 'GLSL'                  ,\n\t\t\t'frag'        => 'GLSL'                  ,\n\t\t\t'comp'        => 'GLSL'                  ,\n            'go'          => 'Go'                    ,\n            'gsp'         => 'Grails'                ,\n            'groovy'      => 'Groovy'                ,\n            'gant'        => 'Groovy'                ,\n            'gradle'      => 'Groovy'                ,\n            'h'           => 'C/C++ Header'          ,\n            'H'           => 'C/C++ Header'          ,\n            'hh'          => 'C/C++ Header'          ,\n            'hpp'         => 'C/C++ Header'          ,\n            'hxx'         => 'C/C++ Header'          ,\n            'hb'          => 'Harbour'               ,\n            'hrl'         => 'Erlang'                ,\n            'hs'          => 'Haskell'               ,\n            'hlsl'        => 'HLSL'                  ,\n            'shader'      => 'HLSL'                  ,\n            'cg'          => 'HLSL'                  ,\n            'cginc'       => 'HLSL'                  ,\n            'haml'        => 'Haml'                  ,\n            'handlebars'  => 'Handlebars'            ,\n            'hbs'         => 'Handlebars'            ,\n            'hx'          => 'Haxe'                  ,\n            'htm'         => 'HTML'                  ,\n            'html'        => 'HTML'                  ,\n            'i3'          => 'Modula3'               ,\n            'ice'         => 'Slice'                 ,\n            'icl'         => 'Clean'                 ,\n            'dcl'         => 'Clean'                 ,\n            'idl'         => 'IDL'                   ,\n            'ini'         => 'INI'                   ,\n            'ism'         => 'InstallShield'         ,\n            'pro'         => 'IDL/Qt Project/Prolog' ,\n            'ig'          => 'Modula3'               ,\n            'il'          => 'SKILL'                 ,\n            'ils'         => 'SKILL++'               ,\n            'inc'         => 'PHP/Pascal'            , # might be PHP or Pascal\n            'ino'         => 'Arduino Sketch'        ,\n            'pde'         => 'Arduino Sketch'        , # pre 1.0\n            'itk'         => 'Tcl/Tk'                ,\n            'java'        => 'Java'                  ,\n            'jcl'         => 'JCL'                   , # IBM Job Control Lang.\n            'jl'          => 'Lisp/Julia'            ,\n            'js'          => 'JavaScript'            ,\n            'es6'         => 'JavaScript'            ,\n            'jsf'         => 'JavaServer Faces'      ,\n            'jsx'         => 'JSX'                   ,\n            'xhtml'       => 'XHTML'                 ,\n            'json'        => 'JSON'                  ,\n            'jsp'         => 'JSP'                   , # Java server pages\n            'jspf'        => 'JSP'                   , # Java server pages\n            'vm'          => 'Velocity Template Language' ,\n            'ksc'         => 'Kermit'                ,\n            'ksh'         => 'Korn Shell'            ,\n            'kt'          => 'Kotlin'                ,\n            'kts'         => 'Kotlin'                ,\n            'lhs'         => 'Haskell'               ,\n            'l'           => 'lex'                   ,\n            'less'        => 'LESS'                  ,\n            'lfe'         => 'LFE'                   ,\n            'liquid'      => 'liquid'                ,\n            'lsp'         => 'Lisp'                  ,\n            'lisp'        => 'Lisp'                  ,\n            'lgt'         => 'Logtalk'               ,\n            'logtalk'     => 'Logtalk'               ,\n            'lua'         => 'Lua'                   ,\n            'm3'          => 'Modula3'               ,\n            'm4'          => 'm4'                    ,\n            'makefile'    => 'make'                  ,\n            'Makefile'    => 'make'                  ,\n            'mako'        => 'Mako'                  ,\n            'md'          => 'Markdown'              ,\n            'mc'          => 'Windows Message File'  ,\n            'met'         => 'Teamcenter met'        ,\n            'mg'          => 'Modula3'               ,\n            'mk'          => 'make'                  ,\n#           'mli'         => 'ML'                    , # ML not implemented\n#           'ml'          => 'ML'                    ,\n            'ml'          => 'OCaml'                 ,\n            'mli'         => 'OCaml'                 ,\n            'mly'         => 'OCaml'                 ,\n            'mll'         => 'OCaml'                 ,\n            'm'           => 'MATLAB/Mathematica/Objective C/MUMPS/Mercury' ,\n            'mm'          => 'Objective C++'         ,\n            'mt'          => 'Mathematica'           ,\n            'wl'          => 'Mathematica'           ,\n            'wlt'         => 'Mathematica'           ,\n            'mustache'    => 'Mustache'              ,\n            'wdproj'      => 'MSBuild script'        ,\n            'csproj'      => 'MSBuild script'        ,\n            'vcproj'      => 'MSBuild script'        ,\n            'wixproj'     => 'MSBuild script'        ,\n            'vbproj'      => 'MSBuild script'        ,\n            'mps'         => 'MUMPS'                 ,\n            'mth'         => 'Teamcenter mth'        ,\n            'n'           => 'Nemerle'               ,\n            'nim'         => 'Nim'                   ,\n            'oscript'     => 'LiveLink OScript'      ,\n            'pad'         => 'Ada'                   , # Oracle Ada preprocessor\n            'page'        => 'Visualforce Page'      ,\n            'pas'         => 'Pascal'                ,\n            'pcc'         => 'C++'                   , # Oracle C++ preprocessor\n            'perl'        => 'Perl'                  ,\n            'pfo'         => 'Fortran 77'            ,\n            'pgc'         => 'C'                     , # Postgres embedded C/C++\n            'php3'        => 'PHP'                   ,\n            'php4'        => 'PHP'                   ,\n            'php5'        => 'PHP'                   ,\n            'php'         => 'PHP'                   ,\n            'phtml'       => 'PHP'                   ,\n            'pig'         => 'Pig Latin'             ,\n            'plh'         => 'Perl'                  ,\n            'pl'          => 'Perl/Prolog'           ,\n            'p6'          => 'Perl/Prolog'           ,\n            'PL'          => 'Perl/Prolog'           ,\n            'plx'         => 'Perl'                  ,\n            'pm'          => 'Perl'                  ,\n            'pm6'         => 'Perl'                  ,\n            'pom.xml'     => 'Maven'                 ,\n            'pom'         => 'Maven'                 ,\n            'P'           => 'Prolog'                ,\n            'p'           => 'Pascal'                ,\n            'pp'          => 'Pascal/Puppet'         ,\n            'psql'        => 'SQL'                   ,\n            'py'          => 'Python'                ,\n            'pyj'         => 'RapydScript'           ,\n            'pyx'         => 'Cython'                ,\n            'qml'         => 'QML'                   ,\n            'rb'          => 'Ruby'                  ,\n            'rake'        => 'Ruby'                  ,\n         #  'resx'        => 'ASP.Net'               ,\n            'rex'         => 'Oracle Reports'        ,\n            'rexx'        => 'Rexx'                  ,\n            'rhtml'       => 'Ruby HTML'             ,\n            'rs'          => 'Rust'                  ,\n            's'           => 'Assembly'              ,\n            'S'           => 'Assembly'              ,\n            'SCA'         => 'Visual Fox Pro'        ,\n            'sca'         => 'Visual Fox Pro'        ,\n            'scala'       => 'Scala'                 ,\n            'sbl'         => 'Softbridge Basic'      ,\n            'SBL'         => 'Softbridge Basic'      ,\n            'sc'          => 'Lisp'                  ,\n            'scm'         => 'Lisp'                  ,\n            'sed'         => 'sed'                   ,\n            'ses'         => 'Patran Command Language'   ,\n            'pcl'         => 'Patran Command Language'   ,\n            'pl1'         => 'PL/I'                  ,\n            'po'          => 'PO File'               ,\n            'sra'         => 'PowerBuilder'          ,\n            'srf'         => 'PowerBuilder'          ,\n            'srm'         => 'PowerBuilder'          ,\n            'srs'         => 'PowerBuilder'          ,\n            'sru'         => 'PowerBuilder'          ,\n            'srw'         => 'PowerBuilder'          ,\n            'pug'         => 'Pug'                   ,\n            'purs'        => 'PureScript'            ,\n            'prefab'      => 'Unity-Prefab'          ,\n            'proto'       => 'Protocol Buffers'      ,\n            'mat'         => 'Unity-Prefab'          ,\n            'ps1'         => 'PowerShell'            ,\n            'psd1'        => 'PowerShell'            ,\n            'psm1'        => 'PowerShell'            ,\n            'R'           => 'R'                     ,\n            'r'           => 'R'                     ,\n            'rkt'         => 'Racket'                ,\n            'rktl'        => 'Racket'                ,\n            'ss'          => 'Racket'                ,\n            'scm'         => 'Racket'                ,\n            'sch'         => 'Racket'                ,\n            'scrbl'       => 'Racket'                ,\n            'tsv'         => 'RobotFramework'        ,\n            'robot'       => 'RobotFramework'        ,\n            'rc'          => 'Windows Resource File' ,\n            'rc2'         => 'Windows Resource File' ,\n            'sas'         => 'SAS'                   ,\n            'sass'        => 'Sass'                  ,\n            'scss'        => 'Sass'                  ,\n            'sh'          => 'Bourne Shell'          ,\n            'smarty'      => 'Smarty'                ,\n            'sml'         => 'Standard ML'           ,\n            'sig'         => 'Standard ML'           ,\n            'fun'         => 'Standard ML'           ,\n            'slim'        => 'Slim'                  ,\n            'e'           => 'Specman e'             ,\n            'sql'         => 'SQL'                   ,\n            'SQL'         => 'SQL'                   ,\n            'sproc.sql'   => 'SQL Stored Procedure'  ,\n            'spoc.sql'    => 'SQL Stored Procedure'  ,\n            'spc.sql'     => 'SQL Stored Procedure'  ,\n            'udf.sql'     => 'SQL Stored Procedure'  ,\n            'data.sql'    => 'SQL Data'              ,\n            'styl'        => 'Stylus'                ,\n            'sv'          => 'Verilog-SystemVerilog' ,\n            'svh'         => 'Verilog-SystemVerilog' ,\n            'v'           => 'Verilog-SystemVerilog/Coq' ,\n            'tcl'         => 'Tcl/Tk'                ,\n            'tcsh'        => 'C Shell'               ,\n            'tk'          => 'Tcl/Tk'                ,\n            'tex'         => 'TeX'                   , # TeX, LaTex, MikTex, ..\n            'sty'         => 'TeX'                   ,\n#           'cls'         => 'TeX'                   ,\n            'dtx'         => 'TeX'                   ,\n            'bst'         => 'TeX'                   ,\n            'tpl'         => 'Smarty'                ,\n            'trigger'     => 'Apex Trigger'          ,\n            'ttcn'        => 'TTCN'                  ,\n            'ttcn2'       => 'TTCN'                  ,\n            'ttcn3'       => 'TTCN'                  ,\n            'ttcnpp'      => 'TTCN'                  ,\n            'tpd'         => 'TITAN Project File Information',\n            'ts'          => 'TypeScript/Qt Linguist',\n            'tsx'         => 'TypeScript'            ,\n            'tss'         => 'Titanium Style Sheet'  ,\n            'twig'        => 'Twig'                  ,\n            'ui'          => 'Qt/Glade'              ,\n            'glade'       => 'Glade'                 ,\n            'vala'        => 'Vala'                  ,\n            'vapi'        => 'Vala Header'           ,\n            'vhd'         => 'VHDL'                  ,\n            'VHD'         => 'VHDL'                  ,\n            'vhdl'        => 'VHDL'                  ,\n            'VHDL'        => 'VHDL'                  ,\n            'vba'         => 'Visual Basic'          ,\n            'VBA'         => 'Visual Basic'          ,\n         #  'vbp'         => 'Visual Basic'          , # .vbp - autogenerated\n            'vb'          => 'Visual Basic'          ,\n            'VB'          => 'Visual Basic'          ,\n         #  'vbw'         => 'Visual Basic'          , # .vbw - autogenerated\n            'vbs'         => 'Visual Basic'          ,\n            'VBS'         => 'Visual Basic'          ,\n            'vue'         => 'Vuejs Component'       ,\n            'webinfo'     => 'ASP.Net'               ,\n            'xmi'         => 'XMI'                   ,\n            'XMI'         => 'XMI'                   ,\n            'xml'         => 'XML'                   ,\n            'xml'         => 'XML'                   ,\n            'XML'         => 'XML'                   ,\n            'mxml'        => 'MXML'                  ,\n            'xml.builder' => 'builder'               ,\n            'build'       => 'NAnt script'           ,\n            'vim'         => 'vim script'            ,\n            'swift'       => 'Swift'                 ,\n            'xaml'        => 'XAML'                  ,\n            'wxs'         => 'WiX source'            ,\n            'wxi'         => 'WiX include'           ,\n            'wxl'         => 'WiX string localization' ,\n            'prg'         => 'xBase'                 ,\n            'ch'          => 'xBase Header'          ,\n            'xq'          => 'XQuery'                ,\n            'xquery'      => 'XQuery'                ,\n            'xsd'         => 'XSD'                   ,\n            'XSD'         => 'XSD'                   ,\n            'xslt'        => 'XSLT'                  ,\n            'XSLT'        => 'XSLT'                  ,\n            'xsl'         => 'XSLT'                  ,\n            'XSL'         => 'XSLT'                  ,\n            'y'           => 'yacc'                  ,\n            'yaml'        => 'YAML'                  ,\n            'yml'         => 'YAML'                  ,\n            'zsh'         => 'zsh'                   ,\n            );\n# 1}}}\n%{$rh_Language_by_Script}    = (             # {{{1\n            'awk'      => 'awk'                   ,\n            'bash'     => 'Bourne Again Shell'    ,\n            'bc'       => 'bc'                    ,# calculator\n            'crystal'  => 'Crystal'               ,\n            'csh'      => 'C Shell'               ,\n            'dmd'      => 'D'                     ,\n            'dtrace'   => 'dtrace'                ,\n            'idl'      => 'IDL'                   ,\n            'kermit'   => 'Kermit'                ,\n            'ksh'      => 'Korn Shell'            ,\n            'lua'      => 'Lua'                   ,\n            'make'     => 'make'                  ,\n            'octave'   => 'Octave'                ,\n            'perl5'    => 'Perl'                  ,\n            'perl6'    => 'Perl'                  ,\n            'perl'     => 'Perl'                  ,\n            'miniperl' => 'Perl'                  ,\n            'php'      => 'PHP'                   ,\n            'php5'     => 'PHP'                   ,\n            'python'   => 'Python'                ,\n            'python2.6'=> 'Python'                ,\n            'python2.7'=> 'Python'                ,\n            'python3'  => 'Python'                ,\n            'python3.3'=> 'Python'                ,\n            'python3.4'=> 'Python'                ,\n            'python3.5'=> 'Python'                ,\n            'rexx'     => 'Rexx'                  ,\n            'regina'   => 'Rexx'                  ,\n            'ruby'     => 'Ruby'                  ,\n            'sed'      => 'sed'                   ,\n            'sh'       => 'Bourne Shell'          ,\n            'swipl'    => 'Prolog'                ,\n            'tcl'      => 'Tcl/Tk'                ,\n            'tclsh'    => 'Tcl/Tk'                ,\n            'tcsh'     => 'C Shell'               ,\n            'wish'     => 'Tcl/Tk'                ,\n            'zsh'      => 'zsh'                   ,\n            );\n# 1}}}\n%{$rh_Language_by_File}      = (             # {{{1\n            'build.xml'      => 'Ant/XML'            ,\n            'CMakeLists.txt' => 'CMake'              ,\n            'Jamfile'        => 'Jam'                ,\n            'Jamrules'       => 'Jam'                ,\n            'Makefile'       => 'make'               ,\n            'makefile'       => 'make'               ,\n            'gnumakefile'    => 'make'               ,\n            'Gnumakefile'    => 'make'               ,\n            'pom.xml'        => 'Maven/XML'          ,\n            'Rakefile'       => 'Ruby'               ,\n            'rakefile'       => 'Ruby'               ,\n            'Dockerfile'     => 'Dockerfile'         ,\n            );\n# 1}}}\n%{$rhaa_Filters_by_Language} = (             # {{{1\n    '(unknown)'          => [ ],\n    'ABAP'               => [   [ 'remove_matches'      , '^\\*'    ], ],\n    'ActionScript'       => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                            ],\n\n    'ASP'                => [   [ 'remove_matches'      , '^\\s*\\47'], ],  # \\47 = '\n    'ASP.Net'            => [   [ 'call_regexp_common'  , 'C'      ], ],\n    'Ada'                => [   [ 'remove_matches'      , '^\\s*--' ], ],\n    'ADSO/IDSM'          => [   [ 'remove_matches'      , '^\\s*\\*[\\+\\!]' ], ],\n    'AMPLE'              => [   [ 'remove_matches'      , '^\\s*//' ], ],\n    'Ant/XML'            => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'Antlr'              => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'Ant'                => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'Apex Trigger'       => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Arduino Sketch'     => [   # same as C\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'AspectJ'            => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Assembly'           => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_matches'      , '^\\s*;'  ],\n                                [ 'remove_matches'      , '^\\s*\\@' ],\n                                [ 'remove_matches'      , '^\\s*\\|' ],\n                                [ 'remove_matches'      , '^\\s*!'  ],\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_matches'      , '^\\s*--' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'remove_inline'       , ';.*$'   ],\n                                [ 'remove_inline'       , '\\@.*$'  ],\n                                [ 'remove_inline'       , '\\|.*$'  ],\n                                [ 'remove_inline'       , '!.*$'   ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                                [ 'remove_inline'       , '--.*$'  ],\n                            ],\n    'AutoHotkey'         => [\n                                [ 'remove_matches'      , '^\\s*;'  ],\n                                [ 'remove_inline'       , ';.*$'   ],\n                            ],\n    'awk'                => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'bc'                 => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Blade'              => [\n                                [ 'remove_between_general', '{{--', '--}}' ],\n                                [ 'remove_html_comments',                  ],\n                            ],\n    'Bourne Again Shell' => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Bourne Shell'       => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Brainfuck'          => [ # puerile name for a language\n#                               [ 'call_regexp_common'  , 'Brainfuck' ],  # inaccurate\n                                [ 'remove_bf_comments',               ],\n                            ],\n    'builder'            => [\n                                [ 'remove_matches'      , '^\\s*xml_markup.comment!'  ],\n                            ],\n    'C'                  => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n#                               [ 'remove_matches'      , '^\\s*//' ], # C99\n                                [ 'remove_inline'       , '//.*$'  ], # C99\n                            ],\n    'C++'                => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'C/C++ Header'       => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Clean'              => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Clojure'            => [   [ 'remove_matches'      , '^\\s*;'  ], ],\n    'ClojureScript'      => [   [ 'remove_matches'      , '^\\s*;'  ], ],\n    'ClojureC'           => [   [ 'remove_matches'      , '^\\s*;'  ], ],\n    'CMake'              => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Crystal'            => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'CUDA'               => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Cython'             => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'docstring_to_C'                 ],\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'C#'                 => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'CCS'                => [   [ 'call_regexp_common'  , 'C'      ], ],\n    'CSS'                => [   [ 'call_regexp_common'  , 'C'      ], ],\n    'COBOL'              => [   [ 'remove_cobol_comments',         ], ],\n    'CoffeeScript'       => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'ColdFusion'         => [   [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ], ],\n    'ColdFusion CFScript'=> [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Coq'                => [\n                                [ 'remove_between_general', '(*', '*)' ],\n                            ],\n    'Crystal Reports'    => [   [ 'remove_matches'      , '^\\s*//' ], ],\n    'CSON'               => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'D/dtrace'           => [ [ 'die' ,          ], ], # never called\n    'D'                  => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_between_general', '/+', '+/' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'DAL'                => [\n                                [ 'remove_between_general', '[', ']', ],\n                            ],\n    'Dart'               => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    # diff is kind of weird: anything but a space in the first column\n    # will count as code, with the exception of #, ---, +++.  Spaces\n    # in the first column denote context lines which aren't part of the\n    # difference.\n    'diff'               => [\n                                [ 'remove_matches'      , '^#' ],\n                                [ 'remove_matches'      , '^\\-\\-\\-' ],\n                                [ 'remove_matches'      , '^\\+\\+\\+' ],\n                                [ 'remove_matches'      , '^\\s' ],\n                            ],\n    'DITA'               => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'DOORS Extension Language' => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'dtrace'             => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'ECPP'               => [\n                                [ 'remove_between_general',\n                                  '<%doc>', '</%doc>',             ],\n                                [ 'remove_between_general',\n                                  '<#'    , '#>'     ,             ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'EEx'                => [\n                                [ 'remove_between_general', '<%#', '%>' ],\n                            ],\n    'Elm'                => [   [ 'remove_haskell_comments', '>filename<' ], ],\n    'ERB'                => [\n                                [ 'remove_between_general', '<%#', '%>' ],\n                            ],\n    'NASTRAN DMAP'       => [\n                                [ 'remove_matches'      , '^\\s*\\$' ],\n                                [ 'remove_inline'       , '\\$.*$'  ],\n                            ],\n    'Dockerfile'         => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'DOS Batch'          => [   [ 'remove_matches'      , '^\\s*rem', ], ],\n    'DTD'                => [   [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ], ],\n    'Elixir'             => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Erlang'             => [\n                                [ 'remove_matches'      , '^\\s*%'  ],\n                                [ 'remove_inline'       , '%.*$'   ],\n                            ],\n    'Expect'             => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Focus'              => [   [ 'remove_matches'      , '^\\s*\\-\\*'  ], ],\n    'Forth'              => [\n                                [ 'remove_matches'      , '^\\s*\\\\\\\\.*$'  ],\n                                [ 'Forth_paren_to_C'                 ],\n                                [ 'call_regexp_common'  , 'C++'      ],\n                                [ 'remove_inline'       , '\\\\\\\\.*$'  ],\n                            ],\n    'Fortran 77'         => [\n                                [ 'remove_f77_comments' ,          ],\n                                [ 'remove_inline'       , '\\!.*$'  ],\n                            ],\n    'Fortran 77/Forth'   => [ [ 'die' ,          ], ], # never called\n    'F#/Forth'           => [ [ 'die' ,          ], ], # never called\n    'Fortran 90'         => [\n                                [ 'remove_f77_comments' ,          ],\n                                [ 'remove_f90_comments' ,          ],\n                                [ 'remove_inline'       , '\\!.*$'  ],\n                            ],\n    'Fortran 95'         => [\n                                [ 'remove_f77_comments' ,          ],\n                                [ 'remove_f90_comments' ,          ],\n                                [ 'remove_inline'       , '\\!.*$'  ],\n                            ],\n    'Freemarker Template' => [\n                                [ 'remove_between_general', '<#--', '-->' ],\n                            ],\n    'F#'                 => [\n                                [ 'call_regexp_common'  , 'Pascal' ],\n                                [ 'remove_matches'      , '^\\s*//' ],\n                            ],\n    'GDScript'           => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Glade'              => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'GLSL'               => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'Go'                 => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Grails'             => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                                [ 'remove_jsp_comments' ,          ],\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'add_newlines'        ,          ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'Groovy'             => [\n                                [ 'remove_inline'       , '//.*$'  ],\n                                # separate /* inside quoted strings with two\n                                # concatenated strings split between / and *\n                                [ 'replace_between_regex', '([\"\\'])(.*?/)(\\*.*?)\\g1',\n                                  '(.*?)' , '\"$1$2$1 + $1$3$1$4\"'],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'Handlebars'         => [\n                                [ 'remove_between_general', '{{!--', '--}}' ],\n                                [ 'remove_between_general', '{{!', '}}' ],\n                                [ 'remove_html_comments',          ],\n                            ],\n    'Harbour'            => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_matches'      , '^\\s*\\&\\&' ],\n                                [ 'remove_matches'      , '^\\s*\\*' ],\n                                [ 'remove_matches'      , '^\\s*NOTE' ],\n                                [ 'remove_matches'      , '^\\s*note' ],\n                                [ 'remove_matches'      , '^\\s*Note' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'remove_inline'       , '\\&\\&.*$' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'HLSL'               => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'Haml'               => [\n                                [ 'remove_haml_block'   ,          ],\n                                [ 'remove_html_comments',          ],\n                                [ 'remove_matches'      , '^\\s*/\\s*\\S+' ],\n                                [ 'remove_matches'      , '^\\s*-#\\s*\\S+' ],\n                            ],\n    'Haxe'               => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'HTML'               => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'INI'                => [\n                                [ 'remove_matches'      , '^\\s*;'  ],\n                            ],\n    'XHTML'               => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'Haskell'            => [   [ 'remove_haskell_comments', '>filename<' ], ],\n    'IDL'                => [   [ 'remove_matches'      , '^\\s*;'  ], ],\n    'IDL/Qt Project/Prolog' => [ [ 'die' ,          ], ], # never called\n    'InstallShield'      => [   [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ], ],\n    'Jam'                => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'JSP'                => [   [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                                [ 'remove_jsp_comments' ,          ],\n                                [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'add_newlines'        ,          ],\n                                [ 'call_regexp_common'  , 'C'      ],\n                            ],\n    'JavaServer Faces'   => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Java'               => [\n                                # separate /* inside quoted strings with two\n                                # concatenated strings split between / and *\n                                [ 'replace_between_regex', '([\"\\'])(.*?/)(\\*.*?)\\g1',\n                                  '(.*?)' , '\"$1$2$1 + $1$3$1$4\"'],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'JavaScript'         => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'JSX'                => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'JCL'                => [   [ 'remove_jcl_comments' ,          ], ],\n    'JSON'               => [   # ECMA-404, the JSON standard definition\n                                # makes no provision for JSON comments\n                                # so just use a placeholder filter\n                                [ 'remove_matches'      , '^\\s*$'  ],\n                            ],\n    'Julia'              => [\n                                [ 'remove_between_general', '#=', '=#' ],\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Kotlin'             => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n#                               [ 'remove_between_general', '/*', '*/' ],\n                            ],\n    'LESS'               => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'LFE'                => [\n                                [ 'remove_matches'      , '^\\s*;'  ],\n                                [ 'remove_between_general', '#|', '|#' ],\n                            ],\n    'liquid'             => [\n                                [ 'remove_between_general', '{% comment %}',\n                                                            '{% endcomment %}' ],\n                                [ 'remove_html_comments',          ],\n                            ],\n    'Lisp'               => [\n                                [ 'remove_matches'      , '^\\s*;'  ],\n                                [ 'remove_between_general', '#|', '|#' ],\n                            ],\n    'Lisp/OpenCL'        => [ [ 'die' ,          ], ], # never called\n    'Lisp/Julia'         => [ [ 'die' ,          ], ], # never called\n    'LiveLink OScript'   => [   [ 'remove_matches'      , '^\\s*//' ], ],\n    'Logtalk'            => [  # same filters as Prolog\n                                [ 'remove_matches'      , '^\\s*\\%' ],\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_inline'       , '(//|\\%).*$' ],\n                            ],\n#   'Lua'                => [   [ 'call_regexp_common'  , 'lua'    ], ],\n    'Lua'                => [\n                                [ 'remove_between_general', '--[[', ']]' ],\n                                [ 'remove_matches'      , '^\\s*\\-\\-' ],\n                            ],\n    'make'               => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'MATLAB'             => [\n                                [ 'remove_matches'      , '^\\s*%'  ],\n                                [ 'remove_inline'       , '%.*$'   ],\n                            ],\n    'Mathematica'        => [\n                                [ 'remove_between_general', '(*', '*)' ],\n                            ],\n    'Maven/XML'          => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'Maven'              => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'Mercury'            => [\n                                [ 'remove_inline'       , '%.*$'   ],\n                                [ 'remove_matches'      , '^\\s*%'  ],\n                            ],\n    'Modula3'            => [   [ 'call_regexp_common'  , 'Pascal' ], ],\n        # Modula 3 comments are (* ... *) so applying the Pascal filter\n        # which also treats { ... } as a comment is not really correct.\n    'Nemerle'            => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'Objective C'        => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Objective C++'      => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'OCaml'              => [\n                                [ 'call_regexp_common'  , 'Pascal' ],\n                            ],\n    'OpenCL'             => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n#                               [ 'remove_matches'      , '^\\s*//' ], # C99\n                                [ 'remove_inline'       , '//.*$'  ], # C99\n                            ],\n    'PHP/Pascal'               => [ [ 'die' ,          ], ], # never called\n    'Mako'               => [\n                                [ 'remove_matches'       , '##.*$'  ],\n                            ],\n    'Markdown'           => [\n                                [ 'remove_between_regex',\n                                  '\\[(comment|\\/\\/)?\\]\\s*:?\\s*(<\\s*>|#)?\\s*\\(.*?', '.*?\\)' ],\n                                # http://stackoverflow.com/questions/4823468/comments-in-markdown\n                            ],\n    'MATLAB/Mathematica/Objective C/MUMPS/Mercury' => [ [ 'die' ,          ], ], # never called\n    'MUMPS'              => [   [ 'remove_matches'      , '^\\s*;'  ], ],\n    'Mustache'           => [\n                                [ 'remove_between_general', '{{!', '}}' ],\n                            ],\n    'Nim'                => [\n                                [ 'remove_between_general', '#[', ']#' ],\n                                [ 'remove_matches'      , '^\\s*#'  ],\n#                               [ 'docstring_to_C'                 ],\n#                               [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Octave'             => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Oracle Forms'       => [   [ 'call_regexp_common'  , 'C'      ], ],\n    'Oracle Reports'     => [   [ 'call_regexp_common'  , 'C'      ], ],\n    'Pascal'             => [\n                                [ 'remove_between_regex', '{[^$]', '}' ],\n                                [ 'remove_between_general', '(*', '*)' ],\n                                [ 'remove_matches'      , '^\\s*//' ],\n                            ],\n####'Pascal'             => [\n####                            [ 'call_regexp_common'  , 'Pascal' ],\n####                            [ 'remove_matches'      , '^\\s*//' ],\n####                        ],\n    'Pascal/Puppet'            => [ [ 'die' ,          ], ], # never called\n    'Puppet'             => [\n                                [ 'remove_matches'      , '^\\s*#'   ],\n                                [ 'call_regexp_common'  , 'C'       ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'PureScript'         => [\n                                [ 'remove_matches'      , '^\\s*--' ],\n                                [ 'remove_between_general', '{-', '-}' ],\n                                [ 'remove_inline'       , '--.*$'  ],\n                            ],\n    'Patran Command Language'=> [\n                                [ 'remove_matches'      , '^\\s*#'   ],\n                                [ 'remove_matches'      , '^\\s*\\$#' ],\n                                [ 'call_regexp_common'  , 'C'       ],\n                            ],\n    'PL/I'               => [\n                                [ 'call_regexp_common'  , 'C'      ],\n                            ],\n    'Perl'               => [   [ 'remove_below'        , '^__(END|DATA)__'],\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_below_above'  , '^=head1', '^=cut'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Perl/Prolog'        => [ [ 'die' ,          ], ], # never called\n    'Pig Latin'          => [\n                                [ 'remove_matches'      , '^\\s*--' ],\n                                [ 'remove_inline'       , '--.*$'  ],\n                                [ 'call_regexp_common'  , 'C'       ],\n                            ],\n    'PO File'            => [\n                                [ 'remove_matches'      , '^\\s*#[^,]' ],  # '#,' is not a comment\n                            ],\n    'PowerBuilder'       => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'PowerShell'         => [\n                                [ 'powershell_to_C'                ],\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Prolog'             => [\n                                [ 'remove_matches'      , '^\\s*\\%' ],\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_inline'       , '(//|\\%).*$' ],\n                            ],\n    'Protocol Buffers'   => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'Pug'                => [\n                                [ 'remove_pug_block'    ,          ],\n                                [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Python'             => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'docstring_to_C'                 ],\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'PHP'                => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '#.*$'   ],\n#                               [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'QML'                => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Qt'                 => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'Qt Linguist'        => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'Qt Project'         => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'R'                  => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Racket'             => [\n                                [ 'remove_matches'      , '^\\s*;'  ],\n                                [ 'remove_inline'       , ';.*$'   ],\n                            ],\n    'RapydScript'        => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'docstring_to_C'                 ],\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Razor'              => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_between_general', '@*', '*@' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'RobotFramework'     => [\n                                [ 'remove_matches'      , '^\\s*#'   ],\n                                [ 'remove_matches'      , '^\\s*Comment' ],\n                                [ 'remove_matches'      , '^\\s*\\*{3}\\s+(Variables|Test\\s+Cases|Settings|Keywords)\\s+\\*{3}' ] ,\n                                [ 'remove_matches'      , '^\\s*\\[(Documentation|Tags)\\]' ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Rexx'               => [   [ 'call_regexp_common'  , 'C'      ], ],\n    'Ruby'               => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_below_above'  , '^=begin', '^=end' ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Ruby HTML'          => [   [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ], ],\n    'Rust'               => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'SAS'                => [\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_between_general', '*', ';' ],\n                            ],\n    'Sass'               => [\n                                [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Scala'              => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'Slice'             => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n#                               [ 'remove_between_general', '/*', '*/' ],\n                            ],\n    'Slim'               => [\n                                [ 'remove_slim_block'   ,          ],\n                            ],\n    'SKILL'              => [\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_matches'      , '^\\s*;'  ],\n                            ],\n    'SKILL++'            => [\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_matches'      , '^\\s*;'  ],\n                            ],\n    'Specman e'          => [\n                                [ 'pre_post_fix'        , \"'>\", \"<'\"],\n                                [ 'remove_between_general', \"'>\", \"<'\" ],\n                                [ 'call_regexp_common'  , 'C++',   ],\n                                [ 'remove_matches'      , '^\\s*--' ],\n                            ],\n    'SQL'                => [\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_matches'      , '^\\s*--' ],\n                                [ 'remove_inline'       , '--.*$'  ],\n                            ],\n    'SQL Stored Procedure'=> [\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_matches'      , '^\\s*--' ],\n                                [ 'remove_inline'       , '--.*$'  ],\n                            ],\n    'SQL Data'           => [\n                                [ 'call_regexp_common'  , 'C'      ],\n                                [ 'remove_matches'      , '^\\s*--' ],\n                                [ 'remove_inline'       , '--.*$'  ],\n                            ],\n    'sed'                => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Smarty'             => [\n                                [ 'smarty_to_C'                    ],\n                                [ 'call_regexp_common'  , 'C'      ],\n                            ],\n    'Standard ML'        => [\n                                [ 'remove_between_general', '(*', '*)' ],\n                            ],\n    'Stylus'             => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Swift'              => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n\n    'm4'                 => [   [ 'remove_matches'      , '^dnl '  ], ],\n    'C Shell'            => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Kermit'             => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_matches'      , '^\\s*;'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Korn Shell'         => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Tcl/Tk'             => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Teamcenter met'     => [   [ 'call_regexp_common'  , 'C'      ], ],\n    'Teamcenter mth'     => [   [ 'remove_matches'      , '^\\s*#'  ], ],\n    'TeX'                => [\n                                [ 'remove_matches'      , '^\\s*%'  ],\n                                [ 'remove_inline'       , '%.*$'   ],\n                            ],\n    'Titanium Style Sheet'  => [\n                                [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'remove_between_regex', '/[^/]', '[^/]/' ],\n                            ],\n    'Twig'               => [\n                                [ 'remove_between_general', '{#', '#}' ],\n                            ],\n    'TTCN'               => [\n                                [ 'call_regexp_common'  , 'C++'      ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'TITAN Project File Information'               => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'TypeScript'         => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'Unity-Prefab'       => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'Visual Fox Pro'     =>  [\n                                [ 'remove_matches'      , '^\\s*\\*' ],\n                                [ 'remove_inline'       , '\\*.*$'  ],\n                                [ 'remove_matches'      , '^\\s*&&' ],\n                                [ 'remove_inline'       , '&&.*$'  ],\n                            ],\n    'Softbridge Basic'   => [   [ 'remove_above'        , '^\\s*Attribute\\s+VB_Name\\s+=' ],\n                                [ 'remove_matches'      , '^\\s*Attribute\\s+'],\n                                [ 'remove_matches'      , '^\\s*\\47'], ],  # \\47 = '\n    # http://www.altium.com/files/learningguides/TR0114%20VHDL%20Language%20Reference.pdf\n    'Vala'               => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Vala Header'        => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'Verilog-SystemVerilog/Coq' => [ ['die'] ], # never called\n    'Verilog-SystemVerilog' => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'VHDL'               => [\n                                [ 'remove_matches'      , '^\\s*--' ],\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                                [ 'remove_inline'       , '--.*$'  ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'vim script'         => [\n                                [ 'remove_matches'      , '^\\s*\"'  ],\n                                [ 'remove_inline'       , '\".*$'   ],\n                            ],\n    'Visual Basic'       => [   [ 'remove_above'        , '^\\s*Attribute\\s+VB_Name\\s+=' ],\n                                [ 'remove_matches'      , '^\\s*Attribute\\s+'],\n                                [ 'remove_matches'      , '^\\s*\\47'], ],  # \\47 = '\n    'Visualforce Component' => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'Visualforce Page'   => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'Velocity Template Language' => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                                [ 'remove_jsp_comments' ,          ],\n                                [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'add_newlines'        ,          ],\n                                [ 'call_regexp_common'  , 'C'      ],\n                            ],\n    'Vuejs Component'     => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'Teamcenter def'     => [   [ 'remove_matches'      , '^\\s*#'  ], ],\n    'Windows Module Definition' => [\n                                [ 'remove_matches'      , '^\\s*;' ],\n                                [ 'remove_inline'       , ';.*$'  ],\n                            ],\n    'yacc'               => [\n                                [ 'call_regexp_common'  , 'C++'    ],\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                            ],\n    'YAML'               => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    'lex'                => [   [ 'call_regexp_common'  , 'C'      ], ],\n    'XAML'               => [   [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ], ],\n    'xBase Header'       => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_matches'      , '^\\s*\\&\\&' ],\n                                [ 'remove_matches'      , '^\\s*\\*' ],\n                                [ 'remove_matches'      , '^\\s*NOTE' ],\n                                [ 'remove_matches'      , '^\\s*note' ],\n                                [ 'remove_matches'      , '^\\s*Note' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'remove_inline'       , '\\&\\&.*$' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'xBase'              => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_matches'      , '^\\s*\\&\\&' ],\n                                [ 'remove_matches'      , '^\\s*\\*' ],\n                                [ 'remove_matches'      , '^\\s*NOTE' ],\n                                [ 'remove_matches'      , '^\\s*note' ],\n                                [ 'remove_matches'      , '^\\s*Note' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'remove_inline'       , '\\&\\&.*$' ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'MXML'               => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                                [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'add_newlines'        ,          ],\n                                [ 'call_regexp_common'  , 'C'      ],\n                            ],\n    'Windows Message File'  => [\n                                [ 'remove_matches'      , '^\\s*;\\s*//' ],\n                                [ 'call_regexp_common'  , 'C'          ],\n                                [ 'remove_matches'      , '^\\s*;\\s*$'  ],\n#                               next line only hypothetical\n#                               [ 'remove_matches_2re'  , '^\\s*;\\s*/\\*',\n#                                                         '^\\s*;\\s*\\*/', ],\n                            ],\n    'Windows Resource File' => [\n#                               [ 'remove_matches'      , '^\\s*//' ],\n                                [ 'remove_inline'       , '//.*$'  ],\n                                [ 'call_regexp_common'  , 'C++'    ],\n                            ],\n    'WiX source'         => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'WiX include'        => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'WiX string localization' => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'XMI'                => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'XML'                => [\n                                [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ],\n                            ],\n    'XQuery'             => [\n                                [ 'remove_between_general', '(:', ':)' ],\n                            ],\n    'XSD'                => [   [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ], ],\n    'XSLT'               => [   [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ], ],\n    'NAnt script'       => [   [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ], ],\n    'MSBuild script'    => [   [ 'remove_html_comments',          ],\n                                [ 'call_regexp_common'  , 'HTML'   ], ],\n    'zsh'                => [\n                                [ 'remove_matches'      , '^\\s*#'  ],\n                                [ 'remove_inline'       , '#.*$'   ],\n                            ],\n    );\n# 1}}}\n%{$rh_EOL_continuation_re} = (               # {{{1\n    'ActionScript'       =>     '\\\\\\\\$'         ,\n    'AspectJ'            =>     '\\\\\\\\$'         ,\n    'Assembly'           =>     '\\\\\\\\$'         ,\n    'ASP'                =>     '\\\\\\\\$'         ,\n    'ASP.Net'            =>     '\\\\\\\\$'         ,\n    'Ada'                =>     '\\\\\\\\$'         ,\n    'awk'                =>     '\\\\\\\\$'         ,\n    'bc'                 =>     '\\\\\\\\$'         ,\n    'C'                  =>     '\\\\\\\\$'         ,\n    'C++'                =>     '\\\\\\\\$'         ,\n    'C/C++ Header'       =>     '\\\\\\\\$'         ,\n    'CMake'              =>     '\\\\\\\\$'         ,\n    'Cython'             =>     '\\\\\\\\$'         ,\n    'C#'                 =>     '\\\\\\\\$'         ,\n    'D'                  =>     '\\\\\\\\$'         ,\n    'Dart'               =>     '\\\\\\\\$'         ,\n    'Expect'             =>     '\\\\\\\\$'         ,\n    'Go'                 =>     '\\\\\\\\$'         ,\n    'IDL'                =>     '\\$\\\\$'         ,\n    'Java'               =>     '\\\\\\\\$'         ,\n    'JavaScript'         =>     '\\\\\\\\$'         ,\n    'JSX'                =>     '\\\\\\\\$'         ,\n    'LESS'               =>     '\\\\\\\\$'         ,\n    'Lua'                =>     '\\\\\\\\$'         ,\n    'make'               =>     '\\\\\\\\$'         ,\n    'MATLAB'             =>     '\\.\\.\\.\\s*$'    ,\n    'MXML'               =>     '\\\\\\\\$'         ,\n    'Objective C'        =>     '\\\\\\\\$'         ,\n    'Objective C++'      =>     '\\\\\\\\$'         ,\n    'OCaml'              =>     '\\\\\\\\$'         ,\n    'Octave'             =>     '\\.\\.\\.\\s*$'    ,\n    'Qt Project'         =>     '\\\\\\\\$'         ,\n    'Patran Command Language'=> '\\\\\\\\$'         ,\n    'PowerBuilder'       =>     '\\\\\\\\$'         ,\n    'PowerShell'         =>     '\\\\\\\\$'         ,\n    'Python'             =>     '\\\\\\\\$'         ,\n    'R'                  =>     '\\\\\\\\$'         ,\n    'Ruby'               =>     '\\\\\\\\$'         ,\n    'sed'                =>     '\\\\\\\\$'         ,\n    'Swift'              =>     '\\\\\\\\$'         ,\n    'Bourne Again Shell' =>     '\\\\\\\\$'         ,\n    'Bourne Shell'       =>     '\\\\\\\\$'         ,\n    'C Shell'            =>     '\\\\\\\\$'         ,\n    'Kermit'             =>     '\\\\\\\\$'         ,\n    'Korn Shell'         =>     '\\\\\\\\$'         ,\n    'Stylus'             =>     '\\\\\\\\$'         ,\n    'Tcl/Tk'             =>     '\\\\\\\\$'         ,\n    'TTCN'               =>     '\\\\\\\\$'         ,\n    'TypeScript'         =>     '\\\\\\\\$'         ,\n    'lex'                =>     '\\\\\\\\$'         ,\n    'Vala'               =>     '\\\\\\\\$'         ,\n    'Vala Header'        =>     '\\\\\\\\$'         ,\n    'zsh'                =>     '\\\\\\\\$'         ,\n    );\n# 1}}}\n%{$rh_Not_Code_Extension}    = (             # {{{1\n   '1'         => 1,  # Man pages (documentation):\n   '2'         => 1,\n   '3'         => 1,\n   '4'         => 1,\n   '5'         => 1,\n   '6'         => 1,\n   '7'         => 1,\n   '8'         => 1,\n   '9'         => 1,\n   'a'         => 1,  # Static object code.\n   'ad'        => 1,  # X application default resource file.\n   'afm'       => 1,  # font metrics\n   'arc'       => 1,  # arc(1) archive\n   'arj'       => 1,  # arj(1) archive\n   'au'        => 1,  # Audio sound filearj(1) archive\n   'bak'       => 1,  # Backup files - we only want to count the \"real\" files.\n   'bdf'       => 1,\n   'bmp'       => 1,\n   'bz2'       => 1,  # bzip2(1) compressed file\n   'csv'       => 1,  # comma separated values\n   'desktop'   => 1,\n   'dic'       => 1,\n   'doc'       => 1,\n   'elc'       => 1,\n   'eps'       => 1,\n   'fig'       => 1,\n   'gif'       => 1,\n   'gz'        => 1,\n   'hdf'       => 1,  # hierarchical data format\n   'in'        => 1,  # Debatable.\n   'jpg'       => 1,\n   'kdelnk'    => 1,\n   'man'       => 1,\n   'mf'        => 1,\n   'mp3'       => 1,\n   'n'         => 1,\n   'o'         => 1,  # Object code is generated from source code.\n   'o.cmd'     => 1,  # not DOS Batch; Linux kernel compilation optimization file\n   'pbm'       => 1,\n   'pdf'       => 1,\n   'pfb'       => 1,\n   'png'       => 1,\n   'ps'        => 1,  # Postscript is _USUALLY_ generated automatically.\n   'sgm'       => 1,\n   'sgml'      => 1,\n   'so'        => 1,  # Dynamically-loaded object code.\n   'Tag'       => 1,\n   'text'      => 1,\n   'tfm'       => 1,\n   'tgz'       => 1,  # gzipped tarball\n   'tiff'      => 1,\n   'txt'       => 1,\n   'vf'        => 1,\n   'wav'       => 1,\n   'xbm'       => 1,\n   'xpm'       => 1,\n   'Y'         => 1,  # file compressed with \"Yabba\"\n   'Z'         => 1,  # file compressed with \"compress\"\n   'zip'       => 1,  # zip archive\n   'gitignore' => 1,\n); # 1}}}\n%{$rh_Not_Code_Filename}     = (             # {{{1\n   'AUTHORS'     => 1,\n   'BUGS'        => 1,\n   'BUGS'        => 1,\n   'Changelog'   => 1,\n   'ChangeLog'   => 1,\n   'ChangeLog'   => 1,\n   'Changes'     => 1,\n   'CHANGES'     => 1,\n   'COPYING'     => 1,\n   'COPYING'     => 1,\n   '.cvsignore'  => 1,\n   'Entries'     => 1,\n   'FAQ'         => 1,\n   'iconfig.h'   => 1, # Skip \"iconfig.h\" files; they're used in Imakefiles.\n   'INSTALL'     => 1,\n   'MAINTAINERS' => 1,\n   'MD5SUMS'     => 1,\n   'NEWS'        => 1,\n   'readme'      => 1,\n   'Readme'      => 1,\n   'README'      => 1,\n   'README.tk'   => 1, # used in kdemultimedia, it's confusing.\n   'Repository'  => 1,\n   'Root'        => 1, # CVS\n   'TODO'        => 1,\n);\n# 1}}}\n%{$rh_Scale_Factor}          = (             # {{{1\n    '(unknown)'                    =>   0.00,\n    '1032/af'                      =>   5.00,\n    '1st generation default'       =>   0.25,\n    '2nd generation default'       =>   0.75,\n    '3rd generation default'       =>   1.00,\n    '4th generation default'       =>   4.00,\n    '5th generation default'       =>  16.00,\n    'aas macro'                    =>   0.88,\n    'abap/4'                       =>   5.00,\n    'ABAP'                         =>   5.00,\n    'accel'                        =>   4.21,\n    'access'                       =>   2.11,\n    'ActionScript'                 =>   1.36,\n    'actor'                        =>   3.81,\n    'acumen'                       =>   2.86,\n    'Ada'                          =>   0.52,\n    'Ada 83'                       =>   1.13,\n    'Ada 95'                       =>   1.63,\n    'adr/dl'                       =>   2.00,\n    'adr/ideal/pdl'                =>   4.00,\n    'ads/batch'                    =>   4.00,\n    'ads/online'                   =>   4.00,\n    'ADSO/IDSM'                    =>   3.00,\n    'advantage'                    =>   2.11,\n    'ai shell default'             =>   1.63,\n    'ai shells'                    =>   1.63,\n    'algol 68'                     =>   0.75,\n    'algol w'                      =>   0.75,\n    'ambush'                       =>   2.50,\n    'aml'                          =>   1.63,\n    'AMPLE'                        =>   2.00,\n    'Ant/XML'                      =>   1.90,\n    'Ant'                          =>   1.90,\n    'Antlr'                        =>   2.00,\n    'amppl ii'                     =>   1.25,\n    'ansi basic'                   =>   1.25,\n    'ansi cobol 74'                =>   0.75,\n    'ansi cobol 85'                =>   0.88,\n    'SQL'                          =>   6.15,\n    'SQL Stored Procedure'         =>   6.15,\n    'SQL Data'                     =>   1.00,\n    'answer/db'                    =>   6.15,\n    'apl 360/370'                  =>   2.50,\n    'apl default'                  =>   2.50,\n    'apl*plus'                     =>   2.50,\n    'applesoft basic'              =>   0.63,\n    'application builder'          =>   4.00,\n    'application manager'          =>   2.22,\n    'aps'                          =>   0.96,\n    'aps'                          =>   4.71,\n    'apt'                          =>   1.13,\n    'aptools'                      =>   4.00,\n    'arc'                          =>   1.63,\n    'ariel'                        =>   0.75,\n    'arity'                        =>   1.63,\n    'art'                          =>   1.63,\n    'art enterprise'               =>   1.74,\n    'artemis'                      =>   2.00,\n    'artim'                        =>   1.74,\n    'AspectJ'                      =>   1.36,\n    'as/set'                       =>   4.21,\n    'asi/inquiry'                  =>   6.15,\n    'ask windows'                  =>   1.74,\n    'asa'                          =>   1.29,\n    'ASP'                          =>   1.29,\n    'ASP.Net'                      =>   1.29,\n    'aspx'                         =>   1.29,\n    'asax'                         =>   1.29,\n    'ascx'                         =>   1.29,\n    'asmx'                         =>   1.29,\n    'config'                       =>   1.29,\n    'webinfo'                      =>   1.29,\n    'CCS'                          =>   5.33,\n    'Apex Trigger'                 =>   1.4 ,\n    'Arduino Sketch'               =>   1.00,\n    'Assembly'                     =>   0.25,\n    'Assembly (macro)'             =>   0.51,\n    'associative default'          =>   1.25,\n    'autocoder'                    =>   0.25,\n    'AutoHotkey'                   =>   1.29,\n    'awk'                          =>   3.81,\n    'aztec c'                      =>   0.63,\n    'balm'                         =>   0.75,\n    'base sas'                     =>   1.51,\n    'basic'                        =>   0.75,\n    'basic a'                      =>   0.63,\n    'bc'                           =>   1.50,\n    'berkeley pascal'              =>   0.88,\n    'better basic'                 =>   0.88,\n    'Blade'                        =>   2.00,\n    'bliss'                        =>   0.75,\n    'bmsgen'                       =>   2.22,\n    'boeingcalc'                   =>  13.33,\n    'bteq'                         =>   6.15,\n    'Brainfuck'                    =>   0.10,\n    'builder'                      =>   2.00,\n    'C'                            =>   0.77,\n    'c set 2'                      =>   0.88,\n    'C#'                           =>   1.36,\n    'C++'                          =>   1.51,\n    'c86plus'                      =>   0.63,\n    'cadbfast'                     =>   2.00,\n    'caearl'                       =>   2.86,\n    'cast'                         =>   1.63,\n    'cbasic'                       =>   0.88,\n    'cdadl'                        =>   4.00,\n    'cellsim'                      =>   1.74,\n    'ColdFusion'                   =>   4.00,\n    'ColdFusion CFScript'          =>   4.00,\n    'chili'                        =>   0.75,\n    'chill'                        =>   0.75,\n    'cics'                         =>   1.74,\n    'clarion'                      =>   1.38,\n    'clascal'                      =>   1.00,\n    'Clean'                        =>   2.50,\n    'cli'                          =>   2.50,\n    'clipper'                      =>   2.05,\n    'clipper db'                   =>   2.00,\n    'clos'                         =>   3.81,\n    'Clojure'                      =>   1.25,\n    'ClojureScript'                =>   1.25,\n    'ClojureC'                     =>   1.25,\n    'clout'                        =>   2.00,\n    'CMake'                        =>   1.00,\n    'cms2'                         =>   0.75,\n    'cmsgen'                       =>   4.21,\n    'COBOL'                        =>   1.04,\n    'COBOL ii'                     =>   0.75,\n    'COBOL/400'                    =>   0.88,\n    'cobra'                        =>   4.00,\n    'codecenter'                   =>   2.22,\n    'cofac'                        =>   2.22,\n    'CoffeeScript'                 =>   2.00,\n    'cogen'                        =>   2.22,\n    'cognos'                       =>   2.22,\n    'cogo'                         =>   1.13,\n    'comal'                        =>   1.00,\n    'comit ii'                     =>   1.25,\n    'common lisp'                  =>   1.25,\n    'concurrent pascal'            =>   1.00,\n    'conniver'                     =>   1.25,\n    'cool:gen/ief'                 =>   2.58,\n    'Coq'                          =>   5.00,\n    'coral 66'                     =>   0.75,\n    'corvet'                       =>   4.21,\n    'corvision'                    =>   5.33,\n    'cpl'                          =>   0.50,\n    'Crystal'                      =>   2.50,\n    'Crystal Reports'              =>   4.00,\n    'csl'                          =>   1.63,\n    'CSON'                         =>   2.50,\n    'csp'                          =>   1.51,\n    'cssl'                         =>   1.74,\n    'CSS'                          =>   1.0,\n    'culprit'                      =>   1.57,\n    'CUDA'                         =>   1.00,\n    'cxpert'                       =>   1.63,\n    'cygnet'                       =>   4.21,\n    'D'                            =>   1.70,\n    'DAL'                          =>   1.50,\n    'Dart'                         =>   2.00,\n    'data base default'            =>   2.00,\n    'dataflex'                     =>   2.00,\n    'datatrieve'                   =>   4.00,\n    'dbase iii'                    =>   2.00,\n    'dbase iv'                     =>   1.54,\n    'diff'                         =>   1.00,\n    'decision support default'     =>   2.22,\n    'decrally'                     =>   2.00,\n    'delphi'                       =>   2.76,\n    'DITA'                         =>   1.90,\n    'dl/1'                         =>   2.00,\n    'dtrace'                       =>   2.00,\n    'NASTRAN DMAP'                 =>   2.35,\n    'dna4'                         =>   4.21,\n    'DOORS Extension Language'     =>   1.50,\n    'Dockerfile'                   =>   2.00,\n    'DOS Batch'                    =>   0.63,\n    'dsp assembly'                 =>   0.50,\n    'dtabl'                        =>   1.74,\n    'dtipt'                        =>   1.74,\n    'dyana'                        =>   1.13,\n    'dynamoiii'                    =>   1.74,\n    'easel'                        =>   2.76,\n    'easy'                         =>   1.63,\n    'easytrieve+'                  =>   2.35,\n    'eclipse'                      =>   1.63,\n    'ECPP'                         =>   1.90,\n    'eda/sql'                      =>   6.67,\n    'edscheme 3.4'                 =>   1.51,\n    'EEx'                          =>   2.00,\n    'eiffel'                       =>   3.81,\n    'Elixir'                       =>   2.11,\n    'Elm'                          =>   2.50,\n    'enform'                       =>   1.74,\n    'englishbased default'         =>   1.51,\n    'ensemble'                     =>   2.76,\n    'epos'                         =>   4.00,\n    'ERB'                          =>   2.00,\n    'Erlang'                       =>   2.11,\n    'esf'                          =>   2.00,\n    'espadvisor'                   =>   1.63,\n    'espl/i'                       =>   1.13,\n    'euclid'                       =>   0.75,\n    'excel'                        =>   1.74,\n    'excel 12'                     =>  13.33,\n    'excel 34'                     =>  13.33,\n    'excel 5'                      =>  13.33,\n    'express'                      =>   2.22,\n    'exsys'                        =>   1.63,\n    'extended common lisp'         =>   1.43,\n    'eznomad'                      =>   2.22,\n    'facets'                       =>   4.00,\n    'factorylink iv'               =>   2.76,\n    'fame'                         =>   2.22,\n    'filemaker pro'                =>   2.22,\n    'flavors'                      =>   2.76,\n    'flex'                         =>   1.74,\n    'flexgen'                      =>   2.76,\n    'Focus'                        =>   1.90,\n    'foil'                         =>   1.51,\n    'forte'                        =>   4.44,\n    'Forth'                        =>   1.25,\n    'Fortran 66'                   =>   0.63,\n    'Fortran 77'                   =>   0.75,\n    'Fortran 90'                   =>   1.00,\n    'Fortran 95'                   =>   1.13,\n    'Fortran II'                   =>   0.63,\n    'foundation'                   =>   2.76,\n    'foxpro'                       =>   2.29,\n    'foxpro 1'                     =>   2.00,\n    'foxpro 2.5'                   =>   2.35,\n    'framework'                    =>  13.33,\n    'Freemarker Template'          =>   1.48,\n    'F#'                           =>   2.50,\n    'g2'                           =>   1.63,\n    'gamma'                        =>   5.00,\n    'genascript'                   =>   2.96,\n    'gener/ol'                     =>   6.15,\n    'genexus'                      =>   5.33,\n    'genifer'                      =>   4.21,\n    'geode 2.0'                    =>   5.00,\n    'gfa basic'                    =>   2.35,\n    'Glade'                        =>   2.00,\n    'GLSL'                         =>   2.00,\n    'gml'                          =>   1.74,\n    'golden common lisp'           =>   1.25,\n    'gpss'                         =>   1.74,\n    'guest'                        =>   2.86,\n    'guru'                         =>   1.63,\n    'GDScript'                     =>   2.50,\n    'Go'                           =>   2.50,\n    'Grails'                       =>   1.48,\n    'Groovy'                       =>   4.10,\n    'gw basic'                     =>   0.82,\n    'Harbour'                      =>   2.00,\n    'Haskell'                      =>   2.11,\n    'high c'                       =>   0.63,\n    'hlevel'                       =>   1.38,\n    'hp basic'                     =>   0.63,\n    'Haml'                         =>   2.50,\n    'Handlebars'                   =>   2.50,\n    'Haxe'                         =>   2.00,\n    'HTML'                         =>   1.90,\n    'XHTML'                        =>   1.90,\n    'XMI'                          =>   1.90,\n    'XML'                          =>   1.90,\n    'MXML'                         =>   1.90,\n    'XSLT'                         =>   1.90,\n    'DTD'                          =>   1.90,\n    'XSD'                          =>   1.90,\n    'NAnt script'                  =>   1.90,\n    'MSBuild script'               =>   1.90,\n    'HLSL'                         =>   2.00,\n    'HTML 2'                       =>   5.00,\n    'HTML 3'                       =>   5.33,\n    'huron'                        =>   5.00,\n    'ibm adf i'                    =>   4.00,\n    'ibm adf ii'                   =>   4.44,\n    'ibm advanced basic'           =>   0.82,\n    'ibm cics/vs'                  =>   2.00,\n    'ibm compiled basic'           =>   0.88,\n    'ibm vs cobol'                 =>   0.75,\n    'ibm vs cobol ii'              =>   0.88,\n    'ices'                         =>   1.13,\n    'icon'                         =>   1.00,\n    'ideal'                        =>   1.54,\n    'idms'                         =>   2.00,\n    'ief'                          =>   5.71,\n    'ief/cool:gen'                 =>   2.58,\n    'iew'                          =>   5.71,\n    'ifps/plus'                    =>   2.50,\n    'imprs'                        =>   2.00,\n    'informix'                     =>   2.58,\n    'ingres'                       =>   2.00,\n    'INI'                          =>   1.00,\n    'inquire'                      =>   6.15,\n    'insight2'                     =>   1.63,\n    'install/1'                    =>   5.00,\n    'InstallShield'                =>   1.90,\n    'intellect'                    =>   1.51,\n    'interlisp'                    =>   1.38,\n    'interpreted basic'            =>   0.75,\n    'interpreted c'                =>   0.63,\n    'iqlisp'                       =>   1.38,\n    'iqrp'                         =>   6.15,\n    'j2ee'                         =>   1.60,\n    'Jam'                          =>   2.00,\n    'janus'                        =>   1.13,\n    'Java'                         =>   1.36,\n    'JavaScript'                   =>   1.48,\n    'JavaServer Faces'             =>   1.5 ,\n    'JSON'                         =>   2.50,\n    'JSP'                          =>   1.48,\n    'JSX'                          =>   1.48,\n    'Velocity Template Language'   =>   1.00,\n    'JCL'                          =>   1.67,\n    'joss'                         =>   0.75,\n    'jovial'                       =>   0.75,\n    'jsp'                          =>   1.36,\n    'kappa'                        =>   2.00,\n    'kbms'                         =>   1.63,\n    'kcl'                          =>   1.25,\n    'kee'                          =>   1.63,\n    'keyplus'                      =>   2.00,\n    'kl'                           =>   1.25,\n    'klo'                          =>   1.25,\n    'knowol'                       =>   1.63,\n    'krl'                          =>   1.38,\n    'Kermit'                       =>   2.00,\n    'Korn Shell'                   =>   3.81,\n    'Kotlin'                       =>   2.00,\n    'ladder logic'                 =>   2.22,\n    'lambit/l'                     =>   1.25,\n    'lattice c'                    =>   0.63,\n    'LESS'                         =>   1.50,\n    'LFE'                          =>   1.25,\n    'liana'                        =>   0.63,\n    'lilith'                       =>   1.13,\n    'linc ii'                      =>   5.71,\n    'liquid'                       =>   3.00,\n    'Lisp'                         =>   1.25,\n    'LiveLink OScript'             =>   3.5 ,\n    'loglisp'                      =>   1.38,\n    'Logtalk'                      =>   2.00,\n    'loops'                        =>   3.81,\n    'lotus 123 dos'                =>  13.33,\n    'lotus macros'                 =>   0.75,\n    'lotus notes'                  =>   3.64,\n    'lucid 3d'                     =>  13.33,\n    'lyric'                        =>   1.51,\n    'm4'                           =>   1.00,\n    'm'                            =>   5.00,\n    'macforth'                     =>   1.25,\n    'mach1'                        =>   2.00,\n    'machine language'             =>   0.13,\n    'maestro'                      =>   5.00,\n    'magec'                        =>   5.00,\n    'magik'                        =>   3.81,\n    'Lake'                         =>   3.81,\n    'make'                         =>   2.50,\n    'Mako'                         =>   1.50, # Not sure about the scaling.\n    'mantis'                       =>   2.96,\n    'mapper'                       =>   0.99,\n    'mark iv'                      =>   2.00,\n    'mark v'                       =>   2.22,\n    'Markdown'                     =>   1.00,\n    'mathcad'                      =>  16.00,\n    'Maven'                        =>   1.90,\n    'mdl'                          =>   2.22,\n    'mentor'                       =>   1.51,\n    'mesa'                         =>   0.75,\n    'microfocus cobol'             =>   1.00,\n    'microforth'                   =>   1.25,\n    'microsoft c'                  =>   0.63,\n    'microstep'                    =>   4.00,\n    'miranda'                      =>   2.00,\n    'model 204'                    =>   2.11,\n    'modula 2'                     =>   1.00,\n    'mosaic'                       =>  13.33,\n    # 'ms c ++ v. 7'                 =>   1.51,\n    'ms compiled basic'            =>   0.88,\n    'msl'                          =>   1.25,\n    'mulisp'                       =>   1.25,\n    'MUMPS'                        =>   4.21,\n    'Mustache'                     =>   1.75,\n    'Nastran'                      =>   1.13,\n    'natural'                      =>   1.54,\n    'natural 1'                    =>   1.51,\n    'natural 2'                    =>   1.74,\n    'natural construct'            =>   3.20,\n    'natural language'             =>   0.03,\n    'Nemerle'                      =>   2.50,\n    'netron/cap'                   =>   4.21,\n    'nexpert'                      =>   1.63,\n    'nial'                         =>   1.63,\n    'Nim'                          =>   2.00,\n    'nomad2'                       =>   2.00,\n    'nonprocedural default'        =>   2.22,\n    'notes vip'                    =>   2.22,\n    'nroff'                        =>   1.51,\n    'object assembler'             =>   1.25,\n    'object lisp'                  =>   2.76,\n    'object logo'                  =>   2.76,\n    'object pascal'                =>   2.76,\n    'object star'                  =>   5.00,\n    'Objective C'                  =>   2.96,\n    'Objective C++'                =>   2.96,\n    'objectoriented default'       =>   2.76,\n    'objectview'                   =>   3.20,\n    'OCaml'                        =>   3.00,\n    'ogl'                          =>   1.00,\n    'omnis 7'                      =>   2.00,\n    'oodl'                         =>   2.76,\n    'ops'                          =>   1.74,\n    'ops5'                         =>   1.38,\n    'oracle'                       =>   2.76,\n    'Oracle Reports'               =>   2.76,\n    'Oracle Forms'                 =>   2.67,\n    'Oracle Developer/2000'        =>   3.48,\n    'oscar'                        =>   0.75,\n    'pacbase'                      =>   1.67,\n    'pace'                         =>   2.00,\n    'paradox/pal'                  =>   2.22,\n    'Pascal'                       =>   0.88,\n    'Patran Command Language'      =>   2.50,\n    'pc focus'                     =>   2.22,\n    'pdl millenium'                =>   3.81,\n    'pdp11 ade'                    =>   1.51,\n    'peoplesoft'                   =>   2.50,\n    'Perl'                         =>   4.00,\n    'persistance object builder'   =>   3.81,\n    'Pig Latin'                    =>   1.00,\n    'pilot'                        =>   1.51,\n    'PL/I'                         =>   1.38,\n    'pl/1'                         =>   1.38,\n    'pl/m'                         =>   1.13,\n    'pl/s'                         =>   0.88,\n    'pl/sql'                       =>   2.58,\n    'planit'                       =>   1.51,\n    'planner'                      =>   1.25,\n    'planperfect 1'                =>  11.43,\n    'plato'                        =>   1.51,\n    'PO File'                      =>   1.50,\n    'polyforth'                    =>   1.25,\n    'pop'                          =>   1.38,\n    'poplog'                       =>   1.38,\n    'power basic'                  =>   1.63,\n    'PowerBuilder'                 =>   3.33,\n    'powerhouse'                   =>   5.71,\n    'PowerShell'                   =>   3.00,\n    'ppl (plus)'                   =>   2.00,\n    'problemoriented default'      =>   1.13,\n    'proc'                         =>   2.96,\n    'procedural default'           =>   0.75,\n    'professional pascal'          =>   0.88,\n    'program generator default'    =>   5.00,\n    'progress v4'                  =>   2.22,\n    'proiv'                        =>   1.38,\n    'Prolog'                       =>   1.25,\n    'prose'                        =>   0.75,\n    'proteus'                      =>   0.75,\n    'Protocol Buffers'             =>   2.00,\n    'Pug'                          =>   2.00,\n    'Puppet'                       =>   2.00,\n    'PureScript'                   =>   2.00,\n    'qbasic'                       =>   1.38,\n    'qbe'                          =>   6.15,\n    'qmf'                          =>   5.33,\n    'QML'                          =>   1.25,\n    'Qt'                           =>   2.00,\n    'Qt Linguist'                  =>   1.00,\n    'Qt Project'                   =>   1.00,\n    'qnial'                        =>   1.63,\n    'quattro'                      =>  13.33,\n    'quattro pro'                  =>  13.33,\n    'query default'                =>   6.15,\n    'quick basic 1'                =>   1.25,\n    'quick basic 2'                =>   1.31,\n    'quick basic 3'                =>   1.38,\n    'quick c'                      =>   0.63,\n    'quickbuild'                   =>   2.86,\n    'quiz'                         =>   5.33,\n    'R'                            =>   3.00,\n    'Racket'                       =>   1.50,\n    'rally'                        =>   2.00,\n    'ramis ii'                     =>   2.00,\n    'rapidgen'                     =>   2.86,\n    'ratfor'                       =>   0.88,\n    'rdb'                          =>   2.00,\n    'realia'                       =>   1.74,\n    'realizer 1.0'                 =>   2.00,\n    'realizer 2.0'                 =>   2.22,\n    'relate/3000'                  =>   2.00,\n    'reuse default'                =>  16.00,\n    'Razor'                        =>   2.00,\n    'Rexx'                         =>   1.19,\n    'rm basic'                     =>   0.88,\n    'rm cobol'                     =>   0.75,\n    'rm fortran'                   =>   0.75,\n    'RobotFramework'               =>   2.50,\n    'rpg i'                        =>   1.00,\n    'rpg ii'                       =>   1.63,\n    'rpg iii'                      =>   1.63,\n    'rtexpert 1.4'                 =>   1.38,\n    'Rust'                         =>   1.00,\n    'sabretalk'                    =>   0.90,\n    'sail'                         =>   0.75,\n    'sapiens'                      =>   5.00,\n    'sas'                          =>   1.95,\n    'savvy'                        =>   6.15,\n    'sbasic'                       =>   0.88,\n    'Scala'                        =>   4.10,\n    'sceptre'                      =>   1.13,\n    'scheme'                       =>   1.51,\n    'screen painter default'       =>  13.33,\n    'sequal'                       =>   6.67,\n    'Slim'                         =>   3.00,\n    'Bourne Shell'                 =>   3.81,\n    'Bourne Again Shell'           =>   3.81,\n    'ksh'                          =>   3.81,\n    'zsh'                          =>   3.81,\n    'C Shell'                      =>   3.81,\n    'siebel tools '                =>   6.15,\n    'SAS'                          =>   1.5 ,\n    'Sass'                         =>   1.5 ,\n    'simplan'                      =>   2.22,\n    'simscript'                    =>   1.74,\n    'simula'                       =>   1.74,\n    'simula 67'                    =>   1.74,\n    'simulation default'           =>   1.74,\n    'SKILL'                        =>   2.00,\n    'SKILL++'                      =>   2.00,\n    'slogan'                       =>   0.98,\n    'Slice'                        =>   1.50,\n    'smalltalk'                    =>   2.50,\n    'smalltalk 286'                =>   3.81,\n    'smalltalk 80'                 =>   3.81,\n    'smalltalk/v'                  =>   3.81,\n    'Smarty'                       =>   3.50,\n    'snap'                         =>   1.00,\n    'snobol24'                     =>   0.63,\n    'softscreen'                   =>   5.71,\n    'Softbridge Basic'             =>   2.76,\n    'solo'                         =>   1.38,\n    'speakeasy'                    =>   2.22,\n    'spinnaker ppl'                =>   2.22,\n    'splus'                        =>   2.50,\n    'spreadsheet default'          =>  13.33,\n    'sps'                          =>   0.25,\n    'spss'                         =>   2.50,\n    'Specman e'                    =>   2.00,\n    'SQL'                          =>   2.29,\n    'sqlwindows'                   =>   6.67,\n    'statistical default'          =>   2.50,\n    'Standard ML'                  =>   3.00,\n    'strategem'                    =>   2.22,\n    'stress'                       =>   1.13,\n    'strongly typed default'       =>   0.88,\n    'style'                        =>   1.74,\n    'Stylus'                       =>   1.48,\n    'superbase 1.3'                =>   2.22,\n    'surpass'                      =>  13.33,\n    'Swift'                        =>   2.50,\n    'sybase'                       =>   2.00,\n    'symantec c++'                 =>   2.76,\n    'symbolang'                    =>   1.25,\n    'synchroworks'                 =>   4.44,\n    'synon/2e'                     =>   4.21,\n    'systemw'                      =>   2.22,\n    'tandem access language'       =>   0.88,\n    'Tcl/Tk'                       =>   4.00,\n    'Teamcenter def'               =>   1.00,\n    'Teamcenter met'               =>   1.00,\n    'Teamcenter mth'               =>   1.00,\n    'TeX'                          =>   1.50,\n    'telon'                        =>   5.00,\n    'tessaract'                    =>   2.00,\n    'the twin'                     =>  13.33,\n    'themis'                       =>   6.15,\n    'tiief'                        =>   5.71,\n    'Titanium Style Sheet'         =>   2.00,\n    'topspeed c++'                 =>   2.76,\n    'transform'                    =>   5.33,\n    'translisp plus'               =>   1.43,\n    'treet'                        =>   1.25,\n    'treetran'                     =>   1.25,\n    'trs80 basic'                  =>   0.63,\n    'true basic'                   =>   1.25,\n    'turbo c'                      =>   0.63,\n    'turbo expert'                 =>   1.63,\n    'turbo pascal >5'              =>   1.63,\n    'turbo pascal 14'              =>   1.00,\n    'turbo pascal 45'              =>   1.13,\n    'turing'                       =>   1.00,\n    'tutor'                        =>   1.51,\n    'twaice'                       =>   1.63,\n    'Twig'                         =>   2.00,\n    'TTCN'                         =>   2.00,\n    'TITAN Project File Information' =>   1.90,\n    'TypeScript'                   =>   2.00,\n    'ucsd pascal'                  =>   0.88,\n    'ufo/ims'                      =>   2.22,\n    'uhelp'                        =>   2.50,\n    'uniface'                      =>   5.00,\n    'Unity-Prefab'                 =>   2.50,\n    'Vala'                         =>   1.50,\n    'Vala Header'                  =>   1.40,\n    'vax acms'                     =>   1.38,\n    'vax ade'                      =>   2.00,\n    'vbscript'                     =>   2.35,\n    'vectran'                      =>   0.75,\n    'Verilog-SystemVerilog'        =>   1.51,\n    'VHDL'                         =>   4.21,\n    'vim script'                   =>   3.00,\n    'visible c'                    =>   1.63,\n    'visible cobol'                =>   2.00,\n    'visicalc 1'                   =>   8.89,\n    'visual 4.0'                   =>   2.76,\n    'visual basic'                 =>   1.90,\n    'visual basic 1'               =>   1.74,\n    'visual basic 2'               =>   1.86,\n    'visual basic 3'               =>   2.00,\n    'visual basic 4'               =>   2.22,\n    'visual basic 5'               =>   2.76,\n    'Visual Basic'                 =>   2.76,\n    'visual basic dos'             =>   2.00,\n    'visual c++'                   =>   2.35,\n    'visual cobol'                 =>   4.00,\n    'Visual Fox Pro'               =>   4.00, # Visual Fox Pro is not available in the language gearing ratios listed at Mayes Consulting web site\n    'visual objects'               =>   5.00,\n    'visualage'                    =>   3.81,\n    'Visualforce Component'        =>   1.9 ,\n    'Visualforce Page'             =>   1.9 ,\n    'visualgen'                    =>   4.44,\n    'VM'                           =>   2.00,\n    'vpf'                          =>   0.84,\n    'Vuejs Component'              =>   2.00,\n    'vulcan'                       =>   1.25,\n    'vz programmer'                =>   2.22,\n    'warp x'                       =>   2.00,\n    'watcom c'                     =>   0.63,\n    'watcom c/386'                 =>   0.63,\n    'waterloo c'                   =>   0.63,\n    'waterloo pascal'              =>   0.88,\n    'watfiv'                       =>   0.94,\n    'watfor'                       =>   0.88,\n    'web scripts'                  =>   5.33,\n    'whip'                         =>   0.88,\n    'Windows Message File'         =>   1.00,\n    'Windows Resource File'        =>   1.00,\n    'Windows Module Definition'    =>   1.00,\n    'WiX source'                   =>   1.90,\n    'WiX include'                  =>   1.90,\n    'WiX string localization'      =>   1.90,\n    'wizard'                       =>   2.86,\n    'xBase'                        =>   2.00,\n    'xBase Header'                 =>   2.00,\n    'xlisp'                        =>   1.25,\n    'XAML'                         =>   1.90,\n    'XQuery'                       =>   2.50,\n    'yacc'                         =>   1.51,\n    'yacc++'                       =>   1.51,\n    'YAML'                         =>   0.90,\n    'zbasic'                       =>   0.88,\n    'zim'                          =>   4.21,\n    'zlisp'                        =>   1.25,\n    'Expect'                       => 2.00,\n    'C/C++ Header'                 => 1.00,\n    'inc'                          => 1.00,\n    'lex'                          => 1.00,\n    'Julia'                        => 4.00,\n    'MATLAB'                       => 4.00,\n    'Mathematica'                  => 5.00,\n    'Mercury'                      => 3.00,\n    'Maven/XML'                    => 2.5,\n    'IDL'                          => 3.80,\n    'Octave'                       => 4.00,\n    'ML'                           => 3.00,\n    'Modula3'                      => 2.00,\n    'PHP'                          => 3.50,\n    'Python'                       => 4.20,\n    'RapydScript'                  => 4.20,\n    'Cython'                       => 3.80,\n    'Ruby'                         => 4.20,\n    'Ruby HTML'                    => 4.00,\n    'sed'                          => 4.00,\n    'Lua'                          => 4.00,\n    'OpenCL'                       => 1.50,\n);\n# 1}}}\n%{$rh_Known_Binary_Archives} = (             # {{{1\n            '.tar'     => 1 ,\n            '.tar.Z'   => 1 ,\n            '.tar.gz'  => 1 ,\n            '.tar.bz2' => 1 ,\n            '.zip'     => 1 ,\n            '.Zip'     => 1 ,\n            '.ZIP'     => 1 ,\n            '.ear'     => 1 ,  # Java\n            '.war'     => 1 ,  # contained within .ear\n            '.xz'      => 1 ,\n            );\n# 1}}}\n} # end sub set_constants()\nsub check_scale_existence {                  # {{{1\n    # do a few sanity checks\n    my ($rhaa_Filters_by_Language,\n        $rh_Language_by_Extension,\n        $rh_Scale_Factor) = @_;\n\n    my %extension_collisions = (\n        # TODO:  find a better way of dealing with these\n        \"PHP/Pascal\"                        => 1,\n        \"Lisp/OpenCL\"                       => 1,\n        \"Lisp/Julia\"                        => 1,\n        \"MATLAB/Mathematica/Objective C/MUMPS/Mercury\"  => 1,\n        \"Pascal/Puppet\"                     => 1,\n        \"Perl/Prolog\"                       => 1,\n        \"IDL/Qt Project/Prolog\"             => 1,\n        \"D/dtrace\"                          => 1,\n        \"Fortran 77/Forth\"                  => 1,\n        \"F#/Forth\"                          => 1,\n        \"Verilog-SystemVerilog/Coq\"         => 1,\n        \"TypeScript/Qt Linguist\"            => 1,\n        \"Qt/Glade\"                          => 1,\n    );\n    my $OK = 1;\n    foreach my $language (sort keys %{$rhaa_Filters_by_Language}) {\n        next if defined $extension_collisions{$language};\n        if (!defined $rh_Scale_Factor->{$language}) {\n            $OK = 0;\n            warn \"Missing scale factor for $language\\n\";\n        }\n    }\n\n    my %seen_it = ();\n    foreach my $ext (sort keys %{$rh_Language_by_Extension}) {\n        my $language = $rh_Language_by_Extension->{$ext};\n        next if defined $extension_collisions{$language};\n        next if $seen_it{$language};\n        if (!$rhaa_Filters_by_Language->{$language}) {\n            $OK = 0;\n            warn \"Missing language filter for $language\\n\";\n        }\n        $seen_it{$language} = 1;\n    }\n    die unless $OK;\n} # 1}}}\nsub Install_Regexp_Common {                  # {{{1\n    # Installs portions of Damian Conway's & Abigail's Regexp::Common\n    # module, version 2013031301 into a temporary directory for the\n    # duration of this run.\n    my %Regexp_Common_Contents = ();\n$Regexp_Common_Contents{'Common'} = <<'EOCommon'; # {{{2\npackage Regexp::Common;\n\nuse 5.00473;\nuse strict;\n\nBEGIN {\n    # This makes sure 'use warnings' doesn't bomb out on 5.005_*;\n    # warnings won't be enabled on those old versions though.\n    # Since all other files use this file, we can use 'use warnings'\n    # elsewhere as well, but *AFTER* 'use Regexp::Common'.\n    if ($] < 5.006) {\n        $INC {\"warnings.pm\"} = 1;\n        no strict 'refs';\n        *{\"warnings::unimport\"} = sub {0};\n    }\n}\n\nuse warnings;\nuse vars qw /$VERSION %RE %sub_interface $AUTOLOAD/;\n\n$VERSION = '2013031301';\n\n\nsub _croak {\n    require Carp;\n    goto &Carp::croak;\n}\n\nsub _carp {\n    require Carp;\n    goto &Carp::carp;\n}\n\nsub new {\n    my ($class, @data) = @_;\n    my %self;\n    tie %self, $class, @data;\n    return \\%self;\n}\n\nsub TIEHASH {\n    my ($class, @data) = @_;\n    bless \\@data, $class;\n}\n\nsub FETCH {\n    my ($self, $extra) = @_;\n    return bless ref($self)->new(@$self, $extra), ref($self);\n}\n\nmy %imports = map {$_ => \"Regexp::Common::$_\"}\n              qw /balanced CC     comment   delimited lingua list\n                  net      number profanity SEN       URI    whitespace\n                  zip/;\n\nsub import {\n    shift;  # Shift off the class.\n    tie %RE, __PACKAGE__;\n    {\n        no strict 'refs';\n        *{caller() . \"::RE\"} = \\%RE;\n    }\n\n    my $saw_import;\n    my $no_defaults;\n    my %exclude;\n    foreach my $entry (grep {!/^RE_/} @_) {\n        if ($entry eq 'pattern') {\n            no strict 'refs';\n            *{caller() . \"::pattern\"} = \\&pattern;\n            next;\n        }\n        # This used to prevent $; from being set. We still recognize it,\n        # but we won't do anything.\n        if ($entry eq 'clean') {\n            next;\n        }\n        if ($entry eq 'no_defaults') {\n            $no_defaults ++;\n            next;\n        }\n        if (my $module = $imports {$entry}) {\n            $saw_import ++;\n            eval \"require $module;\";\n            die $@ if $@;\n            next;\n        }\n        if ($entry =~ /^!(.*)/ && $imports {$1}) {\n            $exclude {$1} ++;\n            next;\n        }\n        # As a last resort, try to load the argument.\n        my $module = $entry =~ /^Regexp::Common/\n                            ? $entry\n                            : \"Regexp::Common::\" . $entry;\n        eval \"require $module;\";\n        die $@ if $@;\n    }\n\n    unless ($saw_import || $no_defaults) {\n        foreach my $module (values %imports) {\n            next if $exclude {$module};\n            eval \"require $module;\";\n            die $@ if $@;\n        }\n    }\n\n    my %exported;\n    foreach my $entry (grep {/^RE_/} @_) {\n        if ($entry =~ /^RE_(\\w+_)?ALL$/) {\n            my $m  = defined $1 ? $1 : \"\";\n            my $re = qr /^RE_${m}.*$/;\n            while (my ($sub, $interface) = each %sub_interface) {\n                next if $exported {$sub};\n                next unless $sub =~ /$re/;\n                {\n                    no strict 'refs';\n                    *{caller() . \"::$sub\"} = $interface;\n                }\n                $exported {$sub} ++;\n            }\n        }\n        else {\n            next if $exported {$entry};\n            _croak \"Can't export unknown subroutine &$entry\"\n                unless $sub_interface {$entry};\n            {\n                no strict 'refs';\n                *{caller() . \"::$entry\"} = $sub_interface {$entry};\n            }\n            $exported {$entry} ++;\n        }\n    }\n}\n\nsub AUTOLOAD { _croak \"Can't $AUTOLOAD\" }\n\nsub DESTROY {}\n\nmy %cache;\n\nmy $fpat = qr/^(-\\w+)/;\n\nsub _decache {\n        my @args = @{tied %{$_[0]}};\n        my @nonflags = grep {!/$fpat/} @args;\n        my $cache = get_cache(@nonflags);\n        _croak \"Can't create unknown regex: \\$RE{\"\n            . join(\"}{\",@args) . \"}\"\n                unless exists $cache->{__VAL__};\n        _croak \"Perl $] does not support the pattern \"\n            . \"\\$RE{\" . join(\"}{\",@args)\n            . \"}.\\nYou need Perl $cache->{__VAL__}{version} or later\"\n                unless ($cache->{__VAL__}{version}||0) <= $];\n        my %flags = ( %{$cache->{__VAL__}{default}},\n                      map { /$fpat\\Q$;\\E(.*)/ ? ($1 => $2)\n                          : /$fpat/           ? ($1 => undef)\n                          :                     ()\n                          } @args);\n        $cache->{__VAL__}->_clone_with(\\@args, \\%flags);\n}\n\nuse overload q{\"\"} => \\&_decache;\n\n\nsub get_cache {\n        my $cache = \\%cache;\n        foreach (@_) {\n                $cache = $cache->{$_}\n                      || ($cache->{$_} = {});\n        }\n        return $cache;\n}\n\nsub croak_version {\n        my ($entry, @args) = @_;\n}\n\nsub pattern {\n        my %spec = @_;\n        _croak 'pattern() requires argument: name => [ @list ]'\n                unless $spec{name} && ref $spec{name} eq 'ARRAY';\n        _croak 'pattern() requires argument: create => $sub_ref_or_string'\n                unless $spec{create};\n\n        if (ref $spec{create} ne \"CODE\") {\n                my $fixed_str = \"$spec{create}\";\n                $spec{create} = sub { $fixed_str }\n        }\n\n        my @nonflags;\n        my %default;\n        foreach ( @{$spec{name}} ) {\n                if (/$fpat=(.*)/) {\n                        $default{$1} = $2;\n                }\n                elsif (/$fpat\\s*$/) {\n                        $default{$1} = undef;\n                }\n                else {\n                        push @nonflags, $_;\n                }\n        }\n\n        my $entry = get_cache(@nonflags);\n\n        if ($entry->{__VAL__}) {\n                _carp \"Overriding \\$RE{\"\n                   . join(\"}{\",@nonflags)\n                   . \"}\";\n        }\n\n        $entry->{__VAL__} = bless {\n                                create  => $spec{create},\n                                match   => $spec{match} || \\&generic_match,\n                                subs    => $spec{subs}  || \\&generic_subs,\n                                version => $spec{version},\n                                default => \\%default,\n                            }, 'Regexp::Common::Entry';\n\n        foreach (@nonflags) {s/\\W/X/g}\n        my $subname = \"RE_\" . join (\"_\", @nonflags);\n        $sub_interface{$subname} = sub {\n                push @_ => undef if @_ % 2;\n                my %flags = @_;\n                my $pat = $spec{create}->($entry->{__VAL__},\n                               {%default, %flags}, \\@nonflags);\n                if (exists $flags{-keep}) { $pat =~ s/\\Q(?k:/(/g; }\n                else { $pat =~ s/\\Q(?k:/(?:/g; }\n                return exists $flags {-i} ? qr /(?i:$pat)/ : qr/$pat/;\n        };\n\n        return 1;\n}\n\nsub generic_match {$_ [1] =~  /$_[0]/}\nsub generic_subs  {$_ [1] =~ s/$_[0]/$_[2]/}\n\nsub matches {\n        my ($self, $str) = @_;\n        my $entry = $self -> _decache;\n        $entry -> {match} -> ($entry, $str);\n}\n\nsub subs {\n        my ($self, $str, $newstr) = @_;\n        my $entry = $self -> _decache;\n        $entry -> {subs} -> ($entry, $str, $newstr);\n        return $str;\n}\n\n\npackage Regexp::Common::Entry;\n# use Carp;\n\nuse overload\n    q{\"\"} => sub {\n        my ($self) = @_;\n        my $pat = $self->{create}->($self, $self->{flags}, $self->{args});\n        if (exists $self->{flags}{-keep}) {\n            $pat =~ s/\\Q(?k:/(/g;\n        }\n        else {\n            $pat =~ s/\\Q(?k:/(?:/g;\n        }\n        if (exists $self->{flags}{-i})   { $pat = \"(?i)$pat\" }\n        return $pat;\n    };\n\nsub _clone_with {\n    my ($self, $args, $flags) = @_;\n    bless { %$self, args=>$args, flags=>$flags }, ref $self;\n}\n\n1;\n#\n# This software is Copyright (c) 2001 - 2011, Damian Conway and Abigail.\n#\n# This module is free software, and maybe used under any of the following\n# licenses:\n#\n#  1) The Perl Artistic License.     See the file COPYRIGHT.AL.\n#  2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.\n#  3) The BSD Licence.               See the file COPYRIGHT.BSD.\n#  4) The MIT Licence.               See the file COPYRIGHT.MIT.\nEOCommon\n# 2}}}\n$Regexp_Common_Contents{'Common/comment'} = <<'EOC';   # {{{2\npackage Regexp::Common::comment;\n\nuse Regexp::Common qw /pattern clean no_defaults/;\n\nuse strict;\nuse warnings;\n\nuse vars qw /$VERSION/;\n$VERSION = '2010010201';\n\nmy @generic = (\n    {languages => [qw /ABC Forth/],\n     to_eol    => ['\\\\\\\\']},   # This is for just a *single* backslash.\n\n    {languages => [qw /Ada Alan Eiffel lua/],\n     to_eol    => ['--']},\n\n    {languages => [qw /Advisor/],\n     to_eol    => ['#|//']},\n\n    {languages => [qw /Advsys CQL Lisp LOGO M MUMPS REBOL Scheme\n                       SMITH zonefile/],\n     to_eol    => [';']},\n\n    {languages => ['Algol 60'],\n     from_to   => [[qw /comment ;/]]},\n\n    {languages => [qw {ALPACA B C C-- LPC PL/I}],\n     from_to   => [[qw {/* */}]]},\n\n    {languages => [qw /awk fvwm2 Icon m4 mutt Perl Python QML\n                       R Ruby shell Tcl/],\n     to_eol    => ['#']},\n\n    {languages => [[BASIC => 'mvEnterprise']],\n     to_eol    => ['[*!]|REM']},\n\n    {languages => [qw /Befunge-98 Funge-98 Shelta/],\n     id        => [';']},\n\n    {languages => ['beta-Juliet', 'Crystal Report', 'Portia', 'Ubercode'],\n     to_eol    => ['//']},\n\n    {languages => ['BML'],\n     from_to   => [['<?_c', '_c?>']],\n    },\n\n    {languages => [qw /C++/, 'C#', qw /AspectJ Cg ECMAScript FPL Java JavaScript JSX Stylus/],\n     to_eol    => ['//'],\n     from_to   => [[qw {/* */}]]},\n\n    {languages => [qw /CLU LaTeX slrn TeX/],\n     to_eol    => ['%']},\n\n    {languages => [qw /False/],\n     from_to   => [[qw !{ }!]]},\n\n    {languages => [qw /Fortran/],\n     to_eol    => ['!']},\n\n    {languages => [qw /Haifu/],\n     id        => [',']},\n\n    {languages => [qw /ILLGOL/],\n     to_eol    => ['NB']},\n\n    {languages => [qw /INTERCAL/],\n     to_eol    => [q{(?:(?:PLEASE(?:\\s+DO)?|DO)\\s+)?(?:NOT|N'T)}]},\n\n    {languages => [qw /J/],\n     to_eol    => ['NB[.]']},\n\n    {languages => [qw /JavaDoc/],\n     from_to   => [[qw {/** */}]]},\n\n    {languages => [qw /Nickle/],\n     to_eol    => ['#'],\n     from_to   => [[qw {/* */}]]},\n\n    {languages => [qw /Oberon/],\n     from_to   => [[qw /(* *)/]]},\n\n    {languages => [[qw /Pascal Delphi/], [qw /Pascal Free/], [qw /Pascal GPC/]],\n     to_eol    => ['//'],\n     from_to   => [[qw !{ }!], [qw !(* *)!]]},\n\n    {languages => [[qw /Pascal Workshop/]],\n     id        => [qw /\"/],\n     from_to   => [[qw !{ }!], [qw !(* *)!], [qw !/* */!]]},\n\n    {languages => [qw /PEARL/],\n     to_eol    => ['!'],\n     from_to   => [[qw {/* */}]]},\n\n    {languages => [qw /PHP/],\n     to_eol    => ['#', '//'],\n     from_to   => [[qw {/* */}]]},\n\n    {languages => [qw !PL/B!],\n     to_eol    => ['[.;]']},\n\n    {languages => [qw !PL/SQL!],\n     to_eol    => ['--'],\n     from_to   => [[qw {/* */}]]},\n\n    {languages => [qw /Q-BAL/],\n     to_eol    => ['`']},\n\n    {languages => [qw /Smalltalk/],\n     id        => ['\"']},\n\n    {languages => [qw /SQL/],\n     to_eol    => ['-{2,}']},\n\n    {languages => [qw /troff/],\n     to_eol    => ['\\\\\\\"']},\n\n    {languages => [qw /vi/],\n     to_eol    => ['\"']},\n\n    {languages => [qw /*W/],\n     from_to   => [[qw {|| !!}]]},\n\n    {languages => [qw /ZZT-OOP/],\n     to_eol    => [\"'\"]},\n);\n\nmy @plain_or_nested = (\n   [Caml         =>  undef,       \"(*\"  => \"*)\"],\n   [Dylan        =>  \"//\",        \"/*\"  => \"*/\"],\n   [Haskell      =>  \"-{2,}\",     \"{-\"  => \"-}\"],\n   [Hugo         =>  \"!(?!\\\\\\\\)\", \"!\\\\\" => \"\\\\!\"],\n   [SLIDE        =>  \"#\",         \"(*\"  => \"*)\"],\n  ['Modula-2'    =>  undef,       \"(*\"  => \"*)\"],\n  ['Modula-3'    =>  undef,       \"(*\"  => \"*)\"],\n);\n\n#\n# Helper subs.\n#\n\nsub combine      {\n    local $_ = join \"|\", @_;\n    if (@_ > 1) {\n        s/\\(\\?k:/(?:/g;\n        $_ = \"(?k:$_)\";\n    }\n    $_\n}\n\nsub to_eol  ($)  {\"(?k:(?k:$_[0])(?k:[^\\\\n]*)(?k:\\\\n))\"}\nsub id      ($)  {\"(?k:(?k:$_[0])(?k:[^$_[0]]*)(?k:$_[0]))\"}  # One char only!\nsub from_to      {\n    my ($begin, $end) = @_;\n\n    my $qb  = quotemeta $begin;\n    my $qe  = quotemeta $end;\n    my $fe  = quotemeta substr $end   => 0, 1;\n    my $te  = quotemeta substr $end   => 1;\n\n    \"(?k:(?k:$qb)(?k:(?:[^$fe]+|$fe(?!$te))*)(?k:$qe))\";\n}\n\n\nmy $count = 0;\nsub nested {\n    my ($begin, $end) = @_;\n\n    $count ++;\n    my $r = '(??{$Regexp::Common::comment ['. $count . ']})';\n\n    my $qb  = quotemeta $begin;\n    my $qe  = quotemeta $end;\n    my $fb  = quotemeta substr $begin => 0, 1;\n    my $fe  = quotemeta substr $end   => 0, 1;\n\n    my $tb  = quotemeta substr $begin => 1;\n    my $te  = quotemeta substr $end   => 1;\n\n    use re 'eval';\n\n    my $re;\n    if ($fb eq $fe) {\n        $re = qr /(?:$qb(?:(?>[^$fb]+)|$fb(?!$tb)(?!$te)|$r)*$qe)/;\n    }\n    else {\n        local $\"      =  \"|\";\n        my   @clauses =  \"(?>[^$fb$fe]+)\";\n        push @clauses => \"$fb(?!$tb)\" if length $tb;\n        push @clauses => \"$fe(?!$te)\" if length $te;\n        push @clauses =>  $r;\n        $re           =   qr /(?:$qb(?:@clauses)*$qe)/;\n    }\n\n    $Regexp::Common::comment [$count] = qr/$re/;\n}\n\n#\n# Process data.\n#\n\nforeach my $info (@plain_or_nested) {\n    my ($language, $mark, $begin, $end) = @$info;\n    pattern name    => [comment => $language],\n            create  =>\n                sub {my $re     = nested $begin => $end;\n                     my $prefix = defined $mark ? $mark . \"[^\\n]*\\n|\" : \"\";\n                     exists $_ [1] -> {-keep} ? qr /($prefix$re)/\n                                              : qr  /$prefix$re/\n                },\n            version => 5.006,\n            ;\n}\n\n\nforeach my $group (@generic) {\n    my $pattern = combine +(map {to_eol   $_} @{$group -> {to_eol}}),\n                           (map {from_to @$_} @{$group -> {from_to}}),\n                           (map {id       $_} @{$group -> {id}}),\n                  ;\n    foreach my $language  (@{$group -> {languages}}) {\n        pattern name    => [comment => ref $language ? @$language : $language],\n                create  => $pattern,\n                ;\n    }\n}\n\n\n\n#\n# Other languages.\n#\n\n# http://www.pascal-central.com/docs/iso10206.txt\npattern name    => [qw /comment Pascal/],\n        create  => '(?k:' . '(?k:[{]|[(][*])'\n                          . '(?k:[^}*]*(?:[*](?![)])[^}*]*)*)'\n                          . '(?k:[}]|[*][)])'\n                          . ')'\n        ;\n\n# http://www.templetons.com/brad/alice/language/\npattern name    =>  [qw /comment Pascal Alice/],\n        create  =>  '(?k:(?k:[{])(?k:[^}\\n]*)(?k:[}]))'\n        ;\n\n\n# http://westein.arb-phys.uni-dortmund.de/~wb/a68s.txt\npattern name    => [qw (comment), 'Algol 68'],\n        create  => q {(?k:(?:#[^#]*#)|}                           .\n                   q {(?:\\bco\\b(?:[^c]+|\\Bc|\\bc(?!o\\b))*\\bco\\b)|} .\n                   q {(?:\\bcomment\\b(?:[^c]+|\\Bc|\\bc(?!omment\\b))*\\bcomment\\b))}\n        ;\n\n\n# See rules 91 and 92 of ISO 8879 (SGML).\n# Charles F. Goldfarb: \"The SGML Handbook\".\n# Oxford: Oxford University Press. 1990. ISBN 0-19-853737-9.\n# Ch. 10.3, pp 390.\npattern name    => [qw (comment HTML)],\n        create  => q {(?k:(?k:<!)(?k:(?:--(?k:[^-]*(?:-[^-]+)*)--\\s*)*)(?k:>))},\n        ;\n\n\npattern name    => [qw /comment SQL MySQL/],\n        create  => q {(?k:(?:#|-- )[^\\n]*\\n|} .\n                   q {/\\*(?:(?>[^*;\"']+)|\"[^\"]*\"|'[^']*'|\\*(?!/))*(?:;|\\*/))},\n        ;\n\n# Anything that isn't <>[]+-.,\n# http://home.wxs.nl/~faase009/Ha_BF.html\npattern name    => [qw /comment Brainfuck/],\n        create  => '(?k:[^<>\\[\\]+\\-.,]+)'\n        ;\n\n# Squeak is a variant of Smalltalk-80.\n# http://www.squeak.\n# http://mucow.com/squeak-qref.html\npattern name    => [qw /comment Squeak/],\n        create  => '(?k:(?k:\")(?k:[^\"]*(?:\"\"[^\"]*)*)(?k:\"))'\n        ;\n\n#\n# Scores of less than 5 or above 17....\n# http://www.cliff.biffle.org/esoterica/beatnik.html\n@Regexp::Common::comment::scores = (1,  3,  3,  2,  1,  4,  2,  4,  1,  8,\n                                    5,  1,  3,  1,  1,  3, 10,  1,  1,  1,\n                                    1,  4,  4,  8,  4, 10);\n{\nmy ($s, $x);\npattern name    =>  [qw /comment Beatnik/],\n        create  =>  sub {\n            use re 'eval';\n            my $re = qr {\\b([A-Za-z]+)\\b\n                         (?(?{($s, $x) = (0, lc $^N);\n                              $s += $Regexp::Common::comment::scores\n                                    [ord (chop $x) - ord ('a')] while length $x;\n                              $s  >= 5 && $s < 18})XXX|)}x;\n            $re;\n        },\n        version  => 5.008,\n        ;\n}\n\n\n# http://www.cray.com/craydoc/manuals/007-3692-005/html-007-3692-005/\n#  (Goto table of contents/3.3 Source Form)\n# Fortran, in fixed format. Comments start with a C, c or * in the first\n# column, or a ! anywhere, but the sixth column. Then end with a newline.\npattern name    =>  [qw /comment Fortran fixed/],\n        create  =>  '(?k:(?k:(?:^[Cc*]|(?<!^.....)!))(?k:[^\\n]*)(?k:\\n))'\n        ;\n\n\n# http://www.csis.ul.ie/cobol/Course/COBOLIntro.htm\n# Traditionally, comments in COBOL were indicated with an asterisk in\n# the seventh column. Modern compilers may be more lenient.\npattern name    =>  [qw /comment COBOL/],\n        create  =>  '(?<=^......)(?k:(?k:[*])(?k:[^\\n]*)(?k:\\n))',\n        version =>  '5.008',\n        ;\n\n1;\nEOC\n# 2}}}\n$Regexp_Common_Contents{'Common/balanced'} = <<'EOB';   # {{{2\npackage Regexp::Common::balanced; {\n\nuse Regexp::Common qw /pattern clean no_defaults/;\n\nuse strict;\nuse warnings;\n\nuse vars qw /$VERSION/;\n$VERSION = '2013030901';\n\nmy %closer = ( '{'=>'}', '('=>')', '['=>']', '<'=>'>' );\nmy %cache;\n\nsub nested {\n    my ($start, $finish) = @_;\n\n    return $cache {$start} {$finish} if exists $cache {$start} {$finish};\n\n    my @starts   = map {s/\\\\(.)/$1/g; $_} grep {length}\n                        $start  =~ /([^|\\\\]+|\\\\.)+/gs;\n    my @finishes = map {s/\\\\(.)/$1/g; $_} grep {length}\n                        $finish =~ /([^|\\\\]+|\\\\.)+/gs;\n\n    push @finishes => ($finishes [-1]) x (@starts - @finishes);\n\n    my @re;\n    local $\" = \"|\";\n    foreach my $begin (@starts) {\n        my $end = shift @finishes;\n\n        my $qb  = quotemeta $begin;\n        my $qe  = quotemeta $end;\n        my $fb  = quotemeta substr $begin => 0, 1;\n        my $fe  = quotemeta substr $end   => 0, 1;\n\n        my $tb  = quotemeta substr $begin => 1;\n        my $te  = quotemeta substr $end   => 1;\n\n        my $add;\n        if ($fb eq $fe) {\n            push @re =>\n                   qq /(?:$qb(?:(?>[^$fb]+)|$fb(?!$tb)(?!$te)|(?-1))*$qe)/;\n        }\n        else {\n            my   @clauses =  \"(?>[^$fb$fe]+)\";\n            push @clauses => \"$fb(?!$tb)\" if length $tb;\n            push @clauses => \"$fe(?!$te)\" if length $te;\n            push @clauses => \"(?-1)\";\n            push @re      =>  qq /(?:$qb(?:@clauses)*$qe)/;\n        }\n    }\n\n    $cache {$start} {$finish} = qr /(@re)/;\n}\n\n\npattern name    => [qw /balanced -parens=() -begin= -end=/],\n        create  => sub {\n            my $flag = $_[1];\n            unless (defined $flag -> {-begin} && length $flag -> {-begin} &&\n                    defined $flag -> {-end}   && length $flag -> {-end}) {\n                my @open  = grep {index ($flag->{-parens}, $_) >= 0}\n                             ('[','(','{','<');\n                my @close = map {$closer {$_}} @open;\n                $flag -> {-begin} = join \"|\" => @open;\n                $flag -> {-end}   = join \"|\" => @close;\n            }\n            return nested @$flag {qw /-begin -end/};\n        },\n        version => 5.010,\n        ;\n\n}\n\n1;\n# This software is Copyright (c) 2001 - 2013, Damian Conway and Abigail.\n#\n# This module is free software, and maybe used under any of the following\n# licenses:\n#\n#  1) The Perl Artistic License.     See the file COPYRIGHT.AL.\n#  2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.\n#  3) The BSD Licence.               See the file COPYRIGHT.BSD.\n#  4) The MIT Licence.               See the file COPYRIGHT.MIT.\nEOB\n# 2}}}\n$Regexp_Common_Contents{'Common/delimited'} = <<'EOD';   # {{{3\npackage Regexp::Common::delimited;\n\nuse Regexp::Common qw /pattern clean no_defaults/;\n\nuse strict;\nuse warnings;\n\nuse vars qw /$VERSION/;\n$VERSION = '2010010201';\n\nsub gen_delimited {\n\n    my ($dels, $escs) = @_;\n    # return '(?:\\S*)' unless $dels =~ /\\S/;\n    if (length $escs) {\n        $escs .= substr ($escs, -1) x (length ($dels) - length ($escs));\n    }\n    my @pat = ();\n    my $i;\n    for ($i=0; $i < length $dels; $i++) {\n        my $del = quotemeta substr ($dels, $i, 1);\n        my $esc = length($escs) ? quotemeta substr ($escs, $i, 1) : \"\";\n        if ($del eq $esc) {\n            push @pat,\n                 \"(?k:$del)(?k:[^$del]*(?:(?:$del$del)[^$del]*)*)(?k:$del)\";\n        }\n        elsif (length $esc) {\n            push @pat,\n                 \"(?k:$del)(?k:[^$esc$del]*(?:$esc.[^$esc$del]*)*)(?k:$del)\";\n        }\n        else {\n            push @pat, \"(?k:$del)(?k:[^$del]*)(?k:$del)\";\n        }\n    }\n    my $pat = join '|', @pat;\n    return \"(?k:$pat)\";\n}\n\nsub _croak {\n    require Carp;\n    goto &Carp::croak;\n}\n\npattern name   => [qw( delimited -delim= -esc=\\\\ )],\n        create => sub {my $flags = $_[1];\n                       _croak 'Must specify delimiter in $RE{delimited}'\n                             unless length $flags->{-delim};\n                       return gen_delimited (@{$flags}{-delim, -esc});\n                  },\n        ;\n\npattern name   => [qw( quoted -esc=\\\\ )],\n        create => sub {my $flags = $_[1];\n                       return gen_delimited (q{\"'`}, $flags -> {-esc});\n                  },\n        ;\n\n\n1;\n# This software is Copyright (c) 2001 - 2009, Damian Conway and Abigail.\n#\n# This module is free software, and maybe used under any of the following\n# licenses:\n#\n#  1) The Perl Artistic License.     See the file COPYRIGHT.AL.\n#  2) The Perl Artistic License 2.0. See the file COPYRIGHT.AL2.\n#  3) The BSD Licence.               See the file COPYRIGHT.BSD.\n#  4) The MIT Licence.               See the file COPYRIGHT.MIT.\nEOD\n# 2}}}\n    my $problems        = 0;\n    $HAVE_Rexexp_Common = 0;\n    my $dir             = \"\";\n    if ($opt_sdir) {\n        ++$TEMP_OFF;\n        $dir = \"$opt_sdir/$TEMP_OFF\";\n        File::Path::rmtree($dir) if     is_dir($dir);\n        File::Path::mkpath($dir) unless is_dir($dir);\n    } else {\n        # let File::Temp create a suitable temporary directory\n        $dir = tempdir( CLEANUP => 1 );  # 1 = delete on exit\n        $TEMP_INST{ $dir } = \"Regexp::Common\";\n    }\n    print \"Using temp dir [$dir] to install Regexp::Common\\n\" if $opt_v;\n    my $Regexp_dir        = \"$dir/Regexp\";\n    my $Regexp_Common_dir = \"$dir/Regexp/Common\";\n    mkdir $Regexp_dir       ;\n    mkdir $Regexp_Common_dir;\n\n    foreach my $module_file (keys %Regexp_Common_Contents) {\n        my $OUT = new IO::File \"$dir/Regexp/${module_file}.pm\", \"w\";\n        if (defined $OUT) {\n            print $OUT $Regexp_Common_Contents{$module_file};\n            $OUT->close;\n        } else {\n            warn \"Failed to install Regexp::${module_file}.pm\\n\";\n            $problems = 1;\n        }\n    }\n\n    push @INC, $dir;\n    eval \"use Regexp::Common qw /comment RE_comment_HTML balanced/\";\n    $HAVE_Rexexp_Common = 1 unless $problems;\n} # 1}}}\nsub Install_Algorithm_Diff {                 # {{{1\n    # Installs Tye McQueen's Algorithm::Diff module, v1.1902, into a\n    # temporary directory for the duration of this run.\n\nmy $Algorithm_Diff_Contents = <<'EOAlgDiff'; # {{{2\npackage Algorithm::Diff;\n# Skip to first \"=head\" line for documentation.\nuse strict;\n\nuse integer;    # see below in _replaceNextLargerWith() for mod to make\n                # if you don't use this\nuse vars qw( $VERSION @EXPORT_OK );\n$VERSION = 1.19_02;\n#          ^ ^^ ^^-- Incremented at will\n#          | \\+----- Incremented for non-trivial changes to features\n#          \\-------- Incremented for fundamental changes\nrequire Exporter;\n*import    = \\&Exporter::import;\n@EXPORT_OK = qw(\n    prepare LCS LCSidx LCS_length\n    diff sdiff compact_diff\n    traverse_sequences traverse_balanced\n);\n\n# McIlroy-Hunt diff algorithm\n# Adapted from the Smalltalk code of Mario I. Wolczko, <mario@wolczko.com>\n# by Ned Konz, perl@bike-nomad.com\n# Updates by Tye McQueen, http://perlmonks.org/?node=tye\n\n# Create a hash that maps each element of $aCollection to the set of\n# positions it occupies in $aCollection, restricted to the elements\n# within the range of indexes specified by $start and $end.\n# The fourth parameter is a subroutine reference that will be called to\n# generate a string to use as a key.\n# Additional parameters, if any, will be passed to this subroutine.\n#\n# my $hashRef = _withPositionsOfInInterval( \\@array, $start, $end, $keyGen );\n\nsub _withPositionsOfInInterval\n{\n    my $aCollection = shift;    # array ref\n    my $start       = shift;\n    my $end         = shift;\n    my $keyGen      = shift;\n    my %d;\n    my $index;\n    for ( $index = $start ; $index <= $end ; $index++ )\n    {\n        my $element = $aCollection->[$index];\n        my $key = &$keyGen( $element, @_ );\n        if ( exists( $d{$key} ) )\n        {\n            unshift ( @{ $d{$key} }, $index );\n        }\n        else\n        {\n            $d{$key} = [$index];\n        }\n    }\n    return wantarray ? %d : \\%d;\n}\n\n# Find the place at which aValue would normally be inserted into the\n# array. If that place is already occupied by aValue, do nothing, and\n# return undef. If the place does not exist (i.e., it is off the end of\n# the array), add it to the end, otherwise replace the element at that\n# point with aValue.  It is assumed that the array's values are numeric.\n# This is where the bulk (75%) of the time is spent in this module, so\n# try to make it fast!\n\nsub _replaceNextLargerWith\n{\n    my ( $array, $aValue, $high ) = @_;\n    $high ||= $#$array;\n\n    # off the end?\n    if ( $high == -1 || $aValue > $array->[-1] )\n    {\n        push ( @$array, $aValue );\n        return $high + 1;\n    }\n\n    # binary search for insertion point...\n    my $low = 0;\n    my $index;\n    my $found;\n    while ( $low <= $high )\n    {\n        $index = ( $high + $low ) / 2;\n\n        # $index = int(( $high + $low ) / 2);  # without 'use integer'\n        $found = $array->[$index];\n\n        if ( $aValue == $found )\n        {\n            return undef;\n        }\n        elsif ( $aValue > $found )\n        {\n            $low = $index + 1;\n        }\n        else\n        {\n            $high = $index - 1;\n        }\n    }\n\n    # now insertion point is in $low.\n    $array->[$low] = $aValue;    # overwrite next larger\n    return $low;\n}\n\n# This method computes the longest common subsequence in $a and $b.\n\n# Result is array or ref, whose contents is such that\n#   $a->[ $i ] == $b->[ $result[ $i ] ]\n# foreach $i in ( 0 .. $#result ) if $result[ $i ] is defined.\n\n# An additional argument may be passed; this is a hash or key generating\n# function that should return a string that uniquely identifies the given\n# element.  It should be the case that if the key is the same, the elements\n# will compare the same. If this parameter is undef or missing, the key\n# will be the element as a string.\n\n# By default, comparisons will use \"eq\" and elements will be turned into keys\n# using the default stringizing operator '\"\"'.\n\n# Additional parameters, if any, will be passed to the key generation\n# routine.\n\nsub _longestCommonSubsequence\n{\n    my $a        = shift;    # array ref or hash ref\n    my $b        = shift;    # array ref or hash ref\n    my $counting = shift;    # scalar\n    my $keyGen   = shift;    # code ref\n    my $compare;             # code ref\n\n    if ( ref($a) eq 'HASH' )\n    {                        # prepared hash must be in $b\n        my $tmp = $b;\n        $b = $a;\n        $a = $tmp;\n    }\n\n    # Check for bogus (non-ref) argument values\n    if ( !ref($a) || !ref($b) )\n    {\n        my @callerInfo = caller(1);\n        die 'error: must pass array or hash references to ' . $callerInfo[3];\n    }\n\n    # set up code refs\n    # Note that these are optimized.\n    if ( !defined($keyGen) )    # optimize for strings\n    {\n        $keyGen = sub { $_[0] };\n        $compare = sub { my ( $a, $b ) = @_; $a eq $b };\n    }\n    else\n    {\n        $compare = sub {\n            my $a = shift;\n            my $b = shift;\n            &$keyGen( $a, @_ ) eq &$keyGen( $b, @_ );\n        };\n    }\n\n    my ( $aStart, $aFinish, $matchVector ) = ( 0, $#$a, [] );\n    my ( $prunedCount, $bMatches ) = ( 0, {} );\n\n    if ( ref($b) eq 'HASH' )    # was $bMatches prepared for us?\n    {\n        $bMatches = $b;\n    }\n    else\n    {\n        my ( $bStart, $bFinish ) = ( 0, $#$b );\n\n        # First we prune off any common elements at the beginning\n        while ( $aStart <= $aFinish\n            and $bStart <= $bFinish\n            and &$compare( $a->[$aStart], $b->[$bStart], @_ ) )\n        {\n            $matchVector->[ $aStart++ ] = $bStart++;\n            $prunedCount++;\n        }\n\n        # now the end\n        while ( $aStart <= $aFinish\n            and $bStart <= $bFinish\n            and &$compare( $a->[$aFinish], $b->[$bFinish], @_ ) )\n        {\n            $matchVector->[ $aFinish-- ] = $bFinish--;\n            $prunedCount++;\n        }\n\n        # Now compute the equivalence classes of positions of elements\n        $bMatches =\n          _withPositionsOfInInterval( $b, $bStart, $bFinish, $keyGen, @_ );\n    }\n    my $thresh = [];\n    my $links  = [];\n\n    my ( $i, $ai, $j, $k );\n    for ( $i = $aStart ; $i <= $aFinish ; $i++ )\n    {\n        $ai = &$keyGen( $a->[$i], @_ );\n        if ( exists( $bMatches->{$ai} ) )\n        {\n            $k = 0;\n            for $j ( @{ $bMatches->{$ai} } )\n            {\n\n                # optimization: most of the time this will be true\n                if ( $k and $thresh->[$k] > $j and $thresh->[ $k - 1 ] < $j )\n                {\n                    $thresh->[$k] = $j;\n                }\n                else\n                {\n                    $k = _replaceNextLargerWith( $thresh, $j, $k );\n                }\n\n                # oddly, it's faster to always test this (CPU cache?).\n                if ( defined($k) )\n                {\n                    $links->[$k] =\n                      [ ( $k ? $links->[ $k - 1 ] : undef ), $i, $j ];\n                }\n            }\n        }\n    }\n\n    if (@$thresh)\n    {\n        return $prunedCount + @$thresh if $counting;\n        for ( my $link = $links->[$#$thresh] ; $link ; $link = $link->[0] )\n        {\n            $matchVector->[ $link->[1] ] = $link->[2];\n        }\n    }\n    elsif ($counting)\n    {\n        return $prunedCount;\n    }\n\n    return wantarray ? @$matchVector : $matchVector;\n}\n\nsub traverse_sequences\n{\n    my $a                 = shift;          # array ref\n    my $b                 = shift;          # array ref\n    my $callbacks         = shift || {};\n    my $keyGen            = shift;\n    my $matchCallback     = $callbacks->{'MATCH'} || sub { };\n    my $discardACallback  = $callbacks->{'DISCARD_A'} || sub { };\n    my $finishedACallback = $callbacks->{'A_FINISHED'};\n    my $discardBCallback  = $callbacks->{'DISCARD_B'} || sub { };\n    my $finishedBCallback = $callbacks->{'B_FINISHED'};\n    my $matchVector = _longestCommonSubsequence( $a, $b, 0, $keyGen, @_ );\n\n    # Process all the lines in @$matchVector\n    my $lastA = $#$a;\n    my $lastB = $#$b;\n    my $bi    = 0;\n    my $ai;\n\n    for ( $ai = 0 ; $ai <= $#$matchVector ; $ai++ )\n    {\n        my $bLine = $matchVector->[$ai];\n        if ( defined($bLine) )    # matched\n        {\n            &$discardBCallback( $ai, $bi++, @_ ) while $bi < $bLine;\n            &$matchCallback( $ai,    $bi++, @_ );\n        }\n        else\n        {\n            &$discardACallback( $ai, $bi, @_ );\n        }\n    }\n\n    # The last entry (if any) processed was a match.\n    # $ai and $bi point just past the last matching lines in their sequences.\n\n    while ( $ai <= $lastA or $bi <= $lastB )\n    {\n\n        # last A?\n        if ( $ai == $lastA + 1 and $bi <= $lastB )\n        {\n            if ( defined($finishedACallback) )\n            {\n                &$finishedACallback( $lastA, @_ );\n                $finishedACallback = undef;\n            }\n            else\n            {\n                &$discardBCallback( $ai, $bi++, @_ ) while $bi <= $lastB;\n            }\n        }\n\n        # last B?\n        if ( $bi == $lastB + 1 and $ai <= $lastA )\n        {\n            if ( defined($finishedBCallback) )\n            {\n                &$finishedBCallback( $lastB, @_ );\n                $finishedBCallback = undef;\n            }\n            else\n            {\n                &$discardACallback( $ai++, $bi, @_ ) while $ai <= $lastA;\n            }\n        }\n\n        &$discardACallback( $ai++, $bi, @_ ) if $ai <= $lastA;\n        &$discardBCallback( $ai, $bi++, @_ ) if $bi <= $lastB;\n    }\n\n    return 1;\n}\n\nsub traverse_balanced\n{\n    my $a                 = shift;              # array ref\n    my $b                 = shift;              # array ref\n    my $callbacks         = shift || {};\n    my $keyGen            = shift;\n    my $matchCallback     = $callbacks->{'MATCH'} || sub { };\n    my $discardACallback  = $callbacks->{'DISCARD_A'} || sub { };\n    my $discardBCallback  = $callbacks->{'DISCARD_B'} || sub { };\n    my $changeCallback    = $callbacks->{'CHANGE'};\n    my $matchVector = _longestCommonSubsequence( $a, $b, 0, $keyGen, @_ );\n\n    # Process all the lines in match vector\n    my $lastA = $#$a;\n    my $lastB = $#$b;\n    my $bi    = 0;\n    my $ai    = 0;\n    my $ma    = -1;\n    my $mb;\n\n    while (1)\n    {\n\n        # Find next match indices $ma and $mb\n        do {\n            $ma++;\n        } while(\n                $ma <= $#$matchVector\n            &&  !defined $matchVector->[$ma]\n        );\n\n        last if $ma > $#$matchVector;    # end of matchVector?\n        $mb = $matchVector->[$ma];\n\n        # Proceed with discard a/b or change events until\n        # next match\n        while ( $ai < $ma || $bi < $mb )\n        {\n\n            if ( $ai < $ma && $bi < $mb )\n            {\n\n                # Change\n                if ( defined $changeCallback )\n                {\n                    &$changeCallback( $ai++, $bi++, @_ );\n                }\n                else\n                {\n                    &$discardACallback( $ai++, $bi, @_ );\n                    &$discardBCallback( $ai, $bi++, @_ );\n                }\n            }\n            elsif ( $ai < $ma )\n            {\n                &$discardACallback( $ai++, $bi, @_ );\n            }\n            else\n            {\n\n                # $bi < $mb\n                &$discardBCallback( $ai, $bi++, @_ );\n            }\n        }\n\n        # Match\n        &$matchCallback( $ai++, $bi++, @_ );\n    }\n\n    while ( $ai <= $lastA || $bi <= $lastB )\n    {\n        if ( $ai <= $lastA && $bi <= $lastB )\n        {\n\n            # Change\n            if ( defined $changeCallback )\n            {\n                &$changeCallback( $ai++, $bi++, @_ );\n            }\n            else\n            {\n                &$discardACallback( $ai++, $bi, @_ );\n                &$discardBCallback( $ai, $bi++, @_ );\n            }\n        }\n        elsif ( $ai <= $lastA )\n        {\n            &$discardACallback( $ai++, $bi, @_ );\n        }\n        else\n        {\n\n            # $bi <= $lastB\n            &$discardBCallback( $ai, $bi++, @_ );\n        }\n    }\n\n    return 1;\n}\n\nsub prepare\n{\n    my $a       = shift;    # array ref\n    my $keyGen  = shift;    # code ref\n\n    # set up code ref\n    $keyGen = sub { $_[0] } unless defined($keyGen);\n\n    return scalar _withPositionsOfInInterval( $a, 0, $#$a, $keyGen, @_ );\n}\n\nsub LCS\n{\n    my $a = shift;                  # array ref\n    my $b = shift;                  # array ref or hash ref\n    my $matchVector = _longestCommonSubsequence( $a, $b, 0, @_ );\n    my @retval;\n    my $i;\n    for ( $i = 0 ; $i <= $#$matchVector ; $i++ )\n    {\n        if ( defined( $matchVector->[$i] ) )\n        {\n            push ( @retval, $a->[$i] );\n        }\n    }\n    return wantarray ? @retval : \\@retval;\n}\n\nsub LCS_length\n{\n    my $a = shift;                          # array ref\n    my $b = shift;                          # array ref or hash ref\n    return _longestCommonSubsequence( $a, $b, 1, @_ );\n}\n\nsub LCSidx\n{\n    my $a= shift @_;\n    my $b= shift @_;\n    my $match= _longestCommonSubsequence( $a, $b, 0, @_ );\n    my @am= grep defined $match->[$_], 0..$#$match;\n    my @bm= @{$match}[@am];\n    return \\@am, \\@bm;\n}\n\nsub compact_diff\n{\n    my $a= shift @_;\n    my $b= shift @_;\n    my( $am, $bm )= LCSidx( $a, $b, @_ );\n    my @cdiff;\n    my( $ai, $bi )= ( 0, 0 );\n    push @cdiff, $ai, $bi;\n    while( 1 ) {\n        while(  @$am  &&  $ai == $am->[0]  &&  $bi == $bm->[0]  ) {\n            shift @$am;\n            shift @$bm;\n            ++$ai, ++$bi;\n        }\n        push @cdiff, $ai, $bi;\n        last   if  ! @$am;\n        $ai = $am->[0];\n        $bi = $bm->[0];\n        push @cdiff, $ai, $bi;\n    }\n    push @cdiff, 0+@$a, 0+@$b\n        if  $ai < @$a || $bi < @$b;\n    return wantarray ? @cdiff : \\@cdiff;\n}\n\nsub diff\n{\n    my $a      = shift;    # array ref\n    my $b      = shift;    # array ref\n    my $retval = [];\n    my $hunk   = [];\n    my $discard = sub {\n        push @$hunk, [ '-', $_[0], $a->[ $_[0] ] ];\n    };\n    my $add = sub {\n        push @$hunk, [ '+', $_[1], $b->[ $_[1] ] ];\n    };\n    my $match = sub {\n        push @$retval, $hunk\n            if 0 < @$hunk;\n        $hunk = []\n    };\n    traverse_sequences( $a, $b,\n        { MATCH => $match, DISCARD_A => $discard, DISCARD_B => $add }, @_ );\n    &$match();\n    return wantarray ? @$retval : $retval;\n}\n\nsub sdiff\n{\n    my $a      = shift;    # array ref\n    my $b      = shift;    # array ref\n    my $retval = [];\n    my $discard = sub { push ( @$retval, [ '-', $a->[ $_[0] ], \"\" ] ) };\n    my $add = sub { push ( @$retval, [ '+', \"\", $b->[ $_[1] ] ] ) };\n    my $change = sub {\n        push ( @$retval, [ 'c', $a->[ $_[0] ], $b->[ $_[1] ] ] );\n    };\n    my $match = sub {\n        push ( @$retval, [ 'u', $a->[ $_[0] ], $b->[ $_[1] ] ] );\n    };\n    traverse_balanced(\n        $a,\n        $b,\n        {\n            MATCH     => $match,\n            DISCARD_A => $discard,\n            DISCARD_B => $add,\n            CHANGE    => $change,\n        },\n        @_\n    );\n    return wantarray ? @$retval : $retval;\n}\n\n########################################\nmy $Root= __PACKAGE__;\npackage Algorithm::Diff::_impl;\nuse strict;\n\nsub _Idx()  { 0 } # $me->[_Idx]: Ref to array of hunk indices\n            # 1   # $me->[1]: Ref to first sequence\n            # 2   # $me->[2]: Ref to second sequence\nsub _End()  { 3 } # $me->[_End]: Diff between forward and reverse pos\nsub _Same() { 4 } # $me->[_Same]: 1 if pos 1 contains unchanged items\nsub _Base() { 5 } # $me->[_Base]: Added to range's min and max\nsub _Pos()  { 6 } # $me->[_Pos]: Which hunk is currently selected\nsub _Off()  { 7 } # $me->[_Off]: Offset into _Idx for current position\nsub _Min() { -2 } # Added to _Off to get min instead of max+1\n\nsub Die\n{\n    require Carp;\n    Carp::confess( @_ );\n}\n\nsub _ChkPos\n{\n    my( $me )= @_;\n    return   if  $me->[_Pos];\n    my $meth= ( caller(1) )[3];\n    Die( \"Called $meth on 'reset' object\" );\n}\n\nsub _ChkSeq\n{\n    my( $me, $seq )= @_;\n    return $seq + $me->[_Off]\n        if  1 == $seq  ||  2 == $seq;\n    my $meth= ( caller(1) )[3];\n    Die( \"$meth: Invalid sequence number ($seq); must be 1 or 2\" );\n}\n\nsub getObjPkg\n{\n    my( $us )= @_;\n    return ref $us   if  ref $us;\n    return $us . \"::_obj\";\n}\n\nsub new\n{\n    my( $us, $seq1, $seq2, $opts ) = @_;\n    my @args;\n    for( $opts->{keyGen} ) {\n        push @args, $_   if  $_;\n    }\n    for( $opts->{keyGenArgs} ) {\n        push @args, @$_   if  $_;\n    }\n    my $cdif= Algorithm::Diff::compact_diff( $seq1, $seq2, @args );\n    my $same= 1;\n    if(  0 == $cdif->[2]  &&  0 == $cdif->[3]  ) {\n        $same= 0;\n        splice @$cdif, 0, 2;\n    }\n    my @obj= ( $cdif, $seq1, $seq2 );\n    $obj[_End] = (1+@$cdif)/2;\n    $obj[_Same] = $same;\n    $obj[_Base] = 0;\n    my $me = bless \\@obj, $us->getObjPkg();\n    $me->Reset( 0 );\n    return $me;\n}\n\nsub Reset\n{\n    my( $me, $pos )= @_;\n    $pos= int( $pos || 0 );\n    $pos += $me->[_End]\n        if  $pos < 0;\n    $pos= 0\n        if  $pos < 0  ||  $me->[_End] <= $pos;\n    $me->[_Pos]= $pos || !1;\n    $me->[_Off]= 2*$pos - 1;\n    return $me;\n}\n\nsub Base\n{\n    my( $me, $base )= @_;\n    my $oldBase= $me->[_Base];\n    $me->[_Base]= 0+$base   if  defined $base;\n    return $oldBase;\n}\n\nsub Copy\n{\n    my( $me, $pos, $base )= @_;\n    my @obj= @$me;\n    my $you= bless \\@obj, ref($me);\n    $you->Reset( $pos )   if  defined $pos;\n    $you->Base( $base );\n    return $you;\n}\n\nsub Next {\n    my( $me, $steps )= @_;\n    $steps= 1   if  ! defined $steps;\n    if( $steps ) {\n        my $pos= $me->[_Pos];\n        my $new= $pos + $steps;\n        $new= 0   if  $pos  &&  $new < 0;\n        $me->Reset( $new )\n    }\n    return $me->[_Pos];\n}\n\nsub Prev {\n    my( $me, $steps )= @_;\n    $steps= 1   if  ! defined $steps;\n    my $pos= $me->Next(-$steps);\n    $pos -= $me->[_End]   if  $pos;\n    return $pos;\n}\n\nsub Diff {\n    my( $me )= @_;\n    $me->_ChkPos();\n    return 0   if  $me->[_Same] == ( 1 & $me->[_Pos] );\n    my $ret= 0;\n    my $off= $me->[_Off];\n    for my $seq ( 1, 2 ) {\n        $ret |= $seq\n            if  $me->[_Idx][ $off + $seq + _Min ]\n            <   $me->[_Idx][ $off + $seq ];\n    }\n    return $ret;\n}\n\nsub Min {\n    my( $me, $seq, $base )= @_;\n    $me->_ChkPos();\n    my $off= $me->_ChkSeq($seq);\n    $base= $me->[_Base] if !defined $base;\n    return $base + $me->[_Idx][ $off + _Min ];\n}\n\nsub Max {\n    my( $me, $seq, $base )= @_;\n    $me->_ChkPos();\n    my $off= $me->_ChkSeq($seq);\n    $base= $me->[_Base] if !defined $base;\n    return $base + $me->[_Idx][ $off ] -1;\n}\n\nsub Range {\n    my( $me, $seq, $base )= @_;\n    $me->_ChkPos();\n    my $off = $me->_ChkSeq($seq);\n    if( !wantarray ) {\n        return  $me->[_Idx][ $off ]\n            -   $me->[_Idx][ $off + _Min ];\n    }\n    $base= $me->[_Base] if !defined $base;\n    return  ( $base + $me->[_Idx][ $off + _Min ] )\n        ..  ( $base + $me->[_Idx][ $off ] - 1 );\n}\n\nsub Items {\n    my( $me, $seq )= @_;\n    $me->_ChkPos();\n    my $off = $me->_ChkSeq($seq);\n    if( !wantarray ) {\n        return  $me->[_Idx][ $off ]\n            -   $me->[_Idx][ $off + _Min ];\n    }\n    return\n        @{$me->[$seq]}[\n                $me->[_Idx][ $off + _Min ]\n            ..  ( $me->[_Idx][ $off ] - 1 )\n        ];\n}\n\nsub Same {\n    my( $me )= @_;\n    $me->_ChkPos();\n    return wantarray ? () : 0\n        if  $me->[_Same] != ( 1 & $me->[_Pos] );\n    return $me->Items(1);\n}\n\nmy %getName;\nBEGIN {\n    %getName= (\n        same => \\&Same,\n        diff => \\&Diff,\n        base => \\&Base,\n        min  => \\&Min,\n        max  => \\&Max,\n        range=> \\&Range,\n        items=> \\&Items, # same thing\n    );\n}\n\nsub Get\n{\n    my $me= shift @_;\n    $me->_ChkPos();\n    my @value;\n    for my $arg (  @_  ) {\n        for my $word (  split ' ', $arg  ) {\n            my $meth;\n            if(     $word !~ /^(-?\\d+)?([a-zA-Z]+)([12])?$/\n                ||  not  $meth= $getName{ lc $2 }\n            ) {\n                Die( $Root, \", Get: Invalid request ($word)\" );\n            }\n            my( $base, $name, $seq )= ( $1, $2, $3 );\n            push @value, scalar(\n                4 == length($name)\n                    ? $meth->( $me )\n                    : $meth->( $me, $seq, $base )\n            );\n        }\n    }\n    if(  wantarray  ) {\n        return @value;\n    } elsif(  1 == @value  ) {\n        return $value[0];\n    }\n    Die( 0+@value, \" values requested from \",\n        $Root, \"'s Get in scalar context\" );\n}\n\n\nmy $Obj= getObjPkg($Root);\nno strict 'refs';\n\nfor my $meth (  qw( new getObjPkg )  ) {\n    *{$Root.\"::\".$meth} = \\&{$meth};\n    *{$Obj .\"::\".$meth} = \\&{$meth};\n}\nfor my $meth (  qw(\n    Next Prev Reset Copy Base Diff\n    Same Items Range Min Max Get\n    _ChkPos _ChkSeq\n)  ) {\n    *{$Obj.\"::\".$meth} = \\&{$meth};\n}\n\n1;\n# This version released by Tye McQueen (http://perlmonks.org/?node=tye).\n#\n# =head1 LICENSE\n#\n# Parts Copyright (c) 2000-2004 Ned Konz.  All rights reserved.\n# Parts by Tye McQueen.\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the same terms as Perl.\n#\n# =head1 MAILING LIST\n#\n# Mark-Jason still maintains a mailing list.  To join a low-volume mailing\n# list for announcements related to diff and Algorithm::Diff, send an\n# empty mail message to mjd-perl-diff-request@plover.com.\n# =head1 CREDITS\n#\n# Versions through 0.59 (and much of this documentation) were written by:\n#\n# Mark-Jason Dominus, mjd-perl-diff@plover.com\n#\n# This version borrows some documentation and routine names from\n# Mark-Jason's, but Diff.pm's code was completely replaced.\n#\n# This code was adapted from the Smalltalk code of Mario Wolczko\n# <mario@wolczko.com>, which is available at\n# ftp://st.cs.uiuc.edu/pub/Smalltalk/MANCHESTER/manchester/4.0/diff.st\n#\n# C<sdiff> and C<traverse_balanced> were written by Mike Schilli\n# <m@perlmeister.com>.\n#\n# The algorithm is that described in\n# I<A Fast Algorithm for Computing Longest Common Subsequences>,\n# CACM, vol.20, no.5, pp.350-353, May 1977, with a few\n# minor improvements to improve the speed.\n#\n# Much work was done by Ned Konz (perl@bike-nomad.com).\n#\n# The OO interface and some other changes are by Tye McQueen.\n#\nEOAlgDiff\n# 2}}}\n    my $problems        = 0;\n    $HAVE_Algorith_Diff = 0;\n    my $dir             = \"\";\n    if ($opt_sdir) {\n        ++$TEMP_OFF;\n        $dir = \"$opt_sdir/$TEMP_OFF\";\n        File::Path::rmtree($dir) if     is_dir($dir);\n        File::Path::mkpath($dir) unless is_dir($dir);\n    } else {\n        # let File::Temp create a suitable temporary directory\n        $dir = tempdir( CLEANUP => 1 );  # 1 = delete on exit\n        $TEMP_INST{ $dir } = \"Algorithm::Diff\";\n    }\n    print \"Using temp dir [$dir] to install Algorithm::Diff\\n\" if $opt_v;\n    my $Algorithm_dir      = \"$dir/Algorithm\";\n    my $Algorithm_Diff_dir = \"$dir/Algorithm/Diff\";\n    mkdir $Algorithm_dir     ;\n    mkdir $Algorithm_Diff_dir;\n\n    my $OUT = new IO::File \"$dir/Algorithm/Diff.pm\", \"w\";\n    if (defined $OUT) {\n        print $OUT $Algorithm_Diff_Contents;\n        $OUT->close;\n    } else {\n        warn \"Failed to install Algorithm/Diff.pm\\n\";\n        $problems = 1;\n    }\n\n    push @INC, $dir;  # between this & Regexp::Common only need to do once\n    eval \"use Algorithm::Diff qw / sdiff /\";\n    $HAVE_Algorith_Diff = 1 unless $problems;\n} # 1}}}\nsub pre_post_fix {                     # {{{1\n    # Return the input lines prefixed and postfixed\n    # by the given strings.\n    my ($ra_lines, $prefix, $postfix ) = @_;\n    print \"-> pre_post_fix with $prefix, $postfix\\n\" if $opt_v > 2;\n\n    my $all_lines = $prefix . join(\"\"  , @{$ra_lines}) . $postfix;\n\n    print \"<- pre_post_fix\\n\" if $opt_v > 2;\n    return split(\"\\n\", $all_lines);\n} # 1}}}\nsub call_regexp_common {                     # {{{1\n    my ($ra_lines, $language ) = @_;\n    print \"-> call_regexp_common for $language\\n\" if $opt_v > 2;\n\n    Install_Regexp_Common() unless $HAVE_Rexexp_Common;\n\n    my $all_lines = undef;\n    if ($language eq \"C++\") { # Regexp::Common's C++ comment regex is multi-line\n#       $all_lines = join(\"\\n\", @{$ra_lines});\n        $all_lines = \"\";\n        foreach (@{$ra_lines}) {\n            if (m/\\\\$/) {  # line ends with a continuation marker\n                $all_lines .= $_;\n            } else {\n                $all_lines .= \"$_\\n\";\n            }\n        }\n    } else {\n        $all_lines = join(\"\"  , @{$ra_lines});\n    }\n\n    no strict 'vars';\n    # otherwise get:\n    #  Global symbol \"%RE\" requires explicit package name at cloc line xx.\n    if ($all_lines =~ $RE{comment}{$language}) {\n        # Suppress \"Use of uninitialized value in regexp compilation\" that\n        # pops up when $1 is undefined--happens if there's a bug in the $RE\n        # This Pascal comment will trigger it:\n        #         (* This is { another } test. **)\n        # Curiously, testing for \"defined $1\" breaks the substitution.\n        no warnings;\n        # remove   comments\n        $all_lines =~ s/$1//g;\n    }\n    # a bogus use of %RE to avoid:\n    # Name \"main::RE\" used only once: possible typo at cloc line xx.\n    print scalar keys %RE if $opt_v < -20;\n    print \"<- call_regexp_common\\n\" if $opt_v > 2;\n    return split(\"\\n\", $all_lines);\n} # 1}}}\nsub plural_form {                            # {{{1\n    # For getting the right plural form on some English nouns.\n    my $n = shift @_;\n    if ($n == 1) { return ( 1, \"\" ); }\n    else         { return ($n, \"s\"); }\n} # 1}}}\nsub matlab_or_objective_C {                  # {{{1\n    # Decide if code is MATLAB, Mathematica, Objective C, MUMPS, or Mercury\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n        $rs_language , # out\n       ) = @_;\n    print \"-> matlab_or_objective_C\\n\" if $opt_v > 2;\n    # matlab markers:\n    #   first line starts with \"function\"\n    #   some lines start with \"%\"\n    #   high marks for lines that start with [\n    #\n    # Objective C markers:\n    #   must have at least two brace characters, { }\n    #   has /* ... */ style comments\n    #   some lines start with @\n    #   some lines start with #include\n    #\n    # MUMPS:\n    #   has ; comment markers\n    #   do not match:  \\w+\\s*=\\s*\\w\n    #   lines begin with   \\s*\\.?\\w+\\s+\\w\n    #   high marks for lines that start with \\s*K\\s+ or \\s*Kill\\s+\n    #\n    # Mercury:\n    #   any line that begins with :- immediately triggers this\n    #\n    # Mathematica:\n    #   (* .. *)\n    #   BeginPackage\n\n    ${$rs_language} = \"\";\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return;\n    }\n\n    my $DEBUG              = 0;\n\n    my $matlab_points      = 0;\n    my $mathematica_points = 0;\n    my $objective_C_points = 0;\n    my $mumps_points       = 0;\n    my $mercury_points     = 0;\n    my $has_braces         = 0;\n    while (<$IN>) {\n        ++$has_braces if $_ =~ m/[{}]/;\n#print \"LINE $. has_braces=$has_braces\\n\";\n        ++$mumps_points if $. == 1 and m{^[A-Z]};\n        if      (m{^\\s*/\\*} or m {^\\s*//}) {   #   /* or //\n            $objective_C_points += 5;\n            $matlab_points      -= 5;\nprintf \".m:  /*|//  obj C=% 2d  matlab=% 2d  mathematica=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n        } elsif (m{^:-\\s+}) {      # gotta be mercury\n            $mercury_points = 1000;\n            last;\n        } elsif (m{\\w+\\s*=\\s*\\[}) {      # matrix assignment, very matlab\n            $matlab_points += 5;\n        }\n        if (m{\\w+\\[}) {      # function call by []\n            $mathematica_points += 2;\nprintf \".m:  \\\\w=[   obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n        } elsif (m{^\\s*\\w+\\s*=\\s*}) {    # definitely not MUMPS\n            --$mumps_points;\nprintf \".m:  \\\\w=    obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n        } elsif (m{^\\s*\\.?(\\w)\\s+(\\w)} and $1 !~ /\\d/ and $2 !~ /\\d/) {\n            ++$mumps_points;\nprintf \".m:  \\\\w \\\\w  obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n        } elsif (m{^\\s*;}) {\n            ++$mumps_points;\nprintf \".m:  ;      obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n        }\n        if (m{^\\s*#(include|import)}) {\n            # Objective C without a doubt\n            $objective_C_points = 1000;\n            $matlab_points      = 0;\nprintf \".m: #includ obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n            $has_braces         = 2;\n            last;\n        } elsif (m{^\\s*@(interface|implementation|protocol|public|protected|private|end)\\s}o) {\n            # Objective C without a doubt\n            $objective_C_points = 1000;\n            $matlab_points      = 0;\nprintf \".m: keyword obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n            last;\n        } elsif (m{^\\s*BeginPackage}) {\n            $mathematica_points += 2;\n        } elsif (m{^\\s*\\[}) {             #   line starts with [  -- very matlab\n            $matlab_points += 5;\nprintf \".m:  [      obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n        } elsif (m{^\\sK(ill)?\\s+}) {\n            $mumps_points  += 5;\nprintf \".m:  Kill   obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n        } elsif (m{^\\s*function}) {\n            --$objective_C_points;\n            ++$matlab_points;\nprintf \".m:  funct  obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n        } elsif (m{^\\s*%}) {              #   %\n            # matlab commented line\n            --$objective_C_points;\n            ++$matlab_points;\nprintf \".m:  pcent  obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n        }\n    }\n    $IN->close;\nprintf \"END LOOP    obj C=% 2d  matlab=% 2d  mumps=% 2d  mercury= % 2d\\n\", $objective_C_points, $matlab_points, $mathematica_points, $mumps_points, $mercury_points if $DEBUG;\n\n    # next heuristic is unreliable for small files\n#   $objective_C_points = -9.9e20 unless $has_braces >= 2;\n\n    my %points = ( 'MATLAB'      => $matlab_points     ,\n                   'Mathematica' => $mathematica_points     ,\n                   'MUMPS'       => $mumps_points      ,\n                   'Objective C' => $objective_C_points,\n                   'Mercury'     => $mercury_points    , );\n\n    ${$rs_language} = (sort { $points{$b} <=> $points{$a}} keys %points)[0];\n\n    print \"<- matlab_or_objective_C($file: matlab=$matlab_points, mathematica=$mathematica_points, C=$objective_C_points, mumps=$mumps_points, mercury=$mercury_points) => ${$rs_language}\\n\"\n        if $opt_v > 2;\n\n} # 1}}}\nsub Lisp_or_OpenCL {                         # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> Lisp_or_OpenCL\\n\" if $opt_v > 2;\n\n    my $lang = undef;\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $lisp_points   = 0;\n    my $opcl_points = 0;\n    while (<$IN>) {\n        ++$lisp_points if  /^\\s*;/;\n        ++$lisp_points if  /\\((def|eval|require|export|let|loop|dec|format)/;\n        ++$opcl_points if  /^\\s*(int|float|const|{)/;\n    }\n    $IN->close;\n    # print \"lisp_points=$lisp_points   opcl_points=$opcl_points\\n\";\n    if ($lisp_points > $opcl_points) {\n        $lang = \"Lisp\";\n    } else {\n        $lang = \"OpenCL\";\n    }\n\n    print \"<- Lisp_or_OpenCL\\n\" if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub Lisp_or_Julia {                          # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> Lisp_or_Julia\\n\" if $opt_v > 2;\n\n    my $lang = undef;\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $lisp_points   = 0;\n    my $julia_points = 0;\n    while (<$IN>) {\n        ++$lisp_points if  /^\\s*;/;\n        ++$lisp_points if  /\\((def|eval|require|export|let|loop|dec|format)/;\n        ++$julia_points if  /^\\s*(function|end|println|for|while)/;\n    }\n    $IN->close;\n    # print \"lisp_points=$lisp_points   julia_points=$julia_points\\n\";\n    if ($lisp_points > $julia_points) {\n        $lang = \"Lisp\";\n    } else {\n        $lang = \"Julia\";\n    }\n\n    print \"<- Lisp_or_Julia\\n\" if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub Perl_or_Prolog {                         # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> Perl_or_Prolog\\n\" if $opt_v > 2;\n\n    my $lang = undef;\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $perl_points = 0;\n    my $prolog_points = 0;\n    while (<$IN>) {\n        ++$perl_points if  /;\\s*$/;\n        ++$perl_points if  /({|})/;\n        ++$perl_points if  /^\\s*sub\\s+/;\n        ++$perl_points if  /\\s*<<'/;  # start HERE block\n        ++$perl_points if  /\\$(\\w+\\->|[_!])/;\n        ++$prolog_points if !/\\s*#/ and /\\.\\s*$/;\n        ++$prolog_points if /:-/;\n    }\n    $IN->close;\n    # print \"perl_points=$perl_points   prolog_points=$prolog_points\\n\";\n    if ($perl_points > $prolog_points) {\n        $lang = \"Perl\";\n    } else {\n        $lang = \"Prolog\";\n    }\n\n    printf \"<- Perl_or_Prolog(%s, Perl=%d Prolog=%d)\\n\",\n        $file, $perl_points, $prolog_points if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub IDL_or_QtProject {                       # {{{1\n    # also Prolog\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> IDL_or_QtProject($file)\\n\" if $opt_v > 2;\n\n    my $lang = undef;\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $idl_points    = 0;\n    my $qtproj_points = 0;\n    my $prolog_points = 0;\n    while (<$IN>) {\n        ++$idl_points    if /^\\s*;/;\n        ++$idl_points    if /plot\\(/i;\n        ++$qtproj_points if /^\\s*(qt|configs|sources)\\s*\\+?=/i;\n        ++$prolog_points if /\\.\\s*$/;\n        ++$prolog_points if /:-/;\n    }\n    $IN->close;\n    # print \"idl_points=$idl_points   qtproj_points=$qtproj_points\\n\";\n\n    if ($idl_points > $qtproj_points) {\n        $lang = \"IDL\";\n    } else {\n        $lang = \"Qt Project\";\n    }\n\n    my %points = ( 'IDL'        => $idl_points     ,\n                   'Qt Project' => $qtproj_points  ,\n                   'Prolog'     => $prolog_points  , );\n\n    $lang = (sort { $points{$b} <=> $points{$a}} keys %points)[0];\n\n    print \"<- IDL_or_QtProject(idl_points=$idl_points, \",\n          \"qtproj_points=$qtproj_points, prolog_points=$prolog_points)\\n\"\n           if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub Ant_or_XML {                             # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> Ant_or_XML($file)\\n\" if $opt_v > 2;\n\n    my $lang = \"XML\";\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $Ant_points   = 0;\n    my $XML_points   = 1;\n    while (<$IN>) {\n        if (/^\\s*<project\\s+/) {\n            ++$Ant_points  ;\n            --$XML_points  ;\n        }\n        if (/xmlns:artifact=\"antlib:org.apache.maven.artifact.ant\"/) {\n            ++$Ant_points  ;\n            --$XML_points  ;\n        }\n    }\n    $IN->close;\n\n    if ($XML_points >= $Ant_points) {\n        # tie or better goes to XML\n        $lang = \"XML\";\n    } else {\n        $lang = \"Ant\";\n    }\n\n    print \"<- Ant_or_XML($lang)\\n\" if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub Maven_or_XML {                           # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> Maven_or_XML($file)\\n\" if $opt_v > 2;\n\n    my $lang = \"XML\";\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $Mvn_points   = 0;\n    my $XML_points   = 1;\n    while (<$IN>) {\n        if (/^\\s*<project\\s+/) {\n            ++$Mvn_points  ;\n            --$XML_points  ;\n        }\n        if (m{xmlns=\"http://maven.apache.org/POM/}) {\n            ++$Mvn_points  ;\n            --$XML_points  ;\n        }\n    }\n    $IN->close;\n\n    if ($XML_points >= $Mvn_points) {\n        # tie or better goes to XML\n        $lang = \"XML\";\n    } else {\n        $lang = \"Maven\";\n    }\n\n    print \"<- Maven_or_XML($lang)\\n\" if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub pascal_or_puppet {                       # {{{1\n    # Decide if code is Pascal or Puppet manifest\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n        $rs_language , # out\n       ) = @_;\n\n    print \"-> pascal_or_puppet\\n\" if $opt_v > 2;\n\n    ${$rs_language} = \"\";\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return;\n    }\n\n    my $DEBUG              = 0;\n    my $pascal_points      = 0;\n    my $puppet_points      = 0;\n\n    while (<$IN>) {\n\n        if ( /^\\s*\\#\\s+/ ) {\n                $puppet_points += .001;\n                next;\n        }\n\n        ++$pascal_points if /\\bprogram\\s+[A-Za-z]/i;\n        ++$pascal_points if /\\bunit\\s+[A-Za-z]/i;\n        ++$pascal_points if /\\bmodule\\s+[A-Za-z]/i;\n        ++$pascal_points if /\\bprocedure\\b/i;\n        ++$pascal_points if /\\bfunction\\b/i;\n        ++$pascal_points if /^\\s*interface\\s+/i;\n        ++$pascal_points if /^\\s*implementation\\s+/i;\n        ++$pascal_points if /^\\s*uses\\s+/i;\n        ++$pascal_points if /(?<!\\:\\:)\\bbegin\\b(?!\\:\\:)/i;\n        ++$pascal_points if /(?<!\\:\\:)\\bend\\b(?!\\:\\:)/i;\n        ++$pascal_points if /\\:\\=/;\n        ++$pascal_points if /\\<\\>/;\n        ++$pascal_points if /^\\s*\\{\\$(I|INCLUDE)\\s+.*\\}/i;\n        ++$pascal_points if /writeln/;\n\n        ++$puppet_points if /^\\s*class\\s+/ and not /class\\s+operator\\s+/;\n        ++$puppet_points if /^\\s*case\\s+/;\n        ++$puppet_points if /^\\s*package\\s+/;\n        ++$puppet_points if /^\\s*file\\s+/;\n        ++$puppet_points if /^\\s*include\\s\\w+/;\n        ++$puppet_points if /^\\s*service\\s+/;\n        ++$puppet_points if /\\s\\$\\w+\\s*\\=\\s*\\S/;\n        ++$puppet_points if /\\S\\s*\\=\\>\\s*\\S/;\n\n        # No need to process rest of file if language seems obvious.\n        last\n                if (abs ($pascal_points - $puppet_points ) > 20 );\n    }\n    $IN->close;\n\n    print \"<- pascal_or_puppet(pascal=$pascal_points, puppet=$puppet_points)\\n\"\n        if $opt_v > 2;\n\n    if ($pascal_points > $puppet_points) {\n        ${$rs_language} = \"Pascal\";\n    } else {\n        ${$rs_language} = \"Puppet\";\n    }\n\n} # 1}}}\nsub Forth_or_Fortran {                       # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> Forth_or_Fortran\\n\" if $opt_v > 2;\n\n    my $lang = undef;\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $forth_points = 0;\n    my $fortran_points = 0;\n    while (<$IN>) {\n        ++$forth_points if  /^:\\s/;\n        ++$fortran_points if  /^([c*][^a-z]|\\s{6,}(subroutine|program|end|implicit)\\s|\\s*!)/i;\n    }\n    $IN->close;\n    if ($forth_points > $fortran_points) {\n        $lang = \"Forth\";\n    } else {\n        $lang = \"Fortran 77\";\n    }\n\n    print \"<- Forth_or_Fortran\\n\" if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub Forth_or_Fsharp {                        # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> Forth_or_Fsharp\\n\" if $opt_v > 2;\n\n    my $lang = undef;\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $forth_points = 0;\n    my $fsharp_points = 0;\n    while (<$IN>) {\n        ++$forth_points if  /^:\\s/;\n        ++$fsharp_points if  /^\\s*(#light|import|let|module|namespace|open|type)/;\n    }\n    $IN->close;\n    if ($forth_points > $fsharp_points) {\n        $lang = \"Forth\";\n    } else {\n        $lang = \"F#\";\n    }\n\n    print \"<- Forth_or_Fsharp\\n\" if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub Verilog_or_Coq {                         # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> Verilog_or_Coq\\n\" if $opt_v > 2;\n\n    my $lang = undef;\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $coq_points     = 0;\n    my $verilog_points = 0;\n    while (<$IN>) {\n        ++$verilog_points if  /^\\s*(module|begin|input|output|always)/;\n        ++$coq_points if /\\b(Inductive|Fixpoint|Definition|\n                             Theorem|Lemma|Proof|Qed|forall|\n                             Section|Check|Notation|Variable|\n                             Goal|Fail|Require|Scheme|Module|Ltac|\n                             Set|Unset|Parameter|Coercion|Axiom|\n                             Locate|Type|Record|Existing|Class)\\b/x;\n    }\n    $IN->close;\n    if ($coq_points > $verilog_points) {\n        $lang = \"Coq\";\n    } else {\n        $lang = \"Verilog-SystemVerilog\";\n    }\n\n    print \"<- Verilog_or_Coq\\n\" if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub TypeScript_or_QtLinguist {               # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> TypeScript_or_QtLinguist\\n\" if $opt_v > 2;\n\n    my $lang = undef;\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $tscript_points  = 0;\n    my $linguist_points = 0;\n    while (<$IN>) {\n        ++$linguist_points if m{\\b</?(message|source|translation)>};\n        ++$tscript_points  if /^\\s*(var|class|document)\\b/;\n        ++$tscript_points  if /[;}]\\s*$/;\n        ++$tscript_points  if m{^\\s*//};\n    }\n    $IN->close;\n    if ($tscript_points > $linguist_points) {\n        $lang = \"TypeScript\";\n    } else {\n        $lang = \"Qt Linguist\";\n    }\n    print \"<- TypeScript_or_QtLinguist\\n\" if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub Qt_or_Glade {                            # {{{1\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n\n    print \"-> Qt_or_Glade\\n\" if $opt_v > 2;\n\n    my $lang = undef;\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        push @{$raa_errors}, [$rh_Err->{'Unable to read'} , $file];\n        return $lang;\n    }\n    my $qt_points    =  1;\n    my $glade_points = -1;\n    while (<$IN>) {\n        if (/generated\\s+with\\s+glade/i) {\n            $glade_points =  1;\n            $qt_points    = -1;\n            last;\n        }\n    }\n    $IN->close;\n    if ($glade_points > $qt_points) {\n        $lang = \"Glade\";\n    } else {\n        $lang = \"Qt\";\n    }\n    print \"<- Qt_or_Glade\\n\" if $opt_v > 2;\n    return $lang;\n} # 1}}}\nsub html_colored_text {                      # {{{1\n    # http://www.pagetutor.com/pagetutor/makapage/pics/net216-2.gif\n    my ($color, $text) = @_;\n#?#die \"html_colored_text($text)\";\n    if      ($color =~ /^red$/i)   {\n        $color = \"#ff0000\";\n    } elsif ($color =~ /^green$/i) {\n        $color = \"#00ff00\";\n    } elsif ($color =~ /^blue$/i)  {\n        $color = \"#0000ff\";\n    } elsif ($color =~ /^grey$/i)  {\n        $color = \"#cccccc\";\n    }\n#   return \"\" unless $text;\n    return '<font color=\"' . $color . '\">' . html_metachars($text) . \"</font>\";\n} # 1}}}\nsub xml_metachars {                          # {{{1\n    # http://en.wikipedia.org/wiki/Character_encodings_in_HTML#XML_character_references\n    my ($string, ) = shift @_;\n\n    my  @in_chars    = split(//, $string);\n    my  @out_chars   = ();\n    foreach my $c (@in_chars) {\n        if      ($c eq '&') { push @out_chars, '&amp;'\n        } elsif ($c eq '<') { push @out_chars, '&lt;'\n        } elsif ($c eq '>') { push @out_chars, '&gt;'\n        } elsif ($c eq '\"') { push @out_chars, '&quot;'\n        } elsif ($c eq \"'\") { push @out_chars, '&apos;'\n        } else {\n            push @out_chars, $c;\n        }\n    }\n    return join \"\", @out_chars;\n} # 1}}}\nsub html_metachars {                         # {{{1\n    # Replace HTML metacharacters with their printable forms.\n    # Future:  use HTML-Encoder-0.00_04/lib/HTML/Encoder.pm\n    # from Fabiano Reese Righetti's HTML::Encoder module if\n    # this subroutine proves to be too simplistic.\n    my ($string, ) = shift @_;\n\n    my  @in_chars    = split(//, $string);\n    my  @out_chars   = ();\n    foreach my $c (@in_chars) {\n        if      ($c eq '<') {\n            push @out_chars, '&lt;'\n        } elsif ($c eq '>') {\n            push @out_chars, '&gt;'\n        } elsif ($c eq '&') {\n            push @out_chars, '&amp;'\n        } else {\n            push @out_chars, $c;\n        }\n    }\n    return join \"\", @out_chars;\n} # 1}}}\nsub test_alg_diff {                          # {{{1\n    my ($file_1 ,\n        $file_2 )\n       = @_;\n    my $fh_1 = new IO::File $file_1, \"r\";\n    die \"Unable to read $file_1:  $!\\n\" unless defined $fh_1;\n    chomp(my @lines_1 = <$fh_1>);\n    $fh_1->close;\n\n    my $fh_2 = new IO::File $file_2, \"r\";\n    die \"Unable to read $file_2:  $!\\n\" unless defined $fh_2;\n    chomp(my @lines_2 = <$fh_2>);\n    $fh_2->close;\n\n    my $n_no_change = 0;\n    my $n_modified  = 0;\n    my $n_added     = 0;\n    my $n_deleted   = 0;\n    my @min_sdiff   = ();\nmy $NN = chr(27) . \"[0m\";  # normal\nmy $BB = chr(27) . \"[1m\";  # bold\n\n    my @sdiffs = sdiff( \\@lines_1, \\@lines_2 );\n    foreach my $entry (@sdiffs) {\n        my ($out_1, $out_2) = ('', '');\n        if ($entry->[0] eq 'u') {\n            ++$n_no_change;\n          # $out_1 = $entry->[1];\n          # $out_2 = $entry->[2];\n            next;\n        }\n#       push @min_sdiff, $entry;\n        if      ($entry->[0] eq 'c') {\n            ++$n_modified;\n            ($out_1, $out_2) = diff_two_strings($entry->[1], $entry->[2]);\n            $out_1 =~ s/\\cA(\\w)/${BB}$1${NN}/g;\n            $out_2 =~ s/\\cA(\\w)/${BB}$1${NN}/g;\n          # $out_1 =~ s/\\cA//g;\n          # $out_2 =~ s/\\cA//g;\n        } elsif ($entry->[0] eq '+') {\n            ++$n_added;\n            $out_1 = $entry->[1];\n            $out_2 = $entry->[2];\n        } elsif ($entry->[0] eq '-') {\n            ++$n_deleted;\n            $out_1 = $entry->[1];\n            $out_2 = $entry->[2];\n        } elsif ($entry->[0] eq 'u') {\n        } else { die \"unknown entry->[0]=[$entry->[0]]\\n\"; }\n        printf \"%-80s | %s\\n\", $out_1, $out_2;\n    }\n\n#   foreach my $entry (@min_sdiff) {\n#       printf \"DIFF:  %s  %s  %s\\n\", @{$entry};\n#   }\n} # 1}}}\nsub write_comments_to_html {                 # {{{1\n    my ($filename      , # in\n        $rah_diff_L    , # in  see routine array_diff() for explanation\n        $rah_diff_R    , # in  see routine array_diff() for explanation\n        $rh_blank      , # in  location and counts of blank lines\n       ) = @_;\n\n    print \"-> write_comments_to_html($filename)\\n\" if $opt_v > 2;\n    my $file = $filename . \".html\";\n#use Data::Dumper;\n#print Dumper(\"rah_diff_L\", $rah_diff_L, \"rah_diff_R\", $rah_diff_R);\n    my $OUT = new IO::File $file, \"w\";\n    if (!defined $OUT) {\n        warn \"Unable to write to $file\\n\";\n        print \"<- write_comments_to_html\\n\" if $opt_v > 2;\n        return;\n    }\n\n    my $approx_line_count = scalar @{$rah_diff_L};\n    my $n_digits = 1 + int(log($approx_line_count)/2.30258509299405); # log_10\n\n    my $html_out = html_header($filename);\n\n    my $comment_line_number = 0;\n    for (my $i = 0; $i < scalar @{$rah_diff_R}; $i++) {\n        if (defined $rh_blank->{$i}) {\n            foreach (1..$rh_blank->{$i}) {\n                $html_out .= \"<!-- blank -->\\n\";\n            }\n        }\n        my $line_num = \"\";\n        my $pre      = \"\";\n        my $post     = '</span> &nbsp;';\nwarn \"undef rah_diff_R[$i]{type} \" unless defined $rah_diff_R->[$i]{type};\n        if ($rah_diff_R->[$i]{type} eq 'nonexist') {\n            ++$comment_line_number;\n            $line_num = sprintf \"\\&nbsp; <span class=\\\"clinenum\\\"> %0${n_digits}d %s\",\n                            $comment_line_number, $post;\n            $pre = '<span class=\"comment\">';\n            $html_out .= $line_num;\n            $html_out .= $pre .\n                         html_metachars($rah_diff_L->[$i]{char}) .\n                         $post . \"\\n\";\n            next;\n        }\n        if      ($rah_diff_R->[$i]{type} eq 'code' and\n                 $rah_diff_R->[$i]{desc} eq 'same') {\n            # entire line remains as-is\n            $line_num = sprintf \"\\&nbsp; <span class=\\\"linenum\\\"> %0${n_digits}d %s\",\n                            $rah_diff_R->[$i]{lnum}, $post;\n            $pre    = '<span class=\"normal\">';\n            $html_out .= $line_num;\n            $html_out .= $pre .\n                         html_metachars($rah_diff_R->[$i]{char}) . $post;\n#XX     } elsif ($rah_diff_R->[$i]{type} eq 'code') { # code+comments\n#XX\n#XX         $line_num = '<span class=\"linenum\">' .\n#XX                      $rah_diff_R->[$i]{lnum} . $post;\n#XX         $html_out .= $line_num;\n#XX\n#XX         my @strings = @{$rah_diff_R->[$i]{char}{strings}};\n#XX         my @type    = @{$rah_diff_R->[$i]{char}{type}};\n#XX         for (my $i = 0; $i < scalar @strings; $i++) {\n#XX             if ($type[$i] eq 'u') {\n#XX                 $pre = '<span class=\"normal\">';\n#XX             } else {\n#XX                 $pre = '<span class=\"comment\">';\n#XX             }\n#XX             $html_out .= $pre .  html_metachars($strings[$i]) . $post;\n#XX         }\n# print Dumper(@strings, @type); die;\n\n        } elsif ($rah_diff_R->[$i]{type} eq 'comment') {\n            $line_num = '<span class=\"clinenum\">' . $comment_line_number . $post;\n            # entire line is a comment\n            $pre    = '<span class=\"comment\">';\n            $html_out .= $pre .\n                         html_metachars($rah_diff_R->[$i]{char}) . $post;\n        }\n#printf \"%-30s %s %-30s\\n\", $line_1, $separator, $line_2;\n        $html_out .= \"\\n\";\n    }\n\n    $html_out .= html_end();\n\n    my $out_file = \"$filename.html\";\n    open  OUT, \">$out_file\" or die \"Cannot write to $out_file $!\\n\";\n    print OUT $html_out;\n    close OUT;\n    print \"Wrote $out_file\\n\" unless $opt_quiet;\n    $OUT->close;\n\n    print \"<- write_comments_to_html\\n\" if $opt_v > 2;\n} # 1}}}\nsub array_diff {                             # {{{1\n    my ($file          , # in  only used for error reporting\n        $ra_lines_L    , # in  array of lines in Left  file (no blank lines)\n        $ra_lines_R    , # in  array of lines in Right file (no blank lines)\n        $mode          , # in  \"comment\" | \"revision\"\n        $rah_diff_L    , # out\n        $rah_diff_R    , # out\n        $raa_Errors    , # in/out\n       ) = @_;\n\n    # This routine operates in two ways:\n    # A. Computes diffs of the same file with and without comments.\n    #    This is used to classify lines as code, comments, or blank.\n    # B. Computes diffs of two revisions of a file.  This method\n    #    requires a prior run of method A using the older version\n    #    of the file because it needs lines to be classified.\n\n    # $rah_diff structure:\n    # An array with n entries where n equals the number of lines in\n    # an sdiff of the two files.  Each entry in the array describes\n    # the contents of the corresponding line in file Left and file Right:\n    #  diff[]{type} = blank | code | code+comment | comment | nonexist\n    #        {lnum} = line number within the original file (1-based)\n    #        {desc} = same | added | removed | modified\n    #        {char} = the input line unless {desc} = 'modified' in\n    #                 which case\n    #        {char}{strings} = [ substrings ]\n    #        {char}{type}    = [ disposition (added, removed, etc)]\n    #\n\n    @{$rah_diff_L} = ();\n    @{$rah_diff_R} = ();\n\n    print \"-> array_diff()\\n\" if $opt_v > 2;\n    my $COMMENT_MODE = 0;\n       $COMMENT_MODE = 1 if $mode eq \"comment\";\n\n#print \"array_diff(mode=$mode)\\n\";\n#print Dumper(\"block left:\" , $ra_lines_L);\n#print Dumper(\"block right:\", $ra_lines_R);\n\n    my @sdiffs = ();\n    eval {\n        local $SIG{ALRM} = sub { die \"alarm\\n\" };\n        alarm $opt_diff_timeout;\n        @sdiffs = sdiff($ra_lines_L, $ra_lines_R);\n        alarm 0;\n    };\n    if ($@) {\n        # timed out\n        die unless $@ eq \"alarm\\n\"; # propagate unexpected errors\n        push @{$raa_Errors},\n             [ $Error_Codes{'Diff error, exceeded timeout'}, $file ];\n        if ($opt_v) {\n          warn \"array_diff: diff timeout failure for $file--ignoring\\n\";\n        }\n        return;\n    }\n\n#use Data::Dumper::Simple;\n#print Dumper($ra_lines_L, $ra_lines_R, @sdiffs);\n#die;\n\n    my $n_L        = 0;\n    my $n_R        = 0;\n    my $n_sdiff    = 0;  # index to $rah_diff_L, $rah_diff_R\n    foreach my $triple (@sdiffs) {\n        my $flag   = $triple->[0];\n        my $line_L = $triple->[1];\n        my $line_R = $triple->[2];\n        $rah_diff_L->[$n_sdiff]{char} = $line_L;\n        $rah_diff_R->[$n_sdiff]{char} = $line_R;\n        if      ($flag eq 'u') {  # u = unchanged\n            ++$n_L;\n            ++$n_R;\n            if ($COMMENT_MODE) {\n                # line exists in both with & without comments, must be code\n                $rah_diff_L->[$n_sdiff]{type} = \"code\";\n                $rah_diff_R->[$n_sdiff]{type} = \"code\";\n            }\n            $rah_diff_L->[$n_sdiff]{desc} = \"same\";\n            $rah_diff_R->[$n_sdiff]{desc} = \"same\";\n            $rah_diff_L->[$n_sdiff]{lnum} = $n_L;\n            $rah_diff_R->[$n_sdiff]{lnum} = $n_R;\n        } elsif ($flag eq 'c') {  # c = changed\n# warn \"per line sdiff() commented out\\n\"; if (0) {\n            ++$n_L;\n            ++$n_R;\n\n            if ($COMMENT_MODE) {\n                # line has text both with & without comments;\n                # count as code\n                $rah_diff_L->[$n_sdiff]{type} = \"code\";\n                $rah_diff_R->[$n_sdiff]{type} = \"code\";\n            }\n\n            my @chars_L = split '', $line_L;\n            my @chars_R = split '', $line_R;\n\n#XX         my @inline_sdiffs = sdiff( \\@chars_L, \\@chars_R );\n\n#use Data::Dumper::Simple;\n#if ($n_R == 6 or $n_R == 1 or $n_R == 2) {\n#print \"L=[$line_L]\\n\";\n#print \"R=[$line_R]\\n\";\n#print Dumper(@chars_L, @chars_R, @inline_sdiffs);\n#}\n#XX         my @index = ();\n#XX         foreach my $il_triple (@inline_sdiffs) {\n#XX             # make an array of u|c|+|- corresponding\n#XX             # to each character\n#XX             push @index, $il_triple->[0];\n#XX         }\n#XX#print Dumper(@index); die;\n#XX          # expect problems if arrays @index and $inline_sdiffs[1];\n#XX          # (@{$inline_sdiffs->[1]} are the characters of line_L)\n#XX          # aren't the same length\n#XX          my $prev_type = $index[0];\n#XX          my @strings   = ();  # blocks of consecutive code or comment\n#XX          my @type      = ();  # u (=code) or c (=comment)\n#XX          my $j_str     = 0;\n#XX          $strings[$j_str] .= $chars_L[0];\n#XX          $type[$j_str] = $prev_type;\n#XX          for (my $i = 1; $i < scalar @chars_L; $i++) {\n#XX              if ($index[$i] ne $prev_type) {\n#XX                  ++$j_str;\n#XX#print \"change at j_str=$j_str type=$index[$i]\\n\";\n#XX                  $type[$j_str] = $index[$i];\n#XX                  $prev_type    = $index[$i];\n#XX              }\n#XX              $strings[$j_str] .= $chars_L[$i];\n#XX          }\n# print Dumper(@strings, @type); die;\n#XX         delete $rah_diff_R->[$n_sdiff]{char};\n#XX         @{$rah_diff_R->[$n_sdiff]{char}{strings}} = @strings;\n#XX         @{$rah_diff_R->[$n_sdiff]{char}{type}}    = @type;\n            $rah_diff_L->[$n_sdiff]{desc} = \"modified\";\n            $rah_diff_R->[$n_sdiff]{desc} = \"modified\";\n            $rah_diff_L->[$n_sdiff]{lnum} = $n_L;\n            $rah_diff_R->[$n_sdiff]{lnum} = $n_R;\n#}\n\n        } elsif ($flag eq '+') {  # + = added\n            ++$n_R;\n            if ($COMMENT_MODE) {\n                # should never get here\n                @{$rah_diff_L} = ();\n                @{$rah_diff_R} = ();\n                push @{$raa_Errors},\n                     [ $Error_Codes{'Diff error (quoted comments?)'}, $file ];\n                if ($opt_v) {\n                  warn \"array_diff: diff failure (diff says the\\n\";\n                  warn \"comment-free file has added lines).\\n\";\n                  warn \"$n_sdiff  $line_L\\n\";\n                }\n                last;\n            }\n            $rah_diff_L->[$n_sdiff]{type} = \"nonexist\";\n            $rah_diff_L->[$n_sdiff]{desc} = \"removed\";\n            $rah_diff_R->[$n_sdiff]{desc} = \"added\";\n            $rah_diff_R->[$n_sdiff]{lnum} = $n_R;\n        } elsif ($flag eq '-') {  # - = removed\n            ++$n_L;\n            if ($COMMENT_MODE) {\n                # line must be comment because blanks already gone\n                $rah_diff_L->[$n_sdiff]{type} = \"comment\";\n            }\n            $rah_diff_R->[$n_sdiff]{type} = \"nonexist\";\n            $rah_diff_R->[$n_sdiff]{desc} = \"removed\";\n            $rah_diff_L->[$n_sdiff]{desc} = \"added\";\n            $rah_diff_L->[$n_sdiff]{lnum} = $n_L;\n        }\n#printf \"%-30s %s %-30s\\n\", $line_L, $separator, $line_R;\n        ++$n_sdiff;\n    }\n#use Data::Dumper::Simple;\n#print Dumper($rah_diff_L, $rah_diff_R);\n\n    print \"<- array_diff\\n\" if $opt_v > 2;\n} # 1}}}\nsub remove_leading_dir {                     # {{{1\n    my @filenames = @_;\n    #\n    #  Input should be a list of file names\n    #  with the same leading directory such as\n    #\n    #      dir1/dir2/a.txt\n    #      dir1/dir2/b.txt\n    #      dir1/dir2/dir3/c.txt\n    #\n    #  Output is the same list minus the common\n    #  directory path:\n    #\n    #      a.txt\n    #      b.txt\n    #      dir3/c.txt\n    #\n    print \"-> remove_leading_dir()\\n\" if $opt_v > 2;\n    my @D = (); # a matrix:   [ [ dir1, dir2 ],         # dir1/dir2/a.txt\n                #               [ dir1, dir2 ],         # dir1/dir2/b.txt\n                #               [ dir1, dir2 , dir3] ]  # dir1/dir2/dir3/c.txt\n    if ($ON_WINDOWS) {\n        foreach my $F (@filenames) {\n            $F =~ s{\\\\}{/}g;\n            $F = ucfirst($F) if $F =~ /^\\w:/;  # uppercase drive letter\n        }\n    }\n    if (scalar @filenames == 1) {\n        # special case:  with only one filename\n        # cannot determine a baseline, just remove first directory level\n        $filenames[0] =~ s{^.*?/}{};\n        # print \"-> $filenames[0]\\n\";\n        return $filenames[0];\n    }\n    foreach my $F (@filenames) {\n        my ($Vol, $Dir, $File) = File::Spec->splitpath($F);\n        my @x = File::Spec->splitdir( $Dir );\n        pop @x unless $x[$#x]; # last entry usually null, remove it\n        if ($ON_WINDOWS) {\n            if (defined($Vol) and $Vol) {\n                # put the drive letter, eg, C:, at the front\n                unshift @x, uc $Vol;\n            }\n        }\n#print \"F=$F, Dir=$Dir  x=[\", join(\"][\", @x), \"]\\n\";\n        push @D, [ @x ];\n    }\n\n    # now loop over columns until either they are all\n    # eliminated or a unique column is found\n\n#use Data::Dumper::Simple;\n#print Dumper(\"remove_leading_dir after \", @D);\n\n    my @common   = ();  # to contain the common leading directories\n    my $mismatch = 0;\n    while (!$mismatch) {\n        for (my $row = 1; $row < scalar @D; $row++) {\n#print \"comparing $D[$row][0] to $D[0][0]\\n\";\n\n            if (!defined $D[$row][0] or !defined $D[0][0] or\n                ($D[$row][0] ne $D[0][0])) {\n                $mismatch = 1;\n                last;\n            }\n        }\n#print \"mismatch=$mismatch\\n\";\n        if (!$mismatch) {\n            push @common, $D[0][0];\n            # all terms in the leading match; unshift the batch\n            foreach my $ra (@D) {\n                shift @{$ra};\n            }\n        }\n    }\n\n    push @common, \" \";  # so that $leading will end with \"/ \"\n    my $leading = File::Spec->catdir( @common );\n       $leading =~ s{ $}{};  # now take back the bogus appended space\n#print \"remove_leading_dir leading=[$leading]\\n\"; die;\n    if ($ON_WINDOWS) {\n       $leading =~ s{\\\\}{/}g;\n    }\n    foreach my $F (@filenames) {\n        $F =~ s{^$leading}{};\n    }\n\n    print \"<- remove_leading_dir()\\n\" if $opt_v > 2;\n    return @filenames;\n\n} # 1}}}\nsub strip_leading_dir {                      # {{{1\n    my ($leading, @filenames) = @_;\n    #  removes the string $leading from each entry in @filenames\n    print \"-> strip_leading_dir()\\n\" if $opt_v > 2;\n\n#print \"remove_leading_dir leading=[$leading]\\n\"; die;\n    if ($ON_WINDOWS) {\n       $leading =~ s{\\\\}{/}g;\n        foreach my $F (@filenames) {\n            $F =~ s{\\\\}{/}g;\n        }\n    }\n    foreach my $F (@filenames) {\n        $F =~ s{^$leading}{};\n    }\n\n    print \"<- strip_leading_dir()\\n\" if $opt_v > 2;\n    return @filenames;\n\n} # 1}}}\nsub find_deepest_file {                      # {{{1\n    my @filenames = @_;\n    #\n    #  Input should be a list of file names\n    #  with the same leading directory such as\n    #\n    #      dir1/dir2/a.txt\n    #      dir1/dir2/b.txt\n    #      dir1/dir2/dir3/c.txt\n    #\n    #  Output is the file with the most parent directories:\n    #\n    #      dir1/dir2/dir3/c.txt\n\n    print \"-> find_deepest_file()\\n\" if $opt_v > 2;\n\n    my $deepest    = undef;\n    my $max_subdir = -1;\n    foreach my $F (sort @filenames) {\n        my ($Vol, $Dir, $File) = File::Spec->splitpath($F);\n        my @x = File::Spec->splitdir( $Dir );\n        pop @x unless $x[$#x]; # last entry usually null, remove it\n        if (scalar @x > $max_subdir) {\n            $deepest    = $F;\n            $max_subdir = scalar @x;\n        }\n    }\n\n    print \"<- find_deepest_file()\\n\" if $opt_v > 2;\n    return $deepest;\n\n} # 1}}}\nsub find_uncommon_parent_dir {               # {{{1\n    my ($file_L, $file_R) = @_;\n    #\n    # example:\n    #\n    #   file_L = \"perl-5.16.1/cpan/CPANPLUS/lib/CPANPLUS/Internals/Source/SQLite/Tie.pm\"\n    #   file_R = \"/tmp/8VxQG0OLbp/perl-5.16.3/cpan/CPANPLUS/lib/CPANPLUS/Internals/Source/SQLite/Tie.pm\"\n    #\n    # then return\n    #\n    #   \"perl-5.16.1\",\n    #   \"/tmp/8VxQG0OLbp/perl-5.16.3\",\n\n    my ($Vol_L, $Dir_L, $File_L) = File::Spec->splitpath($file_L);\n    my @x_L = File::Spec->splitdir( $Dir_L );\n    my ($Vol_R, $Dir_R, $File_R) = File::Spec->splitpath($file_R);\n    my @x_R = File::Spec->splitdir( $Dir_R );\n\n    my @common  = ();\n\n    # work backwards\n    while ($x_L[$#x_L] eq $x_R[$#x_R]) {\n        push @common, $x_L[$#x_L];\n        pop  @x_L;\n        pop  @x_R;\n    }\n    my $success = scalar @common;\n\n    my $dirs_L = File::Spec->catdir( @x_L );\n    my $dirs_R = File::Spec->catdir( @x_R );\n    my $lead_L = File::Spec->catpath( $Vol_L, $dirs_L, \"\" );\n    my $lead_R = File::Spec->catpath( $Vol_R, $dirs_R, \"\" );\n\n    return $lead_L, $lead_R, $success;\n\n} # 1}}}\nsub get_leading_dirs {                       # {{{1\n    my ($rh_file_list_L, $rh_file_list_R) = @_;\n    # find uniquely named files in both sets to help determine the\n    # leading directory positions\n    my %unique_filename = ();\n    my %basename_L = ();\n    my %basename_R = ();\n    foreach my $f (keys %{$rh_file_list_L}) {\n        my $bn = basename($f);\n        $basename_L{ $bn }{'count'}   += 1;\n        $basename_L{ $bn }{'fullpath'} = $f;\n    }\n    foreach my $f (keys %{$rh_file_list_R}) {\n        my $bn = basename($f);\n        $basename_R{ $bn }{'count'}   += 1;\n        $basename_R{ $bn }{'fullpath'} = $f;\n    }\n    foreach my $f (keys %basename_L) {\n        next unless $basename_L{$f}{'count'} == 1;\n        next unless defined $basename_R{$f} and $basename_R{$f}{'count'} == 1;\n        $unique_filename{$f}{'L'} = $basename_L{ $f }{'fullpath'};\n        $unique_filename{$f}{'R'} = $basename_R{ $f }{'fullpath'};\n    }\n    return undef, undef, 0 unless %unique_filename;\n\n    my %candidate_leading_dir_L = ();\n    my %candidate_leading_dir_R = ();\n    foreach my $f (keys %unique_filename) {\n        my $fL = $unique_filename{ $f }{'L'};\n        my $fR = $unique_filename{ $f }{'R'};\n#printf \"%-36s -> %-36s\\n\", $fL, $fR;\n        my $ptr_L = length($fL) - 1;\n        my $ptr_R = length($fR) - 1;\n        my @aL    = split '', $fL;\n        my @aR    = split '', $fR;\n        while ($ptr_L >= 0 and $ptr_R >= 0) {\n            last if $aL[$ptr_L] ne $aR[$ptr_R];\n            --$ptr_L;\n            --$ptr_R;\n        }\n#print \"ptr_L=$ptr_L   ptr_R=$ptr_R\\n\";\n        my $leading_dir_L = \"\";\n           $leading_dir_L = substr($fL, 0, $ptr_L+1) if $ptr_L >= 0;\n        my $leading_dir_R = \"\";\n           $leading_dir_R = substr($fR, 0, $ptr_R+1) if $ptr_R >= 0;\n#print \"leading_dir_L=$leading_dir_L   leading_dir_R=$leading_dir_R\\n\";\n        ++$candidate_leading_dir_L{$leading_dir_L};\n        ++$candidate_leading_dir_R{$leading_dir_R};\n    }\n#use Data::Dumper::Simple;\n#print Dumper(%candidate_leading_dir_L);\n#print Dumper(%candidate_leading_dir_R);\n#die;\n    my $best_L = (sort {\n               $candidate_leading_dir_L{$b} <=>\n               $candidate_leading_dir_L{$a}} keys %candidate_leading_dir_L)[0];\n    my $best_R = (sort {\n               $candidate_leading_dir_R{$b} <=>\n               $candidate_leading_dir_R{$a}} keys %candidate_leading_dir_R)[0];\n    return $best_L, $best_R, 1;\n} # 1}}}\nsub align_by_pairs {                         # {{{1\n    my ($rh_file_list_L        , # in\n        $rh_file_list_R        , # in\n        $ra_added              , # out\n        $ra_removed            , # out\n        $ra_compare_list       , # out\n        ) = @_;\n    print \"-> align_by_pairs()\\n\" if $opt_v > 2;\n    @{$ra_compare_list} = ();\n\n    my @files_L = sort keys %{$rh_file_list_L};\n    my @files_R = sort keys %{$rh_file_list_R};\n    return () unless @files_L or  @files_R;  # at least one must have stuff\n    if      ( @files_L and !@files_R) {\n        # left side has stuff, right side is empty; everything deleted\n        @{$ra_added   }     = ();\n        @{$ra_removed }     = @files_L;\n        @{$ra_compare_list} = ();\n        return;\n    } elsif (!@files_L and  @files_R) {\n        # left side is empty, right side has stuff; everything added\n        @{$ra_added   }     = @files_R;\n        @{$ra_removed }     = ();\n        @{$ra_compare_list} = ();\n        return;\n    }\n#use Data::Dumper::Simple;\n#print Dumper(\"align_by_pairs\", %{$rh_file_list_L}, %{$rh_file_list_R},);\n#die;\n    if (scalar @files_L == 1 and scalar @files_R == 1) {\n        # The easy case:  compare two files.\n        push @{$ra_compare_list}, [ $files_L[0],  $files_R[0] ];\n        @{$ra_added  } = ();\n        @{$ra_removed} = ();\n        return;\n    }\n    # The harder case:  compare groups of files.  This only works\n    # if the groups are in different directories so the first step\n    # is to strip the leading directory names from file lists to\n    # make it possible to align by file names.\n    my @files_L_minus_dir = undef;\n    my @files_R_minus_dir = undef;\n\n    my $deepest_file_L    = find_deepest_file(@files_L);\n    my $deepest_file_R    = find_deepest_file(@files_R);\n#print \"deepest L = [$deepest_file_L]\\n\";\n#print \"deepest R = [$deepest_file_R]\\n\";\n####my ($leading_dir_L, $leading_dir_R, $success) =\n####    find_uncommon_parent_dir($deepest_file_L, $deepest_file_R);\n    my ($leading_dir_L, $leading_dir_R, $success) =\n                get_leading_dirs($rh_file_list_L, $rh_file_list_R);\n#print \"leading_dir_L=[$leading_dir_L]\\n\";\n#print \"leading_dir_R=[$leading_dir_R]\\n\";\n#print \"success      =[$success]\\n\";\n    if ($success) {\n        @files_L_minus_dir = strip_leading_dir($leading_dir_L, @files_L);\n        @files_R_minus_dir = strip_leading_dir($leading_dir_R, @files_R);\n    } else {\n        # otherwise fall back to old strategy\n        @files_L_minus_dir = remove_leading_dir(@files_L);\n        @files_R_minus_dir = remove_leading_dir(@files_R);\n    }\n\n    # Keys of the stripped_X arrays are canonical file names;\n    # should overlap mostly.  Keys in stripped_L but not in\n    # stripped_R are files that have been deleted.  Keys in\n    # stripped_R but not in stripped_L have been added.\n    my %stripped_L = ();\n       @stripped_L{ @files_L_minus_dir } = @files_L;\n    my %stripped_R = ();\n       @stripped_R{ @files_R_minus_dir } = @files_R;\n\n    my %common = ();\n    foreach my $f (keys %stripped_L) {\n        $common{$f}  = 1 if     defined $stripped_R{$f};\n    }\n\n    my %deleted = ();\n    foreach my $f (keys %stripped_L) {\n        $deleted{$stripped_L{$f}} = $f unless defined $stripped_R{$f};\n    }\n\n    my %added = ();\n    foreach my $f (keys %stripped_R) {\n        $added{$stripped_R{$f}}   = $f unless defined $stripped_L{$f};\n    }\n\n#use Data::Dumper::Simple;\n#print Dumper(\"align_by_pairs\", %stripped_L, %stripped_R);\n#print Dumper(\"align_by_pairs\", %common, %added, %deleted);\n\n    foreach my $f (keys %common) {\n        push @{$ra_compare_list}, [ $stripped_L{$f},\n                                    $stripped_R{$f} ];\n    }\n    @{$ra_added   } = keys %added  ;\n    @{$ra_removed } = keys %deleted;\n\n    print \"<- align_by_pairs()\\n\" if $opt_v > 2;\n    return;\n#print Dumper(\"align_by_pairs\", @files_L_minus_dir, @files_R_minus_dir);\n#die;\n} # 1}}}\nsub html_header {                            # {{{1\n    my ($title , ) = @_;\n\n    print \"-> html_header\\n\" if $opt_v > 2;\n    return\n'<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n<meta name=\"GENERATOR\" content=\"cloc http://cloc.sourceforge.net\">\n' .\n\"\n<!-- Created by $script v$VERSION -->\n<title>$title</title>\n\" .\n'\n<style TYPE=\"text/css\">\n<!--\n    body {\n        color: black;\n        background-color: white;\n        font-family: monospace\n    }\n\n    .whitespace {\n        background-color: gray;\n    }\n\n    .comment {\n        color: gray;\n        font-style: italic;\n    }\n\n    .clinenum {\n        color: red;\n    }\n\n    .linenum {\n        color: green;\n    }\n -->\n</style>\n</head>\n<body>\n<pre><tt>\n';\n    print \"<- html_header\\n\" if $opt_v > 2;\n} # 1}}}\nsub html_end {                               # {{{1\nreturn\n'</tt></pre>\n</body>\n</html>\n';\n} # 1}}}\nsub die_unknown_lang {                       # {{{1\n    my ($lang, $option_name) = @_;\n    die \"Unknown language '$lang' used with $option_name option.  \" .\n        \"The command\\n  $script --show-lang\\n\" .\n        \"will print all recognized languages.  Language names are \" .\n        \"case sensitive.\\n\" ;\n} # 1}}}\nsub unicode_file {                           # {{{1\n    my $file = shift @_;\n\n    print \"-> unicode_file($file)\\n\" if $opt_v > 2;\n    return 0 if (-s $file > 2_000_000);\n    # don't bother trying to test binary files bigger than 2 MB\n\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        warn \"Unable to read $file; ignoring.\\n\";\n        return 0;\n    }\n    my @lines = <$IN>;\n    $IN->close;\n\n    if (unicode_to_ascii( join('', @lines) )) {\n        print \"<- unicode_file()\\n\" if $opt_v > 2;\n        return 1;\n    } else {\n        print \"<- unicode_file()\\n\" if $opt_v > 2;\n        return 0;\n    }\n\n} # 1}}}\nsub unicode_to_ascii {                       # {{{1\n    my $string = shift @_;\n\n    # A trivial attempt to convert UTF-16 little or big endian\n    # files into ASCII.  These files exhibit the following byte\n    # sequence:\n    #   byte   1:  255\n    #   byte   2:  254\n    #   byte   3:  ord of ASCII character\n    #   byte   4:    0\n    #   byte 3+i:  ord of ASCII character\n    #   byte 4+i:    0\n    # or\n    #   byte   1:  255\n    #   byte   2:  254\n    #   byte   3:    0\n    #   byte   4:  ord of ASCII character\n    #   byte 3+i:    0\n    #   byte 4+i:  ord of ASCII character\n\n    my $length  = length $string;\n#print \"length=$length\\n\";\n    return '' if $length <= 3;\n    my @unicode = split(//, $string);\n\n    # check the first 100 characters for big or little endian UTF-16 encoding\n    my $max_peek = $length < 200 ? $length : 200;\n    my @view_1   = ();\n    for (my $i = 2; $i < $max_peek; $i += 2) { push @view_1, $unicode[$i] }\n    my @view_2   = ();\n    for (my $i = 3; $i < $max_peek; $i += 2) { push @view_2, $unicode[$i] }\n\n    my $points_1 = 0;\n    foreach my $C (@view_1) {\n        ++$points_1 if (32 <= ord($C) and ord($C) <= 127) or ord($C) == 13\n                                                          or ord($C) == 10\n                                                          or ord($C) ==  9;\n    }\n\n    my $points_2 = 0;\n    foreach my $C (@view_2) {\n        ++$points_2 if (32 <= ord($C) and ord($C) <= 127) or ord($C) == 13\n                                                          or ord($C) == 10\n                                                          or ord($C) ==  9;\n    }\n#print \"points 1: $points_1\\n\";\n#print \"points 2: $points_2\\n\";\n\n    my $offset = undef;\n    if    ($points_1 > 90) { $offset = 2; }\n    elsif ($points_2 > 90) { $offset = 3; }\n    else                   { return '' }  # neither big or little endian UTF-16\n\n    my @ascii              = ();\n    for (my $i = $offset; $i < $length; $i += 2) { push @ascii, $unicode[$i]; }\n    return join(\"\", @ascii);\n} # 1}}}\nsub uncompress_archive_cmd {                 # {{{1\n    my ($archive_file, ) = @_;\n\n    # Wrap $archive_file in single or double quotes in the system\n    # commands below to avoid filename chicanery (including\n    # spaces in the names).\n\n    print \"-> uncompress_archive_cmd($archive_file)\\n\" if $opt_v > 2;\n    my $extract_cmd = \"\";\n    my $missing     = \"\";\n    if ($opt_extract_with) {\n        ( $extract_cmd = $opt_extract_with ) =~ s/>FILE</$archive_file/g;\n    } elsif (basename($archive_file) eq \"-\" and !$ON_WINDOWS) {\n        $extract_cmd = \"cat > -\";\n    } elsif (($archive_file =~ /\\.tar\\.(gz|Z)$/ or\n              $archive_file =~ /\\.tgz$/       ) and !$ON_WINDOWS)    {\n        if (external_utility_exists(\"gzip --version\")) {\n            if (external_utility_exists(\"tar --version\")) {\n                $extract_cmd = \"gzip -dc '$archive_file' | tar xf -\";\n            } else {\n                $missing = \"tar\";\n            }\n        } else {\n            $missing = \"gzip\";\n        }\n    } elsif ($archive_file =~ /\\.tar\\.bz2$/ and !$ON_WINDOWS)    {\n        if (external_utility_exists(\"bzip2 --help\")) {\n            if (external_utility_exists(\"tar --version\")) {\n                $extract_cmd = \"bzip2 -dc '$archive_file' | tar xf -\";\n            } else {\n                $missing = \"tar\";\n            }\n        } else {\n            $missing = \"bzip2\";\n        }\n    } elsif ($archive_file =~ /\\.tar\\.xz$/ and !$ON_WINDOWS)    {\n        if (external_utility_exists(\"unxz --version\")) {\n            if (external_utility_exists(\"tar --version\")) {\n                $extract_cmd = \"unxz -dc '$archive_file' | tar xf -\";\n            } else {\n                $missing = \"tar\";\n            }\n        } else {\n            $missing = \"bzip2\";\n        }\n    } elsif ($archive_file =~ /\\.tar$/ and !$ON_WINDOWS)    {\n        $extract_cmd = \"tar xf '$archive_file'\";\n    } elsif ($archive_file =~ /\\.src\\.rpm$/i and !$ON_WINDOWS) {\n        if (external_utility_exists(\"cpio --version\")) {\n            if (external_utility_exists(\"rpm2cpio\")) {\n                $extract_cmd = \"rpm2cpio '$archive_file' | cpio -i\";\n            } else {\n                $missing = \"rpm2cpio\";\n            }\n        } else {\n            $missing = \"bzip2\";\n        }\n    } elsif ($archive_file =~ /\\.zip$/i and !$ON_WINDOWS)    {\n        if (external_utility_exists(\"unzip\")) {\n            $extract_cmd = \"unzip -qq -d . '$archive_file'\";\n        } else {\n            $missing = \"unzip\";\n        }\n    } elsif ($archive_file =~ /\\.deb$/i and !$ON_WINDOWS)    {\n        # only useful if the .deb contains source code--most\n        # .deb files just have compiled executables\n        if (external_utility_exists(\"dpkg-deb\")) {\n            $extract_cmd = \"dpkg-deb -x '$archive_file' .\";\n        } else {\n            $missing = \"dpkg-deb\";\n        }\n    } elsif ($ON_WINDOWS and $archive_file =~ /\\.zip$/i) {\n        # zip on Windows, guess default Winzip install location\n        $extract_cmd = \"\";\n        my $WinZip = '\"C:\\\\Program Files\\\\WinZip\\\\WinZip32.exe\"';\n        if (external_utility_exists($WinZip)) {\n            $extract_cmd = \"$WinZip -e -o \\\"$archive_file\\\" .\";\n#print \"trace 5 extract_cmd=[$extract_cmd]\\n\";\n        } else {\n#print \"trace 6\\n\";\n            $missing = $WinZip;\n        }\n    }\n    print \"<- uncompress_archive_cmd\\n\" if $opt_v > 2;\n    if ($missing) {\n        die \"Unable to expand $archive_file because external\\n\",\n            \"utility '$missing' is not available.\\n\",\n            \"Another possibility is to use the --extract-with option.\\n\";\n    } else {\n        return $extract_cmd;\n    }\n}\n# 1}}}\nsub read_list_file {                         # {{{1\n    my ($file, ) = @_;\n\n    print \"-> read_list_file($file)\\n\" if $opt_v > 2;\n    my $IN = new IO::File $file, \"r\";\n    if (!defined $IN) {\n        warn \"Unable to read $file; ignoring.\\n\";\n        return ();\n    }\n    my @entry = ();\n    while (<$IN>) {\n        next if /^\\s*$/ or /^\\s*#/; # skip empty or commented lines\n        s/\\cM$//;  # DOS to Unix\n        chomp;\n        push @entry, $_;\n    }\n    $IN->close;\n\n    print \"<- read_list_file\\n\" if $opt_v > 2;\n    return @entry;\n}\n# 1}}}\nsub external_utility_exists {                # {{{1\n    my $exe = shift @_;\n\n    my $success      = 0;\n    if ($ON_WINDOWS) {\n        $success = 1 unless system $exe . ' > nul';\n    } else {\n        $success = 1 unless system $exe . ' >/dev/null 2>&1';\n        if (!$success) {\n            $success = 1 unless system \"which\" . \" $exe\" . ' >/dev/null 2>&1';\n        }\n    }\n\n    return $success;\n} # 1}}}\nsub write_xsl_file {                         # {{{1\n    my $OUT = new IO::File $CLOC_XSL, \"w\";\n    if (!defined $OUT) {\n        warn \"Unable to write $CLOC_XSL  $!\\n\";\n        return;\n    }\n    my $XSL =             # <style>  </style> {{{2\n'<?xml version=\"1.0\" encoding=\"US-ASCII\"?>\n<!-- XLS file by Paul Schwann, January 2009.\n     Fixes for by-file and by-file-by-lang by d_uragan, November 2010.\n     -->\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:output method=\"html\"/>\n  <xsl:template match=\"/\">\n    <html xmlns=\"http://www.w3.org/1999/xhtml\">\n      <head>\n        <title>CLOC Results</title>\n      </head>\n      <style type=\"text/css\">\n        table {\n          table-layout: auto;\n          border-collapse: collapse;\n          empty-cells: show;\n        }\n        td, th {\n          padding: 4px;\n        }\n        th {\n          background-color: #CCCCCC;\n        }\n        td {\n          text-align: center;\n        }\n        table, td, tr, th {\n          border: thin solid #999999;\n        }\n      </style>\n      <body>\n        <h3><xsl:value-of select=\"results/header\"/></h3>\n';\n# 2}}}\n\n    if ($opt_by_file) {\n        $XSL .=             # <table> </table>{{{2\n'        <table>\n          <thead>\n            <tr>\n              <th>File</th>\n              <th>Blank</th>\n              <th>Comment</th>\n              <th>Code</th>\n              <th>Language</th>\n';\n        $XSL .=\n'             <th>3<sup>rd</sup> Generation Equivalent</th>\n              <th>Scale</th>\n' if $opt_3;\n        $XSL .=\n'           </tr>\n          </thead>\n          <tbody>\n          <xsl:for-each select=\"results/files/file\">\n            <tr>\n              <th><xsl:value-of select=\"@name\"/></th>\n              <td><xsl:value-of select=\"@blank\"/></td>\n              <td><xsl:value-of select=\"@comment\"/></td>\n              <td><xsl:value-of select=\"@code\"/></td>\n              <td><xsl:value-of select=\"@language\"/></td>\n';\n        $XSL .=\n'             <td><xsl:value-of select=\"@factor\"/></td>\n              <td><xsl:value-of select=\"@scaled\"/></td>\n' if $opt_3;\n        $XSL .=\n'           </tr>\n          </xsl:for-each>\n            <tr>\n              <th>Total</th>\n              <th><xsl:value-of select=\"results/files/total/@blank\"/></th>\n              <th><xsl:value-of select=\"results/files/total/@comment\"/></th>\n              <th><xsl:value-of select=\"results/files/total/@code\"/></th>\n              <th><xsl:value-of select=\"results/files/total/@language\"/></th>\n';\n        $XSL .=\n'             <th><xsl:value-of select=\"results/files/total/@factor\"/></th>\n              <th><xsl:value-of select=\"results/files/total/@scaled\"/></th>\n' if $opt_3;\n        $XSL .=\n'           </tr>\n          </tbody>\n        </table>\n        <br/>\n';\n# 2}}}\n    }\n\n    if (!$opt_by_file or $opt_by_file_by_lang) {\n        $XSL .=             # <table> </table> {{{2\n'       <table>\n          <thead>\n            <tr>\n              <th>Language</th>\n              <th>Files</th>\n              <th>Blank</th>\n              <th>Comment</th>\n              <th>Code</th>\n';\n        $XSL .=\n'             <th>Scale</th>\n              <th>3<sup>rd</sup> Generation Equivalent</th>\n' if $opt_3;\n        $XSL .=\n'           </tr>\n          </thead>\n          <tbody>\n          <xsl:for-each select=\"results/languages/language\">\n            <tr>\n              <th><xsl:value-of select=\"@name\"/></th>\n              <td><xsl:value-of select=\"@files_count\"/></td>\n              <td><xsl:value-of select=\"@blank\"/></td>\n              <td><xsl:value-of select=\"@comment\"/></td>\n              <td><xsl:value-of select=\"@code\"/></td>\n';\n        $XSL .=\n'             <td><xsl:value-of select=\"@factor\"/></td>\n              <td><xsl:value-of select=\"@scaled\"/></td>\n' if $opt_3;\n        $XSL .=\n'          </tr>\n          </xsl:for-each>\n            <tr>\n              <th>Total</th>\n              <th><xsl:value-of select=\"results/languages/total/@sum_files\"/></th>\n              <th><xsl:value-of select=\"results/languages/total/@blank\"/></th>\n              <th><xsl:value-of select=\"results/languages/total/@comment\"/></th>\n              <th><xsl:value-of select=\"results/languages/total/@code\"/></th>\n';\n        $XSL .=\n'             <th><xsl:value-of select=\"results/languages/total/@factor\"/></th>\n              <th><xsl:value-of select=\"results/languages/total/@scaled\"/></th>\n' if $opt_3;\n        $XSL .=\n'           </tr>\n          </tbody>\n        </table>\n';\n# 2}}}\n    }\n\n    $XSL.= <<'EO_XSL'; # {{{2\n      </body>\n    </html>\n  </xsl:template>\n</xsl:stylesheet>\n\nEO_XSL\n# 2}}}\n\n    my $XSL_DIFF = <<'EO_DIFF_XSL'; # {{{2\n<?xml version=\"1.0\" encoding=\"US-ASCII\"?>\n<!-- XLS file by Blazej Kroll, November 2010 -->\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <xsl:output method=\"html\"/>\n  <xsl:template match=\"/\">\n    <html xmlns=\"http://www.w3.org/1999/xhtml\">\n      <head>\n        <title>CLOC Results</title>\n      </head>\n      <style type=\"text/css\">\n        table {\n          table-layout: auto;\n          border-collapse: collapse;\n          empty-cells: show;\n          margin: 1em;\n        }\n        td, th {\n          padding: 4px;\n        }\n        th {\n          background-color: #CCCCCC;\n        }\n        td {\n          text-align: center;\n        }\n        table, td, tr, th {\n          border: thin solid #999999;\n        }\n      </style>\n      <body>\n        <h3><xsl:value-of select=\"results/header\"/></h3>\nEO_DIFF_XSL\n# 2}}}\n\n    if ($opt_by_file) {\n        $XSL_DIFF.= <<'EO_DIFF_XSL'; # {{{2\n        <table>\n          <thead>\n          <tr><th colspan=\"4\">Same</th>\n          </tr>\n            <tr>\n              <th>File</th>\n              <th>Blank</th>\n              <th>Comment</th>\n              <th>Code</th>\n            </tr>\n          </thead>\n          <tbody>\n          <xsl:for-each select=\"diff_results/same/file\">\n            <tr>\n              <th><xsl:value-of select=\"@name\"/></th>\n              <td><xsl:value-of select=\"@blank\"/></td>\n              <td><xsl:value-of select=\"@comment\"/></td>\n              <td><xsl:value-of select=\"@code\"/></td>\n            </tr>\n          </xsl:for-each>\n          </tbody>\n        </table>\n\n        <table>\n          <thead>\n          <tr><th colspan=\"4\">Modified</th>\n          </tr>\n            <tr>\n              <th>File</th>\n              <th>Blank</th>\n              <th>Comment</th>\n              <th>Code</th>\n            </tr>\n          </thead>\n          <tbody>\n          <xsl:for-each select=\"diff_results/modified/file\">\n            <tr>\n              <th><xsl:value-of select=\"@name\"/></th>\n              <td><xsl:value-of select=\"@blank\"/></td>\n              <td><xsl:value-of select=\"@comment\"/></td>\n              <td><xsl:value-of select=\"@code\"/></td>\n            </tr>\n          </xsl:for-each>\n          </tbody>\n        </table>\n\n        <table>\n          <thead>\n          <tr><th colspan=\"4\">Added</th>\n          </tr>\n            <tr>\n              <th>File</th>\n              <th>Blank</th>\n              <th>Comment</th>\n              <th>Code</th>\n            </tr>\n          </thead>\n          <tbody>\n          <xsl:for-each select=\"diff_results/added/file\">\n            <tr>\n              <th><xsl:value-of select=\"@name\"/></th>\n              <td><xsl:value-of select=\"@blank\"/></td>\n              <td><xsl:value-of select=\"@comment\"/></td>\n              <td><xsl:value-of select=\"@code\"/></td>\n            </tr>\n          </xsl:for-each>\n          </tbody>\n        </table>\n\n        <table>\n          <thead>\n          <tr><th colspan=\"4\">Removed</th>\n          </tr>\n            <tr>\n              <th>File</th>\n              <th>Blank</th>\n              <th>Comment</th>\n              <th>Code</th>\n            </tr>\n          </thead>\n          <tbody>\n          <xsl:for-each select=\"diff_results/removed/file\">\n            <tr>\n              <th><xsl:value-of select=\"@name\"/></th>\n              <td><xsl:value-of select=\"@blank\"/></td>\n              <td><xsl:value-of select=\"@comment\"/></td>\n              <td><xsl:value-of select=\"@code\"/></td>\n            </tr>\n          </xsl:for-each>\n          </tbody>\n        </table>\nEO_DIFF_XSL\n# 2}}}\n    }\n\n    if (!$opt_by_file or $opt_by_file_by_lang) {\n        $XSL_DIFF.= <<'EO_DIFF_XSL'; # {{{2\n        <table>\n          <thead>\n          <tr><th colspan=\"5\">Same</th>\n          </tr>\n            <tr>\n              <th>Language</th>\n              <th>Files</th>\n              <th>Blank</th>\n              <th>Comment</th>\n              <th>Code</th>\n            </tr>\n          </thead>\n          <tbody>\n          <xsl:for-each select=\"diff_results/same/language\">\n            <tr>\n              <th><xsl:value-of select=\"@name\"/></th>\n              <td><xsl:value-of select=\"@files_count\"/></td>\n              <td><xsl:value-of select=\"@blank\"/></td>\n              <td><xsl:value-of select=\"@comment\"/></td>\n              <td><xsl:value-of select=\"@code\"/></td>\n            </tr>\n          </xsl:for-each>\n          </tbody>\n        </table>\n\n        <table>\n          <thead>\n          <tr><th colspan=\"5\">Modified</th>\n          </tr>\n            <tr>\n              <th>Language</th>\n              <th>Files</th>\n              <th>Blank</th>\n              <th>Comment</th>\n              <th>Code</th>\n            </tr>\n          </thead>\n          <tbody>\n          <xsl:for-each select=\"diff_results/modified/language\">\n            <tr>\n              <th><xsl:value-of select=\"@name\"/></th>\n              <td><xsl:value-of select=\"@files_count\"/></td>\n              <td><xsl:value-of select=\"@blank\"/></td>\n              <td><xsl:value-of select=\"@comment\"/></td>\n              <td><xsl:value-of select=\"@code\"/></td>\n            </tr>\n          </xsl:for-each>\n          </tbody>\n        </table>\n\n        <table>\n          <thead>\n          <tr><th colspan=\"5\">Added</th>\n          </tr>\n            <tr>\n              <th>Language</th>\n              <th>Files</th>\n              <th>Blank</th>\n              <th>Comment</th>\n              <th>Code</th>\n            </tr>\n          </thead>\n          <tbody>\n          <xsl:for-each select=\"diff_results/added/language\">\n            <tr>\n              <th><xsl:value-of select=\"@name\"/></th>\n              <td><xsl:value-of select=\"@files_count\"/></td>\n              <td><xsl:value-of select=\"@blank\"/></td>\n              <td><xsl:value-of select=\"@comment\"/></td>\n              <td><xsl:value-of select=\"@code\"/></td>\n            </tr>\n          </xsl:for-each>\n          </tbody>\n        </table>\n\n        <table>\n          <thead>\n          <tr><th colspan=\"5\">Removed</th>\n          </tr>\n            <tr>\n              <th>Language</th>\n              <th>Files</th>\n              <th>Blank</th>\n              <th>Comment</th>\n              <th>Code</th>\n            </tr>\n          </thead>\n          <tbody>\n          <xsl:for-each select=\"diff_results/removed/language\">\n            <tr>\n              <th><xsl:value-of select=\"@name\"/></th>\n              <td><xsl:value-of select=\"@files_count\"/></td>\n              <td><xsl:value-of select=\"@blank\"/></td>\n              <td><xsl:value-of select=\"@comment\"/></td>\n              <td><xsl:value-of select=\"@code\"/></td>\n            </tr>\n          </xsl:for-each>\n          </tbody>\n        </table>\nEO_DIFF_XSL\n# 2}}}\n\n    }\n\n    $XSL_DIFF.= <<'EO_DIFF_XSL'; # {{{2\n      </body>\n    </html>\n  </xsl:template>\n</xsl:stylesheet>\nEO_DIFF_XSL\n# 2}}}\n    if ($opt_diff) {\n        print $OUT $XSL_DIFF;\n    } else {\n        print $OUT $XSL;\n    }\n    $OUT->close();\n} # 1}}}\nsub normalize_file_names {                   # {{{1\n    my (@files, ) = @_;\n\n    # Returns a hash of file names reduced to a canonical form\n    # (fully qualified file names, all path separators changed to /,\n    # Windows file names lowercased).  Hash values are the original\n    # file name.\n\n    my %normalized = ();\n    foreach my $F (@files) {\n        my $F_norm = $F;\n        if ($ON_WINDOWS) {\n            $F_norm = lc $F_norm; # for case insensitive file name comparisons\n            $F_norm =~ s{\\\\}{/}g; # Windows directory separators to Unix\n            $F_norm =~ s{^\\./}{}g;  # remove leading ./\n            if (($F_norm !~ m{^/}) and ($F_norm !~ m{^\\w:/})) {\n                # looks like a relative path; prefix with cwd\n                $F_norm = lc \"$cwd/$F_norm\";\n            }\n        } else {\n            $F_norm =~ s{^\\./}{}g;  # remove leading ./\n            if ($F_norm !~ m{^/}) {\n                # looks like a relative path; prefix with cwd\n                $F_norm = lc \"$cwd/$F_norm\";\n            }\n        }\n        # Remove trailing / so it does not interfere with further regex code\n        # that does not expect it\n        $F_norm =~ s{/+$}{};\n        $normalized{ $F_norm } = $F;\n    }\n    return %normalized;\n} # 1}}}\nsub combine_diffs {                          # {{{1\n    # subroutine by Andy (awalshe@sf.net)\n    # https://sourceforge.net/tracker/?func=detail&aid=3261017&group_id=174787&atid=870625\n    my ($ra_files) = @_;\n\n    my $res   = \"$URL v $VERSION\\n\";\n    my $dl    = '-';\n    my $width = 79;\n    # columns are in this order\n    my @cols  = ('files', 'blank', 'comment', 'code');\n    my %HoH   = ();\n\n    foreach my $file (@{$ra_files}) {\n        my $IN = new IO::File $file, \"r\";\n        if (!defined $IN) {\n            warn \"Unable to read $file; ignoring.\\n\";\n            next;\n        }\n\n        my $sec;\n        while (<$IN>) {\n            chomp;\n            s/\\cM$//;\n            next if /^(http|Language|-----)/;\n            if (/^[A-Za-z0-9]+/) {        # section title\n                $sec = $_;\n                chomp($sec);\n                $HoH{$sec} = () if ! exists $HoH{$sec};\n                next;\n            }\n\n            if (/^\\s(same|modified|added|removed)/) {  # calculated totals row\n                my @ar = grep { $_ ne '' } split(/ /, $_);\n                chomp(@ar);\n                my $ttl = shift @ar;\n                my $i = 0;\n                foreach(@ar) {\n                    my $t = \"${ttl}${dl}${cols[$i]}\";\n                    $HoH{$sec}{$t} = 0 if ! exists $HoH{$sec}{$t};\n                    $HoH{$sec}{$t} += $_;\n                    $i++;\n                }\n            }\n        }\n        $IN->close;\n    }\n\n    # rows are in this order\n    my @rows = ('same', 'modified', 'added', 'removed');\n\n    $res .= sprintf(\"%s\\n\", \"-\" x $width);\n    $res .= sprintf(\"%-19s %14s %14s %14s %14s\\n\", 'Language',\n                    $cols[0], $cols[1], $cols[2], $cols[3]);\n    $res .= sprintf(\"%s\\n\", \"-\" x $width);\n\n    for my $sec ( keys %HoH ) {\n        next if $sec =~ /SUM:/;\n        $res .= \"$sec\\n\";\n        foreach (@rows) {\n            $res .= sprintf(\" %-18s %14s %14s %14s %14s\\n\",\n                            $_, $HoH{$sec}{\"${_}${dl}${cols[0]}\"},\n                                $HoH{$sec}{\"${_}${dl}${cols[1]}\"},\n                                $HoH{$sec}{\"${_}${dl}${cols[2]}\"},\n                                $HoH{$sec}{\"${_}${dl}${cols[3]}\"});\n        }\n    }\n    $res .= sprintf(\"%s\\n\", \"-\" x $width);\n    my $sec = 'SUM:';\n    $res .= \"$sec\\n\";\n    foreach (@rows) {\n        $res .= sprintf(\" %-18s %14s %14s %14s %14s\\n\",\n                        $_, $HoH{$sec}{\"${_}${dl}${cols[0]}\"},\n                            $HoH{$sec}{\"${_}${dl}${cols[1]}\"},\n                            $HoH{$sec}{\"${_}${dl}${cols[2]}\"},\n                            $HoH{$sec}{\"${_}${dl}${cols[3]}\"});\n    }\n    $res .= sprintf(\"%s\\n\", \"-\" x $width);\n\n    return $res;\n} # 1}}}\nsub get_time {                               # {{{1\n    if ($HAVE_Time_HiRes) {\n        return Time::HiRes::time();\n    } else {\n        return time();\n    }\n} # 1}}}\nsub really_is_D {                            # {{{1\n    # Ref bug 131, files ending with .d could be init.d scripts\n    # instead of D language source files.\n    my ($file        , # in\n        $rh_Err      , # in   hash of error codes\n        $raa_errors  , # out\n       ) = @_;\n    print \"-> really_is_D($file)\\n\" if $opt_v > 2;\n    my $possible_script = peek_at_first_line($file, $rh_Err, $raa_errors);\n\n    print \"<- really_is_D($file)\\n\" if $opt_v > 2;\n    return $possible_script;    # null string if D, otherwise a language\n} # 1}}}\n# subroutines copied from SLOCCount\nmy %lex_files    = ();  # really_is_lex()\nmy %expect_files = ();  # really_is_expect()\nmy %php_files    = ();  # really_is_php()\nsub really_is_lex {                          # {{{1\n# Given filename, returns TRUE if its contents really is lex.\n# lex file must have \"%%\", \"%{\", and \"%}\".\n# In theory, a lex file doesn't need \"%{\" and \"%}\", but in practice\n# they all have them, and requiring them avoid mislabeling a\n# non-lexfile as a lex file.\n\n my $filename = shift;\n chomp($filename);\n\n my $is_lex = 0;      # Value to determine.\n my $percent_percent = 0;\n my $percent_opencurly = 0;\n my $percent_closecurly = 0;\n\n # Return cached result, if available:\n if ($lex_files{$filename}) { return $lex_files{$filename};}\n\n open(LEX_FILE, \"<$filename\") ||\n      die \"Can't open $filename to determine if it's lex.\\n\";\n while(<LEX_FILE>) {\n   $percent_percent++     if (m/^\\s*\\%\\%/);\n   $percent_opencurly++   if (m/^\\s*\\%\\{/);\n   $percent_closecurly++   if (m/^\\s*\\%\\}/);\n }\n close(LEX_FILE);\n\n if ($percent_percent && $percent_opencurly && $percent_closecurly)\n          {$is_lex = 1;}\n\n $lex_files{$filename} = $is_lex; # Store result in cache.\n\n return $is_lex;\n} # 1}}}\nsub really_is_expect {                       # {{{1\n# Given filename, returns TRUE if its contents really are Expect.\n# Many \"exp\" files (such as in Apache and Mesa) are just \"export\" data,\n# summarizing something else # (e.g., its interface).\n# Sometimes (like in RPM) it's just misc. data.\n# Thus, we need to look at the file to determine\n# if it's really an \"expect\" file.\n\n my $filename = shift;\n chomp($filename);\n\n# The heuristic is as follows: it's Expect _IF_ it:\n# 1. has \"load_lib\" command and either \"#\" comments or {}.\n# 2. {, }, and one of: proc, if, [...], expect\n\n my $is_expect = 0;      # Value to determine.\n\n my $begin_brace = 0;  # Lines that begin with curly braces.\n my $end_brace = 0;    # Lines that begin with curly braces.\n my $load_lib = 0;     # Lines with the Load_lib command.\n my $found_proc = 0;\n my $found_if = 0;\n my $found_brackets = 0;\n my $found_expect = 0;\n my $found_pound = 0;\n\n # Return cached result, if available:\n if ($expect_files{$filename}) { return expect_files{$filename};}\n\n open(EXPECT_FILE, \"<$filename\") ||\n      die \"Can't open $filename to determine if it's expect.\\n\";\n while(<EXPECT_FILE>) {\n\n   if (m/#/) {$found_pound++; s/#.*//;}\n   if (m/^\\s*\\{/) { $begin_brace++;}\n   if (m/\\{\\s*$/) { $begin_brace++;}\n   if (m/^\\s*\\}/) { $end_brace++;}\n   if (m/\\};?\\s*$/) { $end_brace++;}\n   if (m/^\\s*load_lib\\s+\\S/) { $load_lib++;}\n   if (m/^\\s*proc\\s/) { $found_proc++;}\n   if (m/^\\s*if\\s/) { $found_if++;}\n   if (m/\\[.*\\]/) { $found_brackets++;}\n   if (m/^\\s*expect\\s/) { $found_expect++;}\n }\n close(EXPECT_FILE);\n\n if ($load_lib && ($found_pound || ($begin_brace && $end_brace)))\n          {$is_expect = 1;}\n if ( $begin_brace && $end_brace &&\n      ($found_proc || $found_if || $found_brackets || $found_expect))\n          {$is_expect = 1;}\n\n $expect_files{$filename} = $is_expect; # Store result in cache.\n\n return $is_expect;\n} # 1}}}\nsub really_is_pascal {                       # {{{1\n# Given filename, returns TRUE if its contents really are Pascal.\n\n# This isn't as obvious as it seems.\n# Many \".p\" files are Perl files\n# (such as /usr/src/redhat/BUILD/ispell-3.1/dicts/czech/glob.p),\n# others are C extractions\n# (such as /usr/src/redhat/BUILD/linux/include/linux/umsdos_fs.p\n# and some files in linuxconf).\n# However, test files in \"p2c\" really are Pascal, for example.\n\n# Note that /usr/src/redhat/BUILD/ucd-snmp-4.1.1/ov/bitmaps/UCD.20.p\n# is actually C code.  The heuristics determine that they're not Pascal,\n# but because it ends in \".p\" it's not counted as C code either.\n# I believe this is actually correct behavior, because frankly it\n# looks like it's automatically generated (it's a bitmap expressed as code).\n# Rather than guess otherwise, we don't include it in a list of\n# source files.  Let's face it, someone who creates C files ending in \".p\"\n# and expects them to be counted by default as C files in SLOCCount needs\n# their head examined.  I suggest examining their head\n# with a sucker rod (see syslogd(8) for more on sucker rods).\n\n# This heuristic counts as Pascal such files such as:\n#  /usr/src/redhat/BUILD/teTeX-1.0/texk/web2c/tangleboot.p\n# Which is hand-generated.  We don't count woven documents now anyway,\n# so this is justifiable.\n\n my $filename = shift;\n chomp($filename);\n\n# The heuristic is as follows: it's Pascal _IF_ it has all of the following\n# (ignoring {...} and (*...*) comments):\n# 1. \"^..program NAME\" or \"^..unit NAME\",\n# 2. \"procedure\", \"function\", \"^..interface\", or \"^..implementation\",\n# 3. a \"begin\", and\n# 4. it ends with \"end.\",\n#\n# Or it has all of the following:\n# 1. \"^..module NAME\" and\n# 2. it ends with \"end.\".\n#\n# Or it has all of the following:\n# 1. \"^..program NAME\",\n# 2. a \"begin\", and\n# 3. it ends with \"end.\".\n#\n# The \"end.\" requirements in particular filter out non-Pascal.\n#\n# Note (jgb): this does not detect Pascal main files in fpc, like\n# fpc-1.0.4/api/test/testterminfo.pas, which does not have \"program\" in\n# it\n\n my $is_pascal = 0;      # Value to determine.\n\n my $has_program = 0;\n my $has_unit = 0;\n my $has_module = 0;\n my $has_procedure_or_function = 0;\n my $found_begin = 0;\n my $found_terminating_end = 0;\n my $has_begin = 0;\n\n open(PASCAL_FILE, \"<$filename\") ||\n      die \"Can't open $filename to determine if it's pascal.\\n\";\n while(<PASCAL_FILE>) {\n   s/\\{.*?\\}//g;  # Ignore {...} comments on this line; imperfect, but effective.\n   s/\\(\\*.*?\\*\\)//g;  # Ignore (*...*) comments on this line; imperfect, but effective.\n   if (m/\\bprogram\\s+[A-Za-z]/i)  {$has_program=1;}\n   if (m/\\bunit\\s+[A-Za-z]/i)     {$has_unit=1;}\n   if (m/\\bmodule\\s+[A-Za-z]/i)   {$has_module=1;}\n   if (m/\\bprocedure\\b/i)         { $has_procedure_or_function = 1; }\n   if (m/\\bfunction\\b/i)          { $has_procedure_or_function = 1; }\n   if (m/^\\s*interface\\s+/i)      { $has_procedure_or_function = 1; }\n   if (m/^\\s*implementation\\s+/i) { $has_procedure_or_function = 1; }\n   if (m/\\bbegin\\b/i) { $has_begin = 1; }\n   # Originally I said:\n   # \"This heuristic fails if there are multi-line comments after\n   # \"end.\"; I haven't seen that in real Pascal programs:\"\n   # But jgb found there are a good quantity of them in Debian, specially in\n   # fpc (at the end of a lot of files there is a multiline comment\n   # with the changelog for the file).\n   # Therefore, assume Pascal if \"end.\" appears anywhere in the file.\n   if (m/end\\.\\s*$/i) {$found_terminating_end = 1;}\n#   elsif (m/\\S/) {$found_terminating_end = 0;}\n }\n close(PASCAL_FILE);\n\n # Okay, we've examined the entire file looking for clues;\n # let's use those clues to determine if it's really Pascal:\n\n if ( ( ($has_unit || $has_program) && $has_procedure_or_function &&\n     $has_begin && $found_terminating_end ) ||\n      ( $has_module && $found_terminating_end ) ||\n      ( $has_program && $has_begin && $found_terminating_end ) )\n          {$is_pascal = 1;}\n\n return $is_pascal;\n} # 1}}}\nsub really_is_incpascal {                    # {{{1\n# Given filename, returns TRUE if its contents really are Pascal.\n# For .inc files (mainly seen in fpc)\n\n my $filename = shift;\n chomp($filename);\n\n# The heuristic is as follows: it is Pascal if any of the following:\n# 1. really_is_pascal returns true\n# 2. Any usual reserved word is found (program, unit, const, begin...)\n\n # If the general routine for Pascal files works, we have it\n if (really_is_pascal($filename)) {\n   return 1;\n }\n\n my $is_pascal = 0;      # Value to determine.\n my $found_begin = 0;\n\n open(PASCAL_FILE, \"<$filename\") ||\n      die \"Can't open $filename to determine if it's pascal.\\n\";\n while(<PASCAL_FILE>) {\n   s/\\{.*?\\}//g;  # Ignore {...} comments on this line; imperfect, but effective.\n   s/\\(\\*.*?\\*\\)//g;  # Ignore (*...*) comments on this line; imperfect, but effective.\n   if (m/\\bprogram\\s+[A-Za-z]/i)  {$is_pascal=1;}\n   if (m/\\bunit\\s+[A-Za-z]/i)     {$is_pascal=1;}\n   if (m/\\bmodule\\s+[A-Za-z]/i)   {$is_pascal=1;}\n   if (m/\\bprocedure\\b/i)         {$is_pascal = 1; }\n   if (m/\\bfunction\\b/i)          {$is_pascal = 1; }\n   if (m/^\\s*interface\\s+/i)      {$is_pascal = 1; }\n   if (m/^\\s*implementation\\s+/i) {$is_pascal = 1; }\n   if (m/\\bconstant\\s+/i)         {$is_pascal=1;}\n   if (m/\\bbegin\\b/i) { $found_begin = 1; }\n   if ((m/end\\.\\s*$/i) && ($found_begin = 1)) {$is_pascal = 1;}\n   if ($is_pascal) {\n     last;\n   }\n }\n\n close(PASCAL_FILE);\n return $is_pascal;\n} # 1}}}\nsub really_is_php {                          # {{{1\n# Given filename, returns TRUE if its contents really is php.\n\n my $filename = shift;\n chomp($filename);\n\n my $is_php = 0;      # Value to determine.\n # Need to find a matching pair of surrounds, with ending after beginning:\n my $normal_surround = 0;  # <?; bit 0 = <?, bit 1 = ?>\n my $script_surround = 0;  # <script..>; bit 0 = <script language=\"php\">\n my $asp_surround = 0;     # <%; bit 0 = <%, bit 1 = %>\n\n # Return cached result, if available:\n if ($php_files{$filename}) { return $php_files{$filename};}\n\n open(PHP_FILE, \"<$filename\") ||\n      die \"Can't open $filename to determine if it's php.\\n\";\n while(<PHP_FILE>) {\n   if (m/\\<\\?/)                           { $normal_surround |= 1; }\n   if (m/\\?\\>/ && ($normal_surround & 1)) { $normal_surround |= 2; }\n   if (m/\\<script.*language=\"?php\"?/i)    { $script_surround |= 1; }\n   if (m/\\<\\/script\\>/i && ($script_surround & 1)) { $script_surround |= 2; }\n   if (m/\\<\\%/)                           { $asp_surround |= 1; }\n   if (m/\\%\\>/ && ($asp_surround & 1)) { $asp_surround |= 2; }\n }\n close(PHP_FILE);\n\n if ( ($normal_surround == 3) || ($script_surround == 3) ||\n      ($asp_surround == 3)) {\n   $is_php = 1;\n }\n\n $php_files{$filename} = $is_php; # Store result in cache.\n\n return $is_php;\n} # 1}}}\n__END__\nmode values (stat $item)[2]\n       Unix    Windows\nfile:  33188   33206\ndir :  16832   16895\nlink:  33261   33206\npipe:   4544    null\n"}